#+OPTIONS: num:nil toc:nil
#+REVEAL_TRANS: linear
#+REVEAL_THEME: jr0cket
#+Title: T-io
#+Author:  Ye Zhaoliang
#+Email: yezhaoliang@ncepu.edu.cn
* 11. T-io版本发布历史
:PROPERTIES:
:ID:       e065e50e-f484-43e6-882d-aa507dd26ec6
:END:
** 11.3 t-io 3.2.2
:PROPERTIES:
:ID:       efcde747-197c-4412-a476-003ccbc9f9af
:END:
tio-http 模块的升级

*** 修改点

[tio-utils]：优化tio内置的Cache框架

•	Tio.java部分方法调整
•	[tio-http]：HttpRequest增加很多便捷的方法用于获取参数

#+BEGIN_SRC java
1.	  getObject(String name)
2.	  getString(String name)
3.	  getUploadFile(String name)
4.	  getInt(String name)
5.	  getShort(String name)
6.	  getLong(String name)
7.	  getDouble(String name)
8.	  getFloat(String name)
#+END_SRC


#+BEGIN_SRC java
•	[tio-http]：增加和优化forward()
org.tio.http.common.HttpRequest.forward(String)
org.tio.http.server.util.Resps.forward(HttpRequest, String)
•	[tio-http]：优化404, 500处理，由原来的redirect改为forward，用户体验更棒一些
•	[tio-http]：注释中内置forward字段，用起来跟nginx的rewrite差不多
@RequestPath(value = “/{adid}”, forward = “/ad/methodB”)
public HttpResponse methodA(Integer adid, HttpRequest request) throws Exception {…}
外部访问”/ad/12345”，对内的处理逻辑就是”/ad/methodB?adid=12345”
•	[tio-websocket]：优化一个小的编码问题，减少新对象的创建
#+END_SRC

最新pom

#+BEGIN_SRC java
1.	<dependency>
2.	    <groupId>org.t-io</groupId>
3.	    <artifactId>tio-core</artifactId>
4.	    <version>3.2.2.v20181122-RELEASE</version>
5.	</dependency>
#+END_SRC


** 11.2 t-io 3.2.3
:PROPERTIES:
:ID:       479f1064-71ea-4e13-bd59-867bbbfca10d
:END:
*** 修改点
•	[tio-utils]：增加和优化forward()
•	zookpeer，重连策略换成RetryForever
•	[tio-core]
•	ChannelContext.java增加属性
•	logWhenDecodeError: 解码异常时，是否打印异常日志
•	heartbeatTimeout : https://gitee.com/tywo45/t-io/issues/IP9WY
•	[tio-http]
•	限流接口重新设计，更灵活，更多主动权下放到业务端
•	HttpRequest增加isForward，用于处理forward的请求
•	对于http，ip黑名单判断放在请求头解析完成时进行
最新pom

#+BEGIN_SRC java
1.	<dependency>
2.	    <groupId>org.t-io</groupId>
3.	    <artifactId>tio-core</artifactId>
4.	    <version>3.2.3.v20181212-RELEASE</version>
5.	</dependency>
#+END_SRC


** 11.1 t-io 3.2.4
:PROPERTIES:
:ID:       9bc1d955-1f32-457c-a50b-01c4b34bfc02
:END:

一张图了解t-io的历史和能力
[[file:img/11.1talent.png][tio的历史和能力]]
一张图了解t-io及官方衍生品
[[file:img/11.1extend.png][tio衍生品]]

*** 修改点
•	新需求：https://gitee.com/tywo45/t-io/issues/IOZQB
•	增加org.tio.utils.lock.ReadLockHandler
•	增加org.tio.utils.lock.WriteLockHandler
•	优化http解码过程中的字符编码(对于ws原来是固定utf-8的，现在改成可配)
•	拉黑相关的从GroupContext移到ServerGroupContext
•	ws握手包改名，原名：handshakeRequestPacket，现名：handshakeRequest
•	合并PR
最新pom


#+BEGIN_SRC java
  1.	<dependency>
  2.	    <groupId>org.t-io</groupId>
  3.	    <artifactId>tio-core</artifactId>
  4.	    <version>3.2.4.v20181218-RELEASE</version>
  5.	</dependency>

#+END_SRC

例行说明
•	t-io是OSC官方人员（还不止一个^_^，此处 @红薯 应该来辟谣）也在使用的通讯框架，譬如这个网站的动弹：http://lifes77.com
•	欢迎来https://www.t-io.org/guide, 用t-io写的t-io官网（注：官网用的是tio-core、tio-http、tio-websocket、tio-webpack，并未使用类似tomcat这样的容器），

* 10. T-io源代码分析
:PROPERTIES:
:ID:       18b9627a-1b9e-42b6-9408-ddcaa696259a
:END:
** 10.1 t-io对半包和粘包的处理
:PROPERTIES:
:ID:       ccfa6372-0ffb-4de7-a3ce-5f4ac7cea662
:END:
*** 概述
•	t-io对数据的解码是在DecodeRunnable中完成的，一个TCP连接对应一个DecodeRunnable
•	半包粘包的处理也都在DecodeRunnable中完成的

*** 先上源代码

#+BEGIN_SRC java
  1.	package org.tio.core.task;
  2.	
  3.	import java.nio.BufferUnderflowException;
  4.	import java.nio.ByteBuffer;
  5.	import java.util.List;
  6.	import java.util.concurrent.Executor;
  7.	
  8.	import org.slf4j.Logger;
  9.	import org.slf4j.LoggerFactory;
  10.	import org.tio.core.ChannelContext;
  11.	import org.tio.core.GroupContext;
  12.	import org.tio.core.Tio;
  13.	import org.tio.core.exception.AioDecodeException;
  14.	import org.tio.core.intf.Packet;
  15.	import org.tio.core.stat.ChannelStat;
  16.	import org.tio.core.stat.IpStat;
  17.	import org.tio.core.utils.ByteBufferUtils;
  18.	import org.tio.utils.SystemTimer;
  19.	import org.tio.utils.thread.pool.AbstractQueueRunnable;
  20.	
  21.	/**
  22.	 * 解码任务对象，一个连接对应一个本对象
  23.	 *
  24.	 * @author 谭耀武
  25.	 * 2012-08-09
  26.	 */
  27.	public class DecodeRunnable extends AbstractQueueRunnable<ByteBuffer> {
  28.	    private static final Logger log = LoggerFactory.getLogger(DecodeRunnable.class);
  29.	
  30.	    /**
  31.	     *
  32.	     * @param packet
  33.	     * @param byteCount
  34.	     * @author tanyaowu
  35.	     */
  36.	    public void handler(Packet packet, int byteCount) {
  37.	        switch (groupContext.packetHandlerMode) {
  38.	        case QUEUE:
  39.	            channelContext.handlerRunnable.addMsg(packet);
  40.	            channelContext.handlerRunnable.execute();
  41.	            break;
  42.	        default:
  43.	            channelContext.handlerRunnable.handler(packet);
  44.	            break;
  45.	        }
  46.	    }
  47.	
  48.	    private ChannelContext channelContext = null;
  49.	
  50.	    private GroupContext groupContext = null;
  51.	
  52.	    /**
  53.	     * 上一次解码剩下的数据
  54.	     */
  55.	    private ByteBuffer lastByteBuffer = null;
  56.	
  57.	    /**
  58.	     * 新收到的数据
  59.	     */
  60.	    private ByteBuffer newByteBuffer = null;
  61.	
  62.	    /**
  63.	     *
  64.	     */
  65.	    public DecodeRunnable(ChannelContext channelContext, Executor executor) {
  66.	        super(executor);
  67.	        this.channelContext = channelContext;
  68.	        this.groupContext = channelContext.groupContext;
  69.	    }
  70.	
  71.	    /**
  72.	     * 清空处理的队列消息
  73.	     */
  74.	    public void clearMsgQueue() {
  75.	        super.clearMsgQueue();
  76.	        lastByteBuffer = null;
  77.	        newByteBuffer = null;
  78.	    }
  79.	
  80.	    @Override
  81.	    public void runTask() {
  82.	        while ((newByteBuffer = msgQueue.poll()) != null) {
  83.	            decode();
  84.	        }
  85.	    }
  86.	
  87.	    /**
  88.	     * @see java.lang.Runnable#run()
  89.	     *
  90.	     * @author tanyaowu
  91.	     * 2017年3月21日 下午4:26:39
  92.	     *
  93.	     */
  94.	    public void decode() {
  95.	        ByteBuffer byteBuffer = newByteBuffer;
  96.	        if (lastByteBuffer != null) {
  97.	            byteBuffer = ByteBufferUtils.composite(lastByteBuffer, byteBuffer);
  98.	            lastByteBuffer = null;
  99.	        }
  100.	
  101.	        label_2: while (true) {
  102.	            try {
  103.	                int initPosition = byteBuffer.position();
  104.	                int limit = byteBuffer.limit();
  105.	                int readableLength = limit - initPosition;
  106.	                Packet packet = null;
  107.	                if (channelContext.packetNeededLength != null) {
  108.	                    log.info("{}, 解码所需长度:{}", channelContext, channelContext.packetNeededLength);
  109.	                    if (readableLength >= channelContext.packetNeededLength) {
  110.	                        packet = groupContext.getAioHandler().decode(byteBuffer, limit, initPosition, readableLength, channelContext);
  111.	                    }
  112.	                } else {
  113.	                    try {
  114.	                        packet = groupContext.getAioHandler().decode(byteBuffer, limit, initPosition, readableLength, channelContext);
  115.	                    } catch (BufferUnderflowException e) {
  116.	                        //log.error(e.toString(), e);
  117.	                        //数据不够读
  118.	                    }
  119.	                }
  120.	
  121.	                if (packet == null)// 数据不够，解不了码
  122.	                {
  123.	                    //                    lastByteBuffer = ByteBufferUtils.copy(byteBuffer, initPosition, limit);
  124.	                    if (groupContext.useQueueDecode || (byteBuffer != newByteBuffer)) {
  125.	                        byteBuffer.position(initPosition);
  126.	                        byteBuffer.limit(limit);
  127.	                        lastByteBuffer = byteBuffer;
  128.	                    } else {
  129.	                        lastByteBuffer = ByteBufferUtils.copy(byteBuffer, initPosition, limit);
  130.	                    }
  131.	                    ChannelStat channelStat = channelContext.stat;
  132.	                    channelStat.decodeFailCount++;
  133.	                    //                    int len = byteBuffer.limit() - initPosition;
  134.	                    log.debug("{} 本次解码失败, 已经连续{}次解码失败，参与解码的数据长度共{}字节", channelContext, channelStat.decodeFailCount, readableLength);
  135.	                    if (channelStat.decodeFailCount > 5) {
  136.	                        if (channelContext.packetNeededLength == null) {
  137.	                            log.info("{} 本次解码失败, 已经连续{}次解码失败，参与解码的数据长度共{}字节", channelContext, channelStat.decodeFailCount, readableLength);
  138.	                        }
  139.	
  140.	                        //检查慢包攻击（只有自用版才有）
  141.	                        if (channelStat.decodeFailCount > 10) {
  142.	                            //                            int capacity = lastByteBuffer.capacity();
  143.	                            int per = readableLength / channelStat.decodeFailCount;
  144.	                            if (per < Math.min(groupContext.getReadBufferSize() / 2, 256)) {
  145.	                                String str = "连续解码" + channelStat.decodeFailCount + "次都不成功，并且平均每次接收到的数据为" + per + "字节，有慢攻击的嫌疑";
  146.	                                log.error(str);
  147.	                                throw new AioDecodeException(str);
  148.	                            }
  149.	                        }
  150.	                    }
  151.	                    return;
  152.	                } else //解码成功
  153.	                {
  154.	                    channelContext.setPacketNeededLength(null);
  155.	                    channelContext.stat.latestTimeOfReceivedPacket = SystemTimer.currTime;
  156.	                    channelContext.stat.decodeFailCount = 0;
  157.	
  158.	                    int len = byteBuffer.position() - initPosition;
  159.	                    packet.setByteCount(len);
  160.	
  161.	                    if (groupContext.statOn) {
  162.	                        groupContext.groupStat.receivedPackets.incrementAndGet();
  163.	                        channelContext.stat.receivedPackets.incrementAndGet();
  164.	                    }
  165.	
  166.	                    if (groupContext.ipStats.durationList != null && groupContext.ipStats.durationList.size() > 0) {
  167.	                        try {
  168.	                            for (Long v : groupContext.ipStats.durationList) {
  169.	                                IpStat ipStat = groupContext.ipStats.get(v, channelContext.getClientNode().getIp());
  170.	                                ipStat.getReceivedPackets().incrementAndGet();
  171.	                                groupContext.getIpStatListener().onAfterDecoded(channelContext, packet, len, ipStat);
  172.	                            }
  173.	                        } catch (Exception e1) {
  174.	                            log.error(packet.logstr(), e1);
  175.	                        }
  176.	                    }
  177.	
  178.	                    if (groupContext.getAioListener() != null) {
  179.	                        try {
  180.	                            groupContext.getAioListener().onAfterDecoded(channelContext, packet, len);
  181.	                        } catch (Throwable e) {
  182.	                            log.error(e.toString(), e);
  183.	                        }
  184.	                    }
  185.	
  186.	                    if (log.isDebugEnabled()) {
  187.	                        log.debug("{}, 解包获得一个packet:{}", channelContext, packet.logstr());
  188.	                    }
  189.	
  190.	                    handler(packet, len);
  191.	
  192.	                    if (byteBuffer.hasRemaining())//组包后，还剩有数据
  193.	                    {
  194.	                        if (log.isDebugEnabled()) {
  195.	                            log.debug("{},组包后，还剩有数据:{}", channelContext, byteBuffer.remaining());
  196.	                        }
  197.	                        continue label_2;
  198.	                    } else//组包后，数据刚好用完
  199.	                    {
  200.	                        lastByteBuffer = null;
  201.	                        log.debug("{},组包后，数据刚好用完", channelContext);
  202.	                        return;
  203.	                    }
  204.	                }
  205.	            } catch (Throwable e) {
  206.	                if (channelContext.logWhenDecodeError) {
  207.	                    log.error("解码时遇到异常", e);
  208.	                }
  209.	
  210.	                channelContext.setPacketNeededLength(null);
  211.	
  212.	                if (e instanceof AioDecodeException) {
  213.	                    List<Long> list = groupContext.ipStats.durationList;
  214.	                    if (list != null && list.size() > 0) {
  215.	                        try {
  216.	                            for (Long v : list) {
  217.	                                IpStat ipStat = groupContext.ipStats.get(v, channelContext.getClientNode().getIp());
  218.	                                ipStat.getDecodeErrorCount().incrementAndGet();
  219.	                                groupContext.getIpStatListener().onDecodeError(channelContext, ipStat);
  220.	                            }
  221.	                        } catch (Exception e1) {
  222.	                            log.error(e1.toString(), e1);
  223.	                        }
  224.	                    }
  225.	                }
  226.	
  227.	                Tio.close(channelContext, e, "解码异常:" + e.getMessage());
  228.	                return;
  229.	            }
  230.	        }
  231.	    }
  232.	
  233.	    /**
  234.	     * @param newByteBuffer the newByteBuffer to set
  235.	     */
  236.	    public void setNewByteBuffer(ByteBuffer newByteBuffer) {
  237.	        this.newByteBuffer = newByteBuffer;
  238.	    }
  239.	
  240.	    @Override
  241.	    public String toString() {
  242.	        return this.getClass().getSimpleName() + ":" + channelContext.toString();
  243.	    }
  244.	
  245.	    @Override
  246.	    public String logstr() {
  247.	        return toString();
  248.	    }
  249.	}

#+END_SRC

*** 源代码解说
**** 对于半包
业务端需要在AioHandler.decode()里返回一个null对象给框架，框架拿到null后，就会认为这是个半包，进而把收到的数据暂存到DecodeRunnable.lastByteBuffer，当后面再收到数据时，把DecodeRunnable.lastByteBuffer和新收到的数据组成一个新的bytebuffer给业务端，如此循环，直到业务端能组成一个packet对象给框架层。
**** 对于粘包
业务端在AioHandler.decode()方法中，解码一个packet对象返回给框架后，框架会自行判断是否有多余的byte没有被处理，如果有，则拿剩下的byte(bytebuffer)让业务端继续解码，直到业务端返回null或是返回packet但没有剩余byte为止。
**** 小结
框架层已经做好半包和粘包的工作，业务层只需要按着业务协议解码即可，框架会处理好剩下的byte或是上次没处理完的byte的。
如果还有什么不理解的，请在右侧聊天区域进行留言讨论！

* 9. T-io提供的工具类
:PROPERTIES:
:ID:       06e7fa7d-4d7e-44f8-8170-6579b18e920e
:END:
** 9.2基于quartz封装的定时任务
:PROPERTIES:
:ID:       c60fb3a1-38eb-44f9-a660-1a89c23214d7
:END:
定时任务不须多言，几乎是每个项目必备功能，而原生的quartz用起来着实有点哆嗦，市面上也有不少依赖spring的定时任务组件，因为笔者本人已经完全抛弃spring（笔者还抛弃了servlet），所以自己动手对quartz进行了简单封装，使其更容易开发和维护！

*** 编写pom.xml

#+BEGIN_SRC java
  1.	<dependency>
  2.	    <groupId>org.quartz-scheduler</groupId>
  3.	    <artifactId>quartz</artifactId>
  4.	    <version>2.3.0</version>
  5.	</dependency>
  6.	<dependency>
  7.	    <groupId>org.quartz-scheduler</groupId>
  8.	    <artifactId>quartz-jobs</artifactId>
  9.	    <version>2.3.0</version>
  10.	</dependency>
  11.	<dependency>
  12.	  <groupId>org.t-io</groupId>
  13.	  <artifactId>tio-core</artifactId>
  14.	  <version>3.2.4.v20181218-RELEASE</version>
  15.	</dependency>

#+END_SRC

*** 创建任务类

#+BEGIN_SRC java
  1.	package demo.timetask;
  2.	
  3.	import org.quartz.JobExecutionContext;
  4.	import org.tio.utils.quartz.AbstractJobWithLog;
  5.	
  6.	/**
  7.	 * 
  8.	 * @author tanyw
  9.	 *
  10.	 */
  11.	public class DemoTask extends AbstractJobWithLog {
  12.	
  13.	    /**
  14.	     * 生成博客网站地址
  15.	     */
  16.	    @Override
  17.	    public void run(JobExecutionContext context) throws Exception {
  18.	        System.out.println(context);
  19.	    }
  20.	
  21.	}

#+END_SRC

*** 创建配置文件
在src/main/resources/config目录下创建tio-quartz.properties文件，内容如下：


#+BEGIN_SRC java
  1.	#每10秒执行一次
  2.	demo.timetask.DemoTask = 0/10 * * * * ?

#+END_SRC

*** 在主程序中启动定时任务

#+BEGIN_SRC java

  1.	public static void main(String[] args) throws Exception {
  2.	    //你的其它启动代码
  3.	    //启动配置在config/tio-quartz.properties的所有定时任务
  4.	    QuartzUtils.start();
  5.	}
#+END_SRC

** 9.1 类似J2Cache的tio-cache
:PROPERTIES:
:ID:       0c11303e-22bb-43d4-89b4-60ec5d9d9b1a
:END:
* 8. 基于tio-websocket生产项目的聊天室
:PROPERTIES:
:ID:       3d2f594d-28e9-4c94-b984-72884e9320c9
:END:
** 8.11 结束语和后记
:PROPERTIES:
:ID:       ae947208-0e20-4121-b414-48e375256404
:END:
文档总是不如代码来得实际，笔者花大量精力提供了可用于实战的示范工程，就是让大家以极少的代价掌握t-io，然而还是有很多用户更愿意花大量时间去啃书本，觉得啃书本是个好方法，进而埋怨t-io提供的文档实在太少，对于这个论调，我国著名诗人陆游早就说过：“纸上得来终觉浅，绝知此事要躬行”，为什么很多朋友在t-io文档量几乎为0的情况下用t-io快速完成了生产项目，原因就是他们更愿意笔者提供的示范代码！
** 8.10 写一个js client
:PROPERTIES:
:ID:       318cbb0c-e7cd-4af7-a83f-2e69aaa3147c
:END:

为了简化js端websocket的开发，本人写了一个简单的小js，它的名字叫tiows.js，它处理了重连、发心跳等很多开发人员不愿意去干的活。
它的源代码在：https://gitee.com/tywo45/tio-websocket-showcase
把源代码下载下来后，在page/tio/目录中就能看到tiows.js
然后再打开page/index.html，就能看到下面这个界面了（前提是前面8步要完成），如果你不想完成前面8步，你同样可以在https://gitee.com/tywo45/tio-websocket-showcase，中找到前8步所需要的java代码。

** 8.9启动服务器
:PROPERTIES:
:ID:       7e6ae3eb-2f98-4ce3-b167-edec9a100720
:END:

在eclipse中以main函数的形式运行org.tio.showcase.http.HttpServerShowcaseStarter，能看到类似如下的日志

#+BEGIN_SRC java
1.	2018-12-28 19:53:09,907 INFO  org.tio.server.TioServer[158]: 
2.	|----------------------------------------------------------------------------------------|
3.	| Tio gitee address | https://gitee.com/tywo45/t-io                                      |
4.	| Tio site address  | https://t-io.org/                                                  |
5.	| Tio version       | 3.2.4.v20181218-RELEASE                                            |
6.	| ---------------------------------------------------------------------------------------|
7.	| GroupContext name | showcase                                                           |
8.	| Started at        | 2018-12-28 19:53:09                                                |
9.	| Listen on         | 0.0.0.0:9326                                                       |
10.	| Main Class        | org.tio.showcase.websocket.server.ShowcaseWebsocketStarter         |
11.	| Jvm start time    | 507 ms                                                             |
12.	| Tio start time    | 1 ms                                                               |
13.	| Pid               | 19020                                                              |
14.	|----------------------------------------------------------------------------------------|
#+END_SRC


** 8.8 项目启动项
:PROPERTIES:
:ID:       32e399d7-91e0-4376-9874-88d12621db4d
:END:

#+BEGIN_SRC java
  1.	package org.tio.showcase.websocket.server;
  2.	
  3.	import java.io.IOException;
  4.	
  5.	import org.tio.server.ServerGroupContext;
  6.	import org.tio.showcase.http.init.HttpServerInit;
  7.	import org.tio.utils.jfinal.P;
  8.	import org.tio.websocket.server.WsServerStarter;
  9.	
  10.	/**
  11.	* @author tanyaowu
  12.	* 2017年6月28日 下午5:34:04
  13.	*/
  14.	public class ShowcaseWebsocketStarter {
  15.	
  16.	private WsServerStarter wsServerStarter;
  17.	private ServerGroupContext serverGroupContext;
  18.	
  19.	/**
  20.	*
  21.	* @author tanyaowu
  22.	*/
  23.	public ShowcaseWebsocketStarter(int port, ShowcaseWsMsgHandler wsMsgHandler) throws Exception {
  24.	wsServerStarter = new WsServerStarter(port, wsMsgHandler);
  25.	
  26.	serverGroupContext = wsServerStarter.getServerGroupContext();
  27.	serverGroupContext.setName(ShowcaseServerConfig.PROTOCOL_NAME);
  28.	serverGroupContext.setServerAioListener(ShowcaseServerAioListener.me);
  29.	
  30.	//设置ip监控
  31.	serverGroupContext.setIpStatListener(ShowcaseIpStatListener.me);
  32.	//设置ip统计时间段
  33.	serverGroupContext.ipStats.addDurations(ShowcaseServerConfig.IpStatDuration.IPSTAT_DURATIONS);
  34.	
  35.	//设置心跳超时时间
  36.	serverGroupContext.setHeartbeatTimeout(ShowcaseServerConfig.HEARTBEAT_TIMEOUT);
  37.	
  38.	if (P.getInt("ws.use.ssl", 1) == 1) {
  39.	//如果你希望通过wss来访问，就加上下面的代码吧，不过首先你得有SSL证书（证书必须和域名相匹配，否则可能访问不了ssl）
  40.	// String keyStoreFile = "classpath:config/ssl/keystore.jks";
  41.	// String trustStoreFile = "classpath:config/ssl/keystore.jks";
  42.	// String keyStorePwd = "214323428310224";
  43.	
  44.	
  45.	String keyStoreFile = P.get("ssl.keystore", null);
  46.	String trustStoreFile = P.get("ssl.truststore", null);
  47.	String keyStorePwd = P.get("ssl.pwd", null);
  48.	serverGroupContext.useSsl(keyStoreFile, trustStoreFile, keyStorePwd);
  49.	}
  50.	}
  51.	
  52.	/**
  53.	* @param args
  54.	* @author tanyaowu
  55.	* @throws IOException
  56.	*/
  57.	public static void start() throws Exception {
  58.	ShowcaseWebsocketStarter appStarter = new ShowcaseWebsocketStarter(ShowcaseServerConfig.SERVER_PORT, ShowcaseWsMsgHandler.me);
  59.	appStarter.wsServerStarter.start();
  60.	}
  61.	
  62.	/**
  63.	* @return the serverGroupContext
  64.	*/
  65.	public ServerGroupContext getServerGroupContext() {
  66.	return serverGroupContext;
  67.	}
  68.	
  69.	public WsServerStarter getWsServerStarter() {
  70.	return wsServerStarter;
  71.	}
  72.	
  73.	public static void main(String[] args) throws Exception {
  74.	//启动http server，这个步骤不是必须的，但是为了用页面演示websocket，所以先启动http
  75.	P.use("app.properties");
  76.	
  77.	
  78.	if (P.getInt("start.http", 1) == 1) {
  79.	HttpServerInit.init();
  80.	}
  81.	
  82.	//启动websocket server
  83.	start();
  84.	}
  85.	
  86.	}

#+END_SRC

** 8.7 内置常量
:PROPERTIES:
:ID:       2d192dd0-87ac-42b9-9800-5597f8f148d3
:END:

#+BEGIN_SRC java
  4.	package org.tio.showcase.websocket.server;
  5.	
  6.	/**
  7.	* @author tanyaowu
  8.	*
  9.	*/
  10.	public class Const {
  11.	/**
  12.	* 用于群聊的group id
  13.	*/
  14.	public static final String GROUP_ID = "showcase-websocket";
  15.	}

#+END_SRC

** 8.6 参考配置
:PROPERTIES:
:ID:       31abfb8c-4061-4f96-a14c-01958d376933
:END:

#+BEGIN_SRC java
  4.	package org.tio.showcase.websocket.server;
  5.	
  6.	import org.tio.utils.time.Time;
  7.	
  8.	/**
  9.	* @author tanyaowu
  10.	*
  11.	*/
  12.	public abstract class ShowcaseServerConfig {
  13.	/**
  14.	* 协议名字(可以随便取，主要用于开发人员辨识)
  15.	*/
  16.	public static final String PROTOCOL_NAME = "showcase";
  17.	
  18.	public static final String CHARSET = "utf-8";
  19.	/**
  20.	* 监听的ip
  21.	*/
  22.	public static final String SERVER_IP = null;//null表示监听所有，并不指定ip
  23.	
  24.	/**
  25.	* 监听端口
  26.	*/
  27.	public static final int SERVER_PORT = 9326;
  28.	
  29.	/**
  30.	* 心跳超时时间，单位：毫秒
  31.	*/
  32.	public static final int HEARTBEAT_TIMEOUT = 1000 * 60;
  33.	
  34.	/**
  35.	* ip数据监控统计，时间段
  36.	* @author tanyaowu
  37.	*
  38.	*/
  39.	public static interface IpStatDuration {
  40.	public static final Long DURATION_1 = Time.MINUTE_1 * 5;
  41.	public static final Long[] IPSTAT_DURATIONS = new Long[] { DURATION_1 };
  42.	}
  43.	
  44.	}

#+END_SRC

** 8.5 IpStatListener实现(可选)
:PROPERTIES:
:ID:       5001b6af-0f54-4f81-91ed-c9dd55e91c94
:END:

#+BEGIN_SRC java

  4.	package org.tio.showcase.websocket.server;
  5.	
  6.	import org.slf4j.Logger;
  7.	import org.slf4j.LoggerFactory;
  8.	import org.tio.core.ChannelContext;
  9.	import org.tio.core.GroupContext;
  10.	import org.tio.core.intf.Packet;
  11.	import org.tio.core.stat.IpStat;
  12.	import org.tio.core.stat.IpStatListener;
  13.	
  14.	/**
  15.	* 
  16.	* @author tanyaowu
  17.	*
  18.	*/
  19.	public class ShowcaseIpStatListener implements IpStatListener {
  20.	@SuppressWarnings("unused")
  21.	private static Logger log = LoggerFactory.getLogger(ShowcaseIpStatListener.class);
  22.	
  23.	public static final ShowcaseIpStatListener me = new ShowcaseIpStatListener();
  24.	
  25.	/**
  26.	* 
  27.	*/
  28.	private ShowcaseIpStatListener() {
  29.	}
  30.	
  31.	@Override
  32.	public void onExpired(GroupContext groupContext, IpStat ipStat) {
  33.	//在这里把统计数据入库中或日志
  34.	// if (log.isInfoEnabled()) {
  35.	// log.info("可以把统计数据入库\r\n{}", Json.toFormatedJson(ipStat));
  36.	// }
  37.	}
  38.	
  39.	@Override
  40.	public void onAfterConnected(ChannelContext channelContext, boolean isConnected, boolean isReconnect, IpStat ipStat) throws Exception {
  41.	// if (log.isInfoEnabled()) {
  42.	// log.info("onAfterConnected\r\n{}", Json.toFormatedJson(ipStat));
  43.	// }
  44.	}
  45.	
  46.	@Override
  47.	public void onDecodeError(ChannelContext channelContext, IpStat ipStat) {
  48.	// if (log.isInfoEnabled()) {
  49.	// log.info("onDecodeError\r\n{}", Json.toFormatedJson(ipStat));
  50.	// }
  51.	}
  52.	
  53.	@Override
  54.	public void onAfterSent(ChannelContext channelContext, Packet packet, boolean isSentSuccess, IpStat ipStat) throws Exception {
  55.	// if (log.isInfoEnabled()) {
  56.	// log.info("onAfterSent\r\n{}\r\n{}", packet.logstr(), Json.toFormatedJson(ipStat));
  57.	// }
  58.	}
  59.	
  60.	@Override
  61.	public void onAfterDecoded(ChannelContext channelContext, Packet packet, int packetSize, IpStat ipStat) throws Exception {
  62.	// if (log.isInfoEnabled()) {
  63.	// log.info("onAfterDecoded\r\n{}\r\n{}", packet.logstr(), Json.toFormatedJson(ipStat));
  64.	// }
  65.	}
  66.	
  67.	@Override
  68.	public void onAfterReceivedBytes(ChannelContext channelContext, int receivedBytes, IpStat ipStat) throws Exception {
  69.	// if (log.isInfoEnabled()) {
  70.	// log.info("onAfterReceivedBytes\r\n{}", Json.toFormatedJson(ipStat));
  71.	// }
  72.	}
  73.	
  74.	@Override
  75.	public void onAfterHandled(ChannelContext channelContext, Packet packet, IpStat ipStat, long cost) throws Exception {
  76.	// if (log.isInfoEnabled()) {
  77.	// log.info("onAfterHandled\r\n{}\r\n{}", packet.logstr(), Json.toFormatedJson(ipStat));
  78.	// }
  79.	}
  80.	
  81.	}
#+END_SRC

** 8.4 WsServerAioListener
:PROPERTIES:
:ID:       e826ab1f-e55c-41bb-a25a-aaed32c3b09e
:END:

#+BEGIN_SRC java
  4.	package org.tio.showcase.websocket.server;
  5.	
  6.	import org.slf4j.Logger;
  7.	import org.slf4j.LoggerFactory;
  8.	import org.tio.core.Tio;
  9.	import org.tio.core.ChannelContext;
  10.	import org.tio.core.intf.Packet;
  11.	import org.tio.websocket.common.WsResponse;
  12.	import org.tio.websocket.common.WsSessionContext;
  13.	import org.tio.websocket.server.WsServerAioListener;
  14.	
  15.	/**
  16.	* @author tanyaowu
  17.	* 用户根据情况来完成该类的实现
  18.	*/
  19.	public class ShowcaseServerAioListener extends WsServerAioListener {
  20.	private static Logger log = LoggerFactory.getLogger(ShowcaseServerAioListener.class);
  21.	
  22.	public static final ShowcaseServerAioListener me = new ShowcaseServerAioListener();
  23.	
  24.	private ShowcaseServerAioListener() {
  25.	
  26.	}
  27.	
  28.	@Override
  29.	public void onAfterConnected(ChannelContext channelContext, boolean isConnected, boolean isReconnect) throws Exception {
  30.	super.onAfterConnected(channelContext, isConnected, isReconnect);
  31.	if (log.isInfoEnabled()) {
  32.	log.info("onAfterConnected\r\n{}", channelContext);
  33.	}
  34.	
  35.	}
  36.	
  37.	@Override
  38.	public void onAfterSent(ChannelContext channelContext, Packet packet, boolean isSentSuccess) throws Exception {
  39.	super.onAfterSent(channelContext, packet, isSentSuccess);
  40.	if (log.isInfoEnabled()) {
  41.	log.info("onAfterSent\r\n{}\r\n{}", packet.logstr(), channelContext);
  42.	}
  43.	}
  44.	
  45.	@Override
  46.	public void onBeforeClose(ChannelContext channelContext, Throwable throwable, String remark, boolean isRemove) throws Exception {
  47.	super.onBeforeClose(channelContext, throwable, remark, isRemove);
  48.	if (log.isInfoEnabled()) {
  49.	log.info("onBeforeClose\r\n{}", channelContext);
  50.	}
  51.	
  52.	WsSessionContext wsSessionContext = (WsSessionContext) channelContext.getAttribute();
  53.	
  54.	if (wsSessionContext != null && wsSessionContext.isHandshaked()) {
  55.	
  56.	int count = Tio.getAllChannelContexts(channelContext.groupContext).getObj().size();
  57.	
  58.	String msg = channelContext.getClientNode().toString() + " 离开了，现在共有【" + count + "】人在线";
  59.	//用tio-websocket，服务器发送到客户端的Packet都是WsResponse
  60.	WsResponse wsResponse = WsResponse.fromText(msg, ShowcaseServerConfig.CHARSET);
  61.	//群发
  62.	Tio.sendToGroup(channelContext.groupContext, Const.GROUP_ID, wsResponse);
  63.	}
  64.	}
  65.	
  66.	@Override
  67.	public void onAfterDecoded(ChannelContext channelContext, Packet packet, int packetSize) throws Exception {
  68.	super.onAfterDecoded(channelContext, packet, packetSize);
  69.	if (log.isInfoEnabled()) {
  70.	log.info("onAfterDecoded\r\n{}\r\n{}", packet.logstr(), channelContext);
  71.	}
  72.	}
  73.	
  74.	@Override
  75.	public void onAfterReceivedBytes(ChannelContext channelContext, int receivedBytes) throws Exception {
  76.	super.onAfterReceivedBytes(channelContext, receivedBytes);
  77.	if (log.isInfoEnabled()) {
  78.	log.info("onAfterReceivedBytes\r\n{}", channelContext);
  79.	}
  80.	}
  81.	
  82.	@Override
  83.	public void onAfterHandled(ChannelContext channelContext, Packet packet, long cost) throws Exception {
  84.	super.onAfterHandled(channelContext, packet, cost);
  85.	if (log.isInfoEnabled()) {
  86.	log.info("onAfterHandled\r\n{}\r\n{}", packet.logstr(), channelContext);
  87.	}
  88.	}
  89.	
  90.	}

#+END_SRC

** 8.3 IWsMsgHandler实现
:PROPERTIES:
:ID:       98b9f2f9-d20f-433e-9f0c-fa6ca1d3007e
:END:

#+BEGIN_SRC java
  1.	package org.tio.showcase.websocket.server;
  2.	
  3.	import java.util.Objects;
  4.	
  5.	import org.slf4j.Logger;
  6.	import org.slf4j.LoggerFactory;
  7.	import org.tio.core.Tio;
  8.	import org.tio.core.ChannelContext;
  9.	import org.tio.http.common.HttpRequest;
  10.	import org.tio.http.common.HttpResponse;
  11.	import org.tio.websocket.common.WsRequest;
  12.	import org.tio.websocket.common.WsResponse;
  13.	import org.tio.websocket.common.WsSessionContext;
  14.	import org.tio.websocket.server.handler.IWsMsgHandler;
  15.	
  16.	/**
  17.	* @author tanyaowu
  18.	* 2017年6月28日 下午5:32:38
  19.	*/
  20.	public class ShowcaseWsMsgHandler implements IWsMsgHandler {
  21.	private static Logger log = LoggerFactory.getLogger(ShowcaseWsMsgHandler.class);
  22.	
  23.	public static final ShowcaseWsMsgHandler me = new ShowcaseWsMsgHandler();
  24.	
  25.	private ShowcaseWsMsgHandler() {
  26.	
  27.	}
  28.	
  29.	/**
  30.	* 握手时走这个方法，业务可以在这里获取cookie，request参数等
  31.	*/
  32.	@Override
  33.	public HttpResponse handshake(HttpRequest request, HttpResponse httpResponse, ChannelContext channelContext) throws Exception {
  34.	String clientip = request.getClientIp();
  35.	String myname = request.getParam("name");
  36.	
  37.	Tio.bindUser(channelContext, myname);
  38.	// channelContext.setUserid(myname);
  39.	log.info("收到来自{}的ws握手包\r\n{}", clientip, request.toString());
  40.	return httpResponse;
  41.	}
  42.	
  43.	/** 
  44.	* @param httpRequest
  45.	* @param httpResponse
  46.	* @param channelContext
  47.	* @throws Exception
  48.	* @author tanyaowu
  49.	*/
  50.	@Override
  51.	public void onAfterHandshaked(HttpRequest httpRequest, HttpResponse httpResponse, ChannelContext channelContext) throws Exception {
  52.	//绑定到群组，后面会有群发
  53.	Tio.bindGroup(channelContext, Const.GROUP_ID);
  54.	int count = Tio.getAllChannelContexts(channelContext.groupContext).getObj().size();
  55.	
  56.	String msg = "{name:'admin',message:'" + channelContext.userid + " 进来了，共【" + count + "】人在线" + "'}";
  57.	//用tio-websocket，服务器发送到客户端的Packet都是WsResponse
  58.	WsResponse wsResponse = WsResponse.fromText(msg, ShowcaseServerConfig.CHARSET);
  59.	//群发
  60.	Tio.sendToGroup(channelContext.groupContext, Const.GROUP_ID, wsResponse);
  61.	}
  62.	
  63.	/**
  64.	* 字节消息（binaryType = arraybuffer）过来后会走这个方法
  65.	*/
  66.	@Override
  67.	public Object onBytes(WsRequest wsRequest, byte[] bytes, ChannelContext channelContext) throws Exception {
  68.	return null;
  69.	}
  70.	
  71.	/**
  72.	* 当客户端发close flag时，会走这个方法
  73.	*/
  74.	@Override
  75.	public Object onClose(WsRequest wsRequest, byte[] bytes, ChannelContext channelContext) throws Exception {
  76.	Tio.remove(channelContext, "receive close flag");
  77.	return null;
  78.	}
  79.	
  80.	/*
  81.	* 字符消息（binaryType = blob）过来后会走这个方法
  82.	*/
  83.	@Override
  84.	public Object onText(WsRequest wsRequest, String text, ChannelContext channelContext) throws Exception {
  85.	WsSessionContext wsSessionContext = (WsSessionContext) channelContext.getAttribute();
  86.	HttpRequest httpRequest = wsSessionContext.getHandshakeRequest();//获取websocket握手包
  87.	if (log.isDebugEnabled()) {
  88.	log.debug("握手包:{}", httpRequest);
  89.	}
  90.	
  91.	log.info("收到ws消息:{}", text);
  92.	
  93.	if (Objects.equals("心跳内容", text)) {
  94.	return null;
  95.	}
  96.	//channelContext.getToken()
  97.	//String msg = channelContext.getClientNode().toString() + " 说：" + text;
  98.	String msg = "{name:'" + channelContext.userid + "',message:'" + text + "'}";
  99.	//用tio-websocket，服务器发送到客户端的Packet都是WsResponse
  100.	WsResponse wsResponse = WsResponse.fromText(msg, ShowcaseServerConfig.CHARSET);
  101.	//群发
  102.	Tio.sendToGroup(channelContext.groupContext, Const.GROUP_ID, wsResponse);
  103.	
  104.	//返回值是要发送给客户端的内容，一般都是返回null
  105.	return null;
  106.	}
  107.	
  108.	}

#+END_SRC

** 8.2 pom.xml项目文档编写
:PROPERTIES:
:ID:       87609a27-9c24-4c1f-aaed-30fda31961b0
:END:

#+BEGIN_SRC java
  1.	<project xmlns="http://maven.apache.org/POM/4.0.0"
  2.	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  3.	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  4.	<modelVersion>4.0.0</modelVersion>
  5.	<artifactId>tio-showcase-websocket</artifactId>
  6.	<name>${project.artifactId}</name>
  7.	
  8.	<parent>
  9.	<groupId>org.t-io</groupId>
  10.	<artifactId>tio-parent</artifactId>
  11.	<version>3.2.4.v20181218-RELEASE</version>
  12.	</parent>
  13.	
  14.	<dependencies>
  15.	<dependency>
  16.	<groupId>org.t-io</groupId>
  17.	<artifactId>tio-websocket-server</artifactId>
  18.	</dependency>
  19.	
  20.	<!-- slf4j-logback绑定 -->
  21.	<dependency>
  22.	<groupId>ch.qos.logback</groupId>
  23.	<artifactId>logback-classic</artifactId>
  24.	</dependency>
  25.	<dependency>
  26.	<groupId>ch.qos.logback</groupId>
  27.	<artifactId>logback-access</artifactId>
  28.	</dependency>
  29.	
  30.	
  31.	<!-- redirect apache commons logging -->
  32.	<dependency>
  33.	<groupId>org.slf4j</groupId>
  34.	<artifactId>jcl-over-slf4j</artifactId>
  35.	</dependency>
  36.	<!-- redirect jdk util logging -->
  37.	<dependency>
  38.	<groupId>org.slf4j</groupId>
  39.	<artifactId>jul-to-slf4j</artifactId>
  40.	</dependency>
  41.	<!-- redirect log4j -->
  42.	<dependency>
  43.	<groupId>org.slf4j</groupId>
  44.	<artifactId>log4j-over-slf4j</artifactId>
  45.	</dependency>
  46.	
  47.	<dependency>
  48.	<groupId>junit</groupId>
  49.	<artifactId>junit</artifactId>
  50.	<scope>test</scope>
  51.	</dependency>
  52.	<dependency>
  53.	<groupId>org.testng</groupId>
  54.	<artifactId>testng</artifactId>
  55.	<scope>test</scope>
  56.	</dependency>
  57.	</dependencies>
  58.	
  59.	
  60.	<build>
  61.	<resources>
  62.	<resource>
  63.	<directory>src/main/resources</directory>
  64.	<filtering>false</filtering>
  65.	</resource>
  66.	</resources>
  67.	
  68.	<plugins>
  69.	<plugin>
  70.	<groupId>org.apache.maven.plugins</groupId>
  71.	<artifactId>maven-deploy-plugin</artifactId>
  72.	<configuration>
  73.	<skip>true</skip>
  74.	</configuration>
  75.	</plugin>
  76.	
  77.	<plugin>
  78.	<groupId>org.apache.maven.plugins</groupId>
  79.	<artifactId>maven-jar-plugin</artifactId>
  80.	<configuration>
  81.	<archive>
  82.	<manifest>
  83.	<addDefaultImplementationEntries>true</addDefaultImplementationEntries>
  84.	<addDefaultSpecificationEntries>true</addDefaultSpecificationEntries>
  85.	</manifest>
  86.	<addMavenDescriptor>false</addMavenDescriptor><!-- 生成的jar中，不要包含pom.xml和pom.properties这两个文件 -->
  87.	</archive>
  88.	
  89.	<finalName>${project.artifactId}</finalName>
  90.	
  91.	<excludes>
  92.	<exclude>config/**/*</exclude>
  93.	<exclude>*.properties</exclude>
  94.	<exclude>*.xml</exclude>
  95.	</excludes>
  96.	</configuration>
  97.	</plugin>
  98.	
  99.	<!-- The configuration of maven-assembly-plugin -->
  100.	<plugin>
  101.	<groupId>org.apache.maven.plugins</groupId>
  102.	<artifactId>maven-assembly-plugin</artifactId>
  103.	<executions>
  104.	<execution>
  105.	<id>make-assembly</id> <!--名字任意 -->
  106.	<phase>package</phase> <!-- 绑定到package生命周期阶段上 -->
  107.	<goals>
  108.	<goal>single</goal>
  109.	</goals>
  110.	<configuration>
  111.	<appendAssemblyId>false</appendAssemblyId>
  112.	<descriptors>
  113.	<descriptor>script/pkg.xml</descriptor>
  114.	</descriptors>
  115.	<outputDirectory>${project.build.directory}/</outputDirectory>
  116.	<finalName>${project.artifactId}</finalName>
  117.	</configuration>
  118.	</execution>
  119.	</executions>
  120.	</plugin>
  121.	</plugins>
  122.	</build>
  123.	</project>

#+END_SRC

** 8.1 引言
:PROPERTIES:
:ID:       635b03e5-34e8-4013-805d-51156b241900
:END:

•	在t-io的官方主群，经常会有用户发出这样的感叹：“用tio写一个聊天室或在线客服，几乎就是个分分钟的事儿”。如果不考虑业务上的细节，这话儿看似浮夸，却又十分接近事实，所以大家也看到了：在t-io出来后，码云上用t-io做的开源im项目就非常多。
•	本文手把手教大家如何用t-io快速做一个网页版聊天室——这不仅仅只是个demo，它更多的可作为项目的一个脚手架，读者可以以此为基础，完成一个真实的网页聊天室，甚至扩展成一个在线客服。
•	本文有部分代码并非必须，譬如数据监控相关的listener，但是在大型的项目中，对这些监控数据的处理却是一个必须，所以本文从实用角度出发，加了不少很实用的代码，望读者朋友喜欢并从中获益。
•	为了更贴近实战，本例子所在的工程还提供了tio-http-server的启动代码，不过本文并不会介绍和tio-http-server相关的知识点，有需要的朋友自行去https://local.t-io.org/doc/126掌握tio-http-server的相关知识

* 7. t-io编程高级知识
:PROPERTIES:
:ID:       30c4ad98-98e5-47b9-89e5-c1a0afbf46a5
:END:
** 7.7 与Spring集成
:PROPERTIES:
:ID:       e33dd03e-cf0c-47b7-bef7-9fc60789c4b4
:END:
** 7.6与Final集成
:PROPERTIES:
:ID:       1f053069-e55b-4c3c-a645-5c26d7f5d3c5
:END:
** 7.5 Channel流量统计与监控
:PROPERTIES:
:ID:       37278297-877c-42ee-b24e-a82fdcc7e98b
:END:
** 7.4 IP流量统计与监控
:PROPERTIES:
:ID:       9b730606-9b7e-46d6-a83c-ba6dba724694
:END:
** 7.3 拉黑IP
:PROPERTIES:
:ID:       6824502c-d4b1-4410-a7df-e3c42ab9b6a7
:END:
** 7.2 群组成员内置排序
:PROPERTIES:
:ID:       09b665d5-b995-44b2-b003-607194cdcb88
:END:
** 7.1 SSL?一行代码解决
:PROPERTIES:
:ID:       2c0ba1e1-fb90-4049-8290-004d7d667bed
:END:
申请SSL证书
阿里云可以申请，当然还有很多申请方式，本话题不在本文档范围
生成jks证书
1.	keytool -importkeystore -srckeystore .\xxxx.pfx -destkeystore .\xxxx.jks -srcstoretype PKCS12 -deststoretype JKS
一行代码配上SSL
1.	serverGroupContext.useSsl("/cert/xxx.jks", "/cert/xxx.jks", "******");
•	注册useSsl()是在ServerGroupContext.java中定义的，而不是GroupContext
打完收工
是不是简单到极致？
意犹未尽，那就看一下t-io源代码吧

1.	/**
2.	     * 
3.	     * @param keyStoreFile 如果是以"classpath:"开头，则从classpath中查找，否则视为普通的文件路径
4.	     * @param trustStoreFile 如果是以"classpath:"开头，则从classpath中查找，否则视为普通的文件路径
5.	     * @param keyStorePwd 
6.	     * @throws FileNotFoundException
7.	     */
8.	    public void useSsl(String keyStoreFile, String trustStoreFile, String keyStorePwd) throws Exception {
9.	        if (StrUtil.isNotBlank(keyStoreFile) && StrUtil.isNotBlank(trustStoreFile)) {
10.	            SslConfig sslConfig = SslConfig.forServer(keyStoreFile, trustStoreFile, keyStorePwd);
11.	            this.setSslConfig(sslConfig);
12.	        }
13.	    }


* 6. 生成项目的Helloworld
:PROPERTIES:
:ID:       dc5f61f2-a0b0-4c18-aef4-fc972c25138f
:END:
** 6.7 结束语
:PROPERTIES:
:ID:       c3c7edb5-ab57-487e-aaba-633c5595dd12
:END:

t-io提供的hello world和其它框架提供的似乎不太一样，其它框架的hello world非常简单非常易懂，但大家往往忽略了一个事实，这些框架提供的hello world也只是仅仅拿来看看和了解概念。t-io提供的hello world是可以用于生产项目的脚手架的，用户只需要修改编码、解码、处理的实现，再额外加一些自己想要的功能即可上线
** 6.6 运行
:PROPERTIES:
:ID:       6b78e6f2-3df8-47cd-a45e-99e1fedb5913
:END:
•	运行服务器：org.tio.examples.helloworld.server.HelloServerStarter，控制台应该会打印如下日志：

#+BEGIN_SRC java
1.	2018-11-14 20:01:44,567 INFO  org.tio.server.TioServer[158]: 
2.	|----------------------------------------------------------------------------------------|
3.	| Tio gitee address | https://gitee.com/tywo45/t-io                                      |
4.	| Tio site address  | https://t-io.org/                                                  |
5.	| Tio version       | 3.2.1.v20181024-RELEASE                                            |
6.	| ---------------------------------------------------------------------------------------|
7.	| GroupContext name | hello-tio-server                                                   |
8.	| Started at        | 2018-11-14 20:01:44                                                |
9.	| Listen on         | 0.0.0.0:6789                                                       |
10.	| Main Class        | org.tio.examples.helloworld.server.HelloServerStarter              |
11.	| Jvm start time    | 408 ms                                                             |
12.	| Tio start time    | 18 ms                                                              |
13.	| Pid               | 6700                                                               |
14.	|----------------------------------------------------------------------------------------|
#+END_SRC

•	运行客户端：org.tio.examples.helloworld.client.HelloClientStarter，会有如下日志

#+BEGIN_SRC java
1.	2018-11-14 20:04:11 INFO  o.t.c.ConnectionCompletionHandler[101]: connected to 127.0.0.1:6789
2.	收到消息：收到了你的消息，你的消息是:hello world
3.	2018-11-14 20:04:12 INFO  org.tio.client.TioClient[369]: [1]: curr:1, closed:0, received:(1p)(55b), handled:1, sent:(1p)(15b)
4.	2018-11-14 20:04:14 INFO  org.tio.client.TioClient[369]: [1]: curr:1, closed:0, received:(1p)(55b), handled:1, sent:(1p)(15b)
5.	2018-11-14 20:04:15 INFO  org.tio.client.TioClient[362]: server:127.0.0.1:6789, client:0:0:0:0:0:0:0:0:54739发送心跳包
6.	2018-11-14 20:04:15 INFO  org.tio.client.TioClient[369]: [1]: curr:1, closed:0, received:(1p)(55b), handled:1, sent:(1p)(15b)
7.	2018-11-14 20:04:16 INFO  org.tio.client.TioClient[369]: [1]: curr:1, closed:0, received:(1p)(55b), handled:1, sent:(2p)(19b)
8.	2018-11-14 20:04:17 INFO  org.tio.client.TioClient[362]: server:127.0.0.1:6789, client:0:0:0:0:0:0:0:0:54739发送心跳包
9.	2018-11-14 20:04:17 INFO  org.tio.client.TioClient[369]: [1]: curr:1, closed:0, received:(1p)(55b), handled:1, sent:(2p)(19b)
10.	2018-11-14 20:04:19 INFO  org.tio.client.TioClient[369]: [1]: curr:1, closed:0, received:(1p)(55b), handled:1, sent:(3p)(23b)
11.	2018-11-14 20:04:20 INFO  org.tio.client.TioClient[362]: server:127.0.0.1:6789, client:0:0:0:0:0:0:0:0:54739发送心跳包
#+END_SRC


** 6.4 服务端编写
:PROPERTIES:
:ID:       693b283b-e774-4879-b754-53488ade9544
:END:
服务端代码


#+BEGIN_SRC java
  1.	package org.tio.examples.helloworld.server;
  2.	
  3.	import java.nio.ByteBuffer;
  4.	
  5.	import org.tio.core.Tio;
  6.	import org.tio.core.ChannelContext;
  7.	import org.tio.core.GroupContext;
  8.	import org.tio.core.exception.AioDecodeException;
  9.	import org.tio.core.intf.Packet;
  10.	import org.tio.examples.helloworld.common.HelloPacket;
  11.	import org.tio.server.intf.ServerAioHandler;
  12.	
  13.	/**
  14.	 * @author tanyaowu
  15.	 */
  16.	public class HelloServerAioHandler implements ServerAioHandler {
  17.	
  18.	    /**
  19.	     * 解码：把接收到的ByteBuffer，解码成应用可以识别的业务消息包
  20.	     * 总的消息结构：消息头 + 消息体
  21.	     * 消息头结构：    4个字节，存储消息体的长度
  22.	     * 消息体结构：   对象的json串的byte[]
  23.	     */
  24.	    @Override
  25.	    public HelloPacket decode(ByteBuffer buffer, int limit, int position, int readableLength, ChannelContext channelContext) throws AioDecodeException {
  26.	        //提醒：buffer的开始位置并不一定是0，应用需要从buffer.position()开始读取数据
  27.	        //收到的数据组不了业务包，则返回null以告诉框架数据不够
  28.	        if (readableLength < HelloPacket.HEADER_LENGHT) {
  29.	            return null;
  30.	        }
  31.	
  32.	        //读取消息体的长度
  33.	        int bodyLength = buffer.getInt();
  34.	
  35.	        //数据不正确，则抛出AioDecodeException异常
  36.	        if (bodyLength < 0) {
  37.	            throw new AioDecodeException("bodyLength [" + bodyLength + "] is not right, remote:" + channelContext.getClientNode());
  38.	        }
  39.	
  40.	        //计算本次需要的数据长度
  41.	        int neededLength = HelloPacket.HEADER_LENGHT + bodyLength;
  42.	        //收到的数据是否足够组包
  43.	        int isDataEnough = readableLength - neededLength;
  44.	        // 不够消息体长度(剩下的buffe组不了消息体)
  45.	        if (isDataEnough < 0) {
  46.	            return null;
  47.	        } else //组包成功
  48.	        {
  49.	            HelloPacket imPacket = new HelloPacket();
  50.	            if (bodyLength > 0) {
  51.	                byte[] dst = new byte[bodyLength];
  52.	                buffer.get(dst);
  53.	                imPacket.setBody(dst);
  54.	            }
  55.	            return imPacket;
  56.	        }
  57.	    }
  58.	
  59.	    /**
  60.	     * 编码：把业务消息包编码为可以发送的ByteBuffer
  61.	     * 总的消息结构：消息头 + 消息体
  62.	     * 消息头结构：    4个字节，存储消息体的长度
  63.	     * 消息体结构：   对象的json串的byte[]
  64.	     */
  65.	    @Override
  66.	    public ByteBuffer encode(Packet packet, GroupContext groupContext, ChannelContext channelContext) {
  67.	        HelloPacket helloPacket = (HelloPacket) packet;
  68.	        byte[] body = helloPacket.getBody();
  69.	        int bodyLen = 0;
  70.	        if (body != null) {
  71.	            bodyLen = body.length;
  72.	        }
  73.	
  74.	        //bytebuffer的总长度是 = 消息头的长度 + 消息体的长度
  75.	        int allLen = HelloPacket.HEADER_LENGHT + bodyLen;
  76.	        //创建一个新的bytebuffer
  77.	        ByteBuffer buffer = ByteBuffer.allocate(allLen);
  78.	        //设置字节序
  79.	        buffer.order(groupContext.getByteOrder());
  80.	
  81.	        //写入消息头----消息头的内容就是消息体的长度
  82.	        buffer.putInt(bodyLen);
  83.	
  84.	        //写入消息体
  85.	        if (body != null) {
  86.	            buffer.put(body);
  87.	        }
  88.	        return buffer;
  89.	    }
  90.	
  91.	
  92.	    /**
  93.	     * 处理消息
  94.	     */
  95.	    @Override
  96.	    public void handler(Packet packet, ChannelContext channelContext) throws Exception {
  97.	        HelloPacket helloPacket = (HelloPacket) packet;
  98.	        byte[] body = helloPacket.getBody();
  99.	        if (body != null) {
  100.	            String str = new String(body, HelloPacket.CHARSET);
  101.	            System.out.println("收到消息：" + str);
  102.	
  103.	            HelloPacket resppacket = new HelloPacket();
  104.	            resppacket.setBody(("收到了你的消息，你的消息是:" + str).getBytes(HelloPacket.CHARSET));
  105.	            Tio.send(channelContext, resppacket);
  106.	        }
  107.	        return;
  108.	    }
  109.	}

#+END_SRC

•	服务器端启动类


#+BEGIN_SRC java

  1.	package org.tio.examples.helloworld.server;
  2.	
  3.	import java.io.IOException;
  4.	
  5.	import org.tio.examples.helloworld.common.Const;
  6.	import org.tio.server.TioServer;
  7.	import org.tio.server.ServerGroupContext;
  8.	import org.tio.server.intf.ServerAioHandler;
  9.	import org.tio.server.intf.ServerAioListener;
  10.	
  11.	/**
  12.	 *
  13.	 * @author tanyaowu
  14.	 * 2017年4月4日 下午12:22:58
  15.	 */
  16.	public class HelloServerStarter {
  17.	    //handler, 包括编码、解码、消息处理
  18.	    public static ServerAioHandler aioHandler = new HelloServerAioHandler();
  19.	
  20.	    //事件监听器，可以为null，但建议自己实现该接口，可以参考showcase了解些接口
  21.	    public static ServerAioListener aioListener = null;
  22.	
  23.	    //一组连接共用的上下文对象
  24.	    public static ServerGroupContext serverGroupContext = new ServerGroupContext("hello-tio-server", aioHandler, aioListener);
  25.	
  26.	    //tioServer对象
  27.	    public static TioServer tioServer = new TioServer(serverGroupContext);
  28.	
  29.	    //有时候需要绑定ip，不需要则null
  30.	    public static String serverIp = null;
  31.	
  32.	    //监听的端口
  33.	    public static int serverPort = Const.PORT;
  34.	
  35.	    /**
  36.	     * 启动程序入口
  37.	     */
  38.	    public static void main(String[] args) throws IOException {
  39.	        serverGroupContext.setHeartbeatTimeout(org.tio.examples.helloworld.common.Const.TIMEOUT);
  40.	
  41.	        tioServer.start(serverIp, serverPort);
  42.	    }
  43.	}
#+END_SRC
** 6.5 客户端编写
:PROPERTIES:
:ID:       9fdd8add-b765-4d2e-b222-423a81ee0efc
:END:

#+BEGIN_SRC java
  1.	package org.tio.examples.helloworld.client;
  2.	
  3.	import java.nio.ByteBuffer;
  4.	
  5.	import org.tio.client.intf.ClientAioHandler;
  6.	import org.tio.core.ChannelContext;
  7.	import org.tio.core.GroupContext;
  8.	import org.tio.core.exception.AioDecodeException;
  9.	import org.tio.core.intf.Packet;
  10.	import org.tio.examples.helloworld.common.HelloPacket;
  11.	
  12.	/**
  13.	 * 
  14.	 * @author tanyaowu
  15.	 */
  16.	public class HelloClientAioHandler implements ClientAioHandler {
  17.	    private static HelloPacket heartbeatPacket = new HelloPacket();
  18.	
  19.	
  20.	    /**
  21.	     * 解码：把接收到的ByteBuffer，解码成应用可以识别的业务消息包
  22.	     * 总的消息结构：消息头 + 消息体
  23.	     * 消息头结构：    4个字节，存储消息体的长度
  24.	     * 消息体结构：   对象的json串的byte[]
  25.	     */
  26.	    @Override
  27.	    public HelloPacket decode(ByteBuffer buffer, int limit, int position, int readableLength, ChannelContext channelContext) throws AioDecodeException {
  28.	        //收到的数据组不了业务包，则返回null以告诉框架数据不够
  29.	        if (readableLength < HelloPacket.HEADER_LENGHT) {
  30.	            return null;
  31.	        }
  32.	
  33.	        //读取消息体的长度
  34.	        int bodyLength = buffer.getInt();
  35.	
  36.	        //数据不正确，则抛出AioDecodeException异常
  37.	        if (bodyLength < 0) {
  38.	            throw new AioDecodeException("bodyLength [" + bodyLength + "] is not right, remote:" + channelContext.getClientNode());
  39.	        }
  40.	
  41.	        //计算本次需要的数据长度
  42.	        int neededLength = HelloPacket.HEADER_LENGHT + bodyLength;
  43.	        //收到的数据是否足够组包
  44.	        int isDataEnough = readableLength - neededLength;
  45.	        // 不够消息体长度(剩下的buffe组不了消息体)
  46.	        if (isDataEnough < 0) {
  47.	            return null;
  48.	        } else //组包成功
  49.	        {
  50.	            HelloPacket imPacket = new HelloPacket();
  51.	            if (bodyLength > 0) {
  52.	                byte[] dst = new byte[bodyLength];
  53.	                buffer.get(dst);
  54.	                imPacket.setBody(dst);
  55.	            }
  56.	            return imPacket;
  57.	        }
  58.	    }
  59.	
  60.	    /**
  61.	     * 编码：把业务消息包编码为可以发送的ByteBuffer
  62.	     * 总的消息结构：消息头 + 消息体
  63.	     * 消息头结构：    4个字节，存储消息体的长度
  64.	     * 消息体结构：   对象的json串的byte[]
  65.	     */
  66.	    @Override
  67.	    public ByteBuffer encode(Packet packet, GroupContext groupContext, ChannelContext channelContext) {
  68.	        HelloPacket helloPacket = (HelloPacket) packet;
  69.	        byte[] body = helloPacket.getBody();
  70.	        int bodyLen = 0;
  71.	        if (body != null) {
  72.	            bodyLen = body.length;
  73.	        }
  74.	
  75.	        //bytebuffer的总长度是 = 消息头的长度 + 消息体的长度
  76.	        int allLen = HelloPacket.HEADER_LENGHT + bodyLen;
  77.	        //创建一个新的bytebuffer
  78.	        ByteBuffer buffer = ByteBuffer.allocate(allLen);
  79.	        //设置字节序
  80.	        buffer.order(groupContext.getByteOrder());
  81.	
  82.	        //写入消息头----消息头的内容就是消息体的长度
  83.	        buffer.putInt(bodyLen);
  84.	
  85.	        //写入消息体
  86.	        if (body != null) {
  87.	            buffer.put(body);
  88.	        }
  89.	        return buffer;
  90.	    }
  91.	
  92.	    /**
  93.	     * 处理消息
  94.	     */
  95.	    @Override
  96.	    public void handler(Packet packet, ChannelContext channelContext) throws Exception {
  97.	        HelloPacket helloPacket = (HelloPacket) packet;
  98.	        byte[] body = helloPacket.getBody();
  99.	        if (body != null) {
  100.	            String str = new String(body, HelloPacket.CHARSET);
  101.	            System.out.println("收到消息：" + str);
  102.	        }
  103.	
  104.	        return;
  105.	    }
  106.	
  107.	    /**
  108.	     * 此方法如果返回null，框架层面则不会发心跳；如果返回非null，框架层面会定时发本方法返回的消息包
  109.	     */
  110.	    @Override
  111.	    public HelloPacket heartbeatPacket() {
  112.	        return heartbeatPacket;
  113.	    }
  114.	}

#+END_SRC

客户端启动类


#+BEGIN_SRC java
  1.	package org.tio.examples.helloworld.client;
  2.	
  3.	import org.tio.client.TioClient;
  4.	import org.tio.client.ClientChannelContext;
  5.	import org.tio.client.ClientGroupContext;
  6.	import org.tio.client.ReconnConf;
  7.	import org.tio.client.intf.ClientAioHandler;
  8.	import org.tio.client.intf.ClientAioListener;
  9.	import org.tio.core.Tio;
  10.	import org.tio.core.Node;
  11.	import org.tio.examples.helloworld.common.Const;
  12.	import org.tio.examples.helloworld.common.HelloPacket;
  13.	
  14.	/**
  15.	 *
  16.	 * @author tanyaowu
  17.	 *
  18.	 */
  19.	public class HelloClientStarter {
  20.	    //服务器节点
  21.	    public static Node serverNode = new Node(Const.SERVER, Const.PORT);
  22.	
  23.	    //handler, 包括编码、解码、消息处理
  24.	    public static ClientAioHandler tioClientHandler = new HelloClientAioHandler();
  25.	
  26.	    //事件监听器，可以为null，但建议自己实现该接口，可以参考showcase了解些接口
  27.	    public static ClientAioListener aioListener = null;
  28.	
  29.	    //断链后自动连接的，不想自动连接请设为null
  30.	    private static ReconnConf reconnConf = new ReconnConf(5000L);
  31.	
  32.	    //一组连接共用的上下文对象
  33.	    public static ClientGroupContext clientGroupContext = new ClientGroupContext(tioClientHandler, aioListener, reconnConf);
  34.	
  35.	    public static TioClient tioClient = null;
  36.	    public static ClientChannelContext clientChannelContext = null;
  37.	
  38.	    /**
  39.	     * 启动程序入口
  40.	     */
  41.	    public static void main(String[] args) throws Exception {
  42.	        clientGroupContext.setHeartbeatTimeout(Const.TIMEOUT);
  43.	        tioClient = new TioClient(clientGroupContext);
  44.	        clientChannelContext = tioClient.connect(serverNode);
  45.	        //连上后，发条消息玩玩
  46.	        send();
  47.	    }
  48.	
  49.	    private static void send() throws Exception {
  50.	        HelloPacket packet = new HelloPacket();
  51.	        packet.setBody("hello world".getBytes(HelloPacket.CHARSET));
  52.	        Tio.send(clientChannelContext, packet);
  53.	    }
  54.	}

#+END_SRC

** 6.3 公共模块编写
:PROPERTIES:
:ID:       793c68e5-b518-47c2-9266-119b83d48e43
:END:

•	在pom.xml文件中引入tio-core（最新版本请参考： http://repo.maven.apache.org/maven2/org/t-io/ ）


#+BEGIN_SRC java
1.	<dependency>
2.	    <groupId>org.t-io</groupId>
3.	    <artifactId>tio-core</artifactId>
4.	    <version>3.2.1.v20181024-RELEASE</version>
5.	</dependency>
#+END_SRC

•	定义Packet

#+BEGIN_SRC java
1.	package org.tio.examples.helloworld.common;
2.	
3.	import org.tio.core.intf.Packet;
4.	
5.	/**
6.	 * @author tanyaowu
7.	 */
8.	public class HelloPacket extends Packet {
9.	    private static final long serialVersionUID = -172060606924066412L;
10.	    public static final int HEADER_LENGHT = 4;//消息头的长度
11.	    public static final String CHARSET = "utf-8";
12.	    private byte[] body;
13.	
14.	    /**
15.	     * @return the body
16.	     */
17.	    public byte[] getBody() {
18.	        return body;
19.	    }
20.	
21.	    /**
22.	     * @param body the body to set
23.	     */
24.	    public void setBody(byte[] body) {
25.	        this.body = body;
26.	    }
27.	}
#+END_SRC

•	定义服务器端和客户端都用得到的常量

#+BEGIN_SRC java
1.	package org.tio.examples.helloworld.common;
2.	
3.	/**
4.	 *
5.	 * @author tanyaowu
6.	 * 2017年3月30日 下午7:05:54
7.	 */
8.	public interface Const {
9.	    /**
10.	     * 服务器地址
11.	     */
12.	    public static final String SERVER = "127.0.0.1";
13.	
14.	    /**
15.	     * 监听端口
16.	     */
17.	    public static final int PORT = 6789;
18.	
19.	    /**
20.	     * 心跳超时时间
21.	     */
22.	    public static final int TIMEOUT = 5000;
23.	}
#+END_SRC


** 6.2 应用层协议介绍
:PROPERTIES:
:ID:       9b807977-8251-41ef-a248-6802ceb0f375
:END:
本例子演示的是一个典型的TCP长连接应用，大体业务简介如下
•	分为server和client工程，server和client共用common工程
•	服务端和客户端的消息协议比较简单，消息头为4个字节，用以表示消息体的长度，消息体为一个字符串的byte[]
•	服务端先启动，监听6789端口
•	客户端连接到服务端后，会主动向服务器发送一条消息
•	服务器收到消息后会回应一条消息
•	之后，框架层会自动从客户端发心跳到服务器，服务器也会检测心跳有没有超时（这些事都是框架做的，业务层只需要配一个心跳超时参数即可）
•	框架层会在断链后自动重连（这些事都是框架做的，业务层只需要配一个重连配置对象即可）

** 6.1 引言
:PROPERTIES:
:ID:       99eba80c-c69c-44c2-893f-f1e693b01d8f
:END:
学习的开端往往从hello world开始
•	hello world是入门t-io最好的方式！而作者也是用心写了一个对生产项目有参考价值的hello world，不少用户直接拿官方提供的hello world入门，并且稍作逻辑修改后就直接用在生产环境了。
•	hello world的源代码在：https://gitee.com/tywo45/tio-showcase

* 5. t-io编程基础知识
:PROPERTIES:
:ID:       d700c535-a112-4098-9232-a6b89079a2ec
:END:
** 5.12 Tio集大成者
:PROPERTIES:
:ID:       3e4c04db-bcff-466b-b82e-0df79d0d586b
:END:
Tio.java概述
•	为了让用户减少查找API的时间，t-io把常用API以静态方法的形式汇集于一个类，这就是Tio.java
•	下面归类讲解各API
资源绑定的API
•	资源绑定是指把业务相关的数据和Tcp连接（即ChannelContext）关联起来，譬如ChannelContext-A代表了用户张三，张三的userid是333，就用下面的代码进行绑定

#+BEGIN_SRC java
1.	Tio.bindUser(ChannelContext-A, "333")
#+END_SRC

•	t-io目前内置了4种资源绑定，当然用户可以灵活使用这些绑定从而解决业务层所有的资源绑定问题，譬如可以给group加前缀”ios-“，从而标记这个用户使用的是ios，譬如

#+BEGIN_SRC java
0.	Tio.bindGroup(ChannelContext-A, "333");
1.	Tio.bindGroup(ChannelContext-A, "ios-" + "333");
#+END_SRC

•	内置的4种资源绑定方法中，一个ChannelContext是可以绑定到多个groupid的，其它三个绑定都是一对一的关系，也就是说一个ChannelContext可以同时属于group-a，group-b… …
•	下面贴一下这4个资源绑定的源代码


#+BEGIN_SRC java
  0.	/**
  1.	   * 绑定业务id
  2.	   * @param channelContext
  3.	   * @param bsId
  4.	   * @author tanyaowu
  5.	   */
  6.	  public static void bindBsId(ChannelContext channelContext, String bsId) {
  7.	      channelContext.groupContext.bsIds.bind(channelContext, bsId);
  8.	  }
  9.	
  10.	  /**
  11.	   * 绑定群组
  12.	   * @param channelContext
  13.	   * @param group
  14.	   * @author tanyaowu
  15.	   */
  16.	  public static void bindGroup(ChannelContext channelContext, String group) {
  17.	      channelContext.groupContext.groups.bind(group, channelContext);
  18.	  }
  19.	
  20.	  /**
  21.	   * 绑定token
  22.	   * @param channelContext
  23.	   * @param token
  24.	   * @author tanyaowu
  25.	   */
  26.	  public static void bindToken(ChannelContext channelContext, String token) {
  27.	      channelContext.groupContext.tokens.bind(token, channelContext);
  28.	  }
  29.	
  30.	  /**
  31.	   * 绑定用户
  32.	   * @param channelContext
  33.	   * @param userid
  34.	   * @author tanyaowu
  35.	   */
  36.	  public static void bindUser(ChannelContext channelContext, String userid) {
  37.	      channelContext.groupContext.users.bind(userid, channelContext);
  38.	  }

#+END_SRC

资源解绑的API
•	既有绑定，就肯定会有解绑，这是个和绑定相反的操作，所以话不多说，直接贴出不长的源代码


#+BEGIN_SRC java
  /**
  2.	   * 解绑业务id
  3.	   * @param channelContext
  4.	   * @author tanyaowu
  5.	   */
  6.	  public static void unbindBsId(ChannelContext channelContext) {
  7.	      channelContext.groupContext.bsIds.unbind(channelContext);
  8.	  }
  9.	
  10.	  /**
  11.	   * 与所有组解除解绑关系
  12.	   * @param channelContext
  13.	   * @author tanyaowu
  14.	   */
  15.	  public static void unbindGroup(ChannelContext channelContext) {
  16.	      channelContext.groupContext.groups.unbind(channelContext);
  17.	  }
  18.	
  19.	  /**
  20.	   * 与指定组解除绑定关系
  21.	   * @param group
  22.	   * @param channelContext
  23.	   * @author tanyaowu
  24.	   */
  25.	  public static void unbindGroup(String group, ChannelContext channelContext) {
  26.	      channelContext.groupContext.groups.unbind(group, channelContext);
  27.	  }
  28.	
  29.	  /**
  30.	   * 解除channelContext绑定的token
  31.	   * @param channelContext
  32.	   * @author tanyaowu
  33.	   */
  34.	  public static void unbindToken(ChannelContext channelContext) {
  35.	      channelContext.groupContext.tokens.unbind(channelContext);
  36.	  }
  37.	
  38.	  //    org.tio.core.GroupContext.ipBlacklist
  39.	
  40.	  /**
  41.	   * 解除channelContext绑定的userid
  42.	   * @param channelContext
  43.	   * @author tanyaowu
  44.	   */
  45.	  public static void unbindUser(ChannelContext channelContext) {
  46.	      channelContext.groupContext.users.unbind(channelContext);
  47.	  }
  48.	
  49.	  /**
  50.	   * 解除userid的绑定。一般用于多地登录，踢掉前面登录的场景
  51.	   * @param groupContext
  52.	   * @param userid
  53.	   * @author: tanyaowu
  54.	   */
  55.	  public static void unbindUser(GroupContext groupContext, String userid) {
  56.	      groupContext.users.unbind(groupContext, userid);
  57.	  }

#+END_SRC

异步发送的API
•	异步发送，指的是业务层把Packet丢给t-io后立即返回，返回时Packet并没有被发送，而只是提交到了待发送队列
•	异步发送都是以send开头的，这个API有点多，贴代码有点长，用图片展示更舒适些
    [[file:img/5.12yibu.png][异步发送]]
阻塞发送的API
•	阻塞发送：t-io把Packet送给对方后才返回
•	阻塞发送都是以bSend开头的，这个API有点多，贴代码有点长，用图片展示更舒适些
    [[file:img/5.12zusai.png][阻塞发送]] 

获取ChannelContext的API
•	前面的资源绑定，一个重要的目的就是要根据那些业务标识来获取ChannelContext，譬如你绑定了一个userid，那么后面就可以通过这个userid来获取ChannelContext
•	获取ChannelContext的API都是以get开头的，这个API有点多，贴代码有点长，用图片展示更舒适些
    [[file:img/5.12get.png][get]] 
断开连接和移除连接的API
•	断开连接都是以close开头的方法，指的是把当前已经连上的TCP连接断开掉，如果是TCP客户端，并不一定会移除该连接对应的ChannelContext对象，后面会根据重连规则进行重连，如果是TCP服务器，断开连接就会彻底移除该连接，同时释放该连接对应的ChannelContext对象，因为服务器不存在重连一说。
 
•	移除连接都是以remove开头的方法，指的是彻底抛弃这个连接
    [[file:img/5.12close.png][关闭]] 
集群通知的API
•	t-io是内置集群功能的，作为与业务不相关的io框架，内置集群功能是件费力却不见得讨好的事（为啥不讨好？譬如会增加代码复杂度、会降低tio-mvc在TFB上的跑分排名），但t-io考虑到广大用户的呼声，还是内置了集群功能
•	目前t-io提供的消息发送功能，都是支持集群的，这个从Tio.java的源代码中就能看出来。但是t-io并没有提供其它功能的集群，譬如移除连接、绑定资源，这些操作用户需要自己完成集群能力，也可以通过t-io内置的消息发送集群灵活实现这些集群能力(譬如发送一条特定指令去实现这些功能的集群能力)
•	集群通知类API都是以notifyCluster开头的，见图
    [[file:img/5.12notifyCluster.png][集群通知]] 


** 5.11 GroupStat所有通道统计
:PROPERTIES:
:ID:       9bde0089-2d57-4b41-8d78-209fa274422d
:END:
GroupStat是ChannelStat的集合，它有俩子类ServerChannelStat和ClientChannelStat，当你用t-io做tcp服务器端时，你拿到的是ServerChannelStat，反之则是ClientChannelStat
如何获取GroupStat

#+BEGIN_SRC java
1.	org.tio.core.GroupContext.groupStat
#+END_SRC

GroupStat有哪些统计项
直接看源代码吧，这个比文档还容易理解


#+BEGIN_SRC java
  1.	package org.tio.core.stat;
  2.	
  3.	import java.util.concurrent.atomic.AtomicLong;
  4.	
  5.	/**
  6.	 * 
  7.	 * @author tanyaowu 
  8.	 * 2017年10月19日 上午9:40:48
  9.	 */
  10.	public class GroupStat implements java.io.Serializable {
  11.	    private static final long serialVersionUID = -6988655941470121164L;
  12.	    /**
  13.	     * 关闭了多少连接
  14.	     */
  15.	    public final AtomicLong closed = new AtomicLong();
  16.	    /**
  17.	     * 接收到的消息包
  18.	     */
  19.	    public final AtomicLong receivedPackets = new AtomicLong();
  20.	
  21.	    /**
  22.	     * 接收到的消息字节数
  23.	     */
  24.	    public final AtomicLong receivedBytes = new AtomicLong();
  25.	
  26.	    /**
  27.	     * 处理了的消息包数
  28.	     */
  29.	    public final AtomicLong handledPackets = new AtomicLong();
  30.	
  31.	    /**
  32.	     * 处理消息包耗时，单位：毫秒
  33.	     */
  34.	    public final AtomicLong handledPacketCosts = new AtomicLong();
  35.	
  36.	    /**
  37.	     * 处理了多少字节
  38.	     */
  39.	    public final AtomicLong handledBytes = new AtomicLong();
  40.	
  41.	    /**
  42.	     * 发送了的消息包数
  43.	     */
  44.	    public final AtomicLong sentPackets = new AtomicLong();
  45.	
  46.	    /**
  47.	     * 发送了的字节数
  48.	     */
  49.	    public final AtomicLong sentBytes = new AtomicLong();
  50.	
  51.	    /**
  52.	     * 本IP已接收了多少次TCP数据包
  53.	     */
  54.	    public final AtomicLong receivedTcps = new AtomicLong();
  55.	
  56.	    /**
  57.	     * 平均每次TCP接收到的字节数，这个可以用来监控慢攻击，配置PacketsPerTcpReceive定位慢攻击
  58.	     */
  59.	    public double getBytesPerTcpReceive() {
  60.	        if (receivedTcps.get() == 0) {
  61.	            return 0;
  62.	        }
  63.	        double ret = (double) receivedBytes.get() / (double) receivedTcps.get();
  64.	        return ret;
  65.	    }
  66.	
  67.	    /**
  68.	     * 平均每次TCP接收到的业务包数，这个可以用来监控慢攻击，此值越小越有攻击嫌疑
  69.	     */
  70.	    public double getPacketsPerTcpReceive() {
  71.	        if (receivedTcps.get() == 0) {
  72.	            return 0;
  73.	        }
  74.	        double ret = (double) receivedPackets.get() / (double) receivedTcps.get();
  75.	        return ret;
  76.	    }
  77.	
  78.	    /**
  79.	     * @return the closed
  80.	     */
  81.	    public AtomicLong getClosed() {
  82.	        return closed;
  83.	    }
  84.	
  85.	    /**
  86.	     * @return the handledBytes
  87.	     */
  88.	    public AtomicLong getHandledBytes() {
  89.	        return handledBytes;
  90.	    }
  91.	
  92.	    /**
  93.	     * @return the handledPackets
  94.	     */
  95.	    public AtomicLong getHandledPackets() {
  96.	        return handledPackets;
  97.	    }
  98.	
  99.	    /**
  100.	     * @return the receivedBytes
  101.	     */
  102.	    public AtomicLong getReceivedBytes() {
  103.	        return receivedBytes;
  104.	    }
  105.	
  106.	    /**
  107.	     * @return the receivedPackets
  108.	     */
  109.	    public AtomicLong getReceivedPackets() {
  110.	        return receivedPackets;
  111.	    }
  112.	
  113.	    /**
  114.	     * @return the sentBytes
  115.	     */
  116.	    public AtomicLong getSentBytes() {
  117.	        return sentBytes;
  118.	    }
  119.	
  120.	    /**
  121.	     * @return the sentPacket
  122.	     */
  123.	    public AtomicLong getSentPackets() {
  124.	        return sentPackets;
  125.	    }
  126.	
  127.	    /**
  128.	     * @return the receivedTcps
  129.	     */
  130.	    public AtomicLong getReceivedTcps() {
  131.	        return receivedTcps;
  132.	    }
  133.	
  134.	    /**
  135.	     * 处理消息包耗时，单位：毫秒
  136.	     * @return
  137.	     */
  138.	    public AtomicLong getHandledPacketCosts() {
  139.	        return handledPacketCosts;
  140.	    }
  141.	
  142.	    /**
  143.	     * 处理packet平均耗时，单位：毫秒
  144.	     * @return
  145.	     */
  146.	    public double getHandledCostsPerPacket() {
  147.	        if (handledPackets.get() > 0) {
  148.	            return handledPacketCosts.get() / handledPackets.get();
  149.	        }
  150.	        return 0;
  151.	    }
  152.	}

#+END_SRC

当然它的两个子类还会有各自的字段


#+BEGIN_SRC java

  1.	package org.tio.server;
  2.	
  3.	import java.util.concurrent.atomic.AtomicLong;
  4.	
  5.	import org.tio.core.stat.GroupStat;
  6.	
  7.	/**
  8.	 *
  9.	 * @author tanyaowu
  10.	 *
  11.	 */
  12.	public class ServerGroupStat extends GroupStat {
  13.	
  14.	    private static final long serialVersionUID = -139100692961946342L;
  15.	    /**
  16.	     * 接受了多少连接
  17.	     */
  18.	    public final AtomicLong accepted = new AtomicLong();
  19.	
  20.	    /**
  21.	     *
  22.	     *
  23.	     * @author tanyaowu
  24.	     * 2016年12月3日 下午2:29:28
  25.	     *
  26.	     */
  27.	    public ServerGroupStat() {
  28.	    }
  29.	
  30.	    /**
  31.	     * @return the accepted
  32.	     */
  33.	    public AtomicLong getAccepted() {
  34.	        return accepted;
  35.	    }
  36.	}
  1.	package org.tio.client;
  2.	
  3.	import org.tio.core.stat.GroupStat;
  4.	
  5.	/**
  6.	 *
  7.	 * @author tanyaowu
  8.	 * 2017年4月1日 上午9:32:01
  9.	 */
  10.	public class ClientGroupStat extends GroupStat {
  11.	
  12.	    private static final long serialVersionUID = 804270967157603097L;
  13.	}
#+END_SRC

** 5.10 ChannelStat:单条通道统计
:PROPERTIES:
:ID:       718623e1-4558-4ca2-9c0a-9b851ccb9c39
:END:
ChannelStat是单条TCP通道的流量统计，t-io自诩拥有最强级别的流量统计和监控，也绝不是吹吹牛
如何获取ChannelStat

#+BEGIN_SRC java
1.	org.tio.core.ChannelContext.stat
#+END_SRC

ChannelStat有哪些统计项
直接看源代码吧，这个比文档还容易理解

#+BEGIN_SRC java

  1.	package org.tio.core.stat;
  2.	
  3.	import java.util.concurrent.atomic.AtomicLong;
  4.	
  5.	import org.tio.utils.SystemTimer;
  6.	
  7.	/**
  8.	 * @author tanyaowu
  9.	 * 2017年4月1日 下午2:17:35
  10.	 */
  11.	public class ChannelStat implements java.io.Serializable {
  12.	    private static final long serialVersionUID = -6942731710053482089L;
  13.	
  14.	    /**
  15.	     * 本次解码失败的次数
  16.	     */
  17.	    public int decodeFailCount = 0;
  18.	
  19.	    /**
  20.	     * 最近一次收到业务消息包的时间(一个完整的业务消息包，一部分消息不算)
  21.	     */
  22.	    public long latestTimeOfReceivedPacket = SystemTimer.currTime;
  23.	
  24.	    /**
  25.	     * 最近一次发送业务消息包的时间(一个完整的业务消息包，一部分消息不算)
  26.	     */
  27.	    public long latestTimeOfSentPacket = SystemTimer.currTime;
  28.	
  29.	    /**
  30.	     * 最近一次收到业务消息包的时间:收到字节就算
  31.	     */
  32.	    public long latestTimeOfReceivedByte = SystemTimer.currTime;
  33.	
  34.	    /**
  35.	     * 最近一次发送业务消息包的时间：发送字节就算
  36.	     */
  37.	    public long latestTimeOfSentByte = SystemTimer.currTime;
  38.	
  39.	    /**
  40.	     * ChannelContext对象创建的时间
  41.	     */
  42.	    public long timeCreated = System.currentTimeMillis();
  43.	
  44.	    /**
  45.	     * 第一次连接成功的时间
  46.	     */
  47.	    public Long timeFirstConnected = null;
  48.	
  49.	    /**
  50.	     * 连接关闭的时间
  51.	     */
  52.	    public long timeClosed = SystemTimer.currTime;
  53.	
  54.	    /**
  55.	     * 进入重连队列时间
  56.	     */
  57.	    public long timeInReconnQueue = SystemTimer.currTime;
  58.	
  59.	    /**
  60.	     * 本连接已发送的字节数
  61.	     */
  62.	    public final AtomicLong sentBytes = new AtomicLong();
  63.	
  64.	    /**
  65.	     * 本连接已发送的packet数
  66.	     */
  67.	    public final AtomicLong sentPackets = new AtomicLong();
  68.	
  69.	    /**
  70.	     * 本连接已处理的字节数
  71.	     */
  72.	    public final AtomicLong handledBytes = new AtomicLong();
  73.	
  74.	    /**
  75.	     * 本连接已处理的packet数
  76.	     */
  77.	    public final AtomicLong handledPackets = new AtomicLong();
  78.	
  79.	    /**
  80.	     * 处理消息包耗时，单位：毫秒
  81.	     * 拿这个值除以handledPackets，就是处理每个消息包的平均耗时
  82.	     */
  83.	    public final AtomicLong handledPacketCosts = new AtomicLong();
  84.	
  85.	    /**
  86.	     * 本连接已接收的字节数
  87.	     */
  88.	    public final AtomicLong receivedBytes = new AtomicLong();
  89.	
  90.	    /**
  91.	     * 本连接已接收了多少次TCP数据包
  92.	     */
  93.	    public final AtomicLong receivedTcps = new AtomicLong();
  94.	
  95.	    /**
  96.	     * 本连接已接收的packet数
  97.	     */
  98.	    public final AtomicLong receivedPackets = new AtomicLong();
  99.	
  100.	    /**
  101.	     * 平均每次TCP接收到的字节数，这个可以用来监控慢攻击，配置PacketsPerTcpReceive定位慢攻击
  102.	     */
  103.	    public double getBytesPerTcpReceive() {
  104.	        if (receivedTcps.get() == 0) {
  105.	            return 0;
  106.	        }
  107.	        double ret = (double)receivedBytes.get() / (double)receivedTcps.get();
  108.	        return ret;
  109.	    }
  110.	
  111.	    /**
  112.	     * 平均每次TCP接收到的业务包数，这个可以用来监控慢攻击，此值越小越有攻击嫌疑
  113.	     */
  114.	    public double getPacketsPerTcpReceive() {
  115.	        if (receivedTcps.get() == 0) {
  116.	            return 0;
  117.	        }
  118.	        double ret = (double)receivedPackets.get() / (double)receivedTcps.get();
  119.	        return ret;
  120.	    }
  121.	
  122.	    /**
  123.	     * @return the decodeFailCount
  124.	     */
  125.	    public int getDecodeFailCount() {
  126.	        return decodeFailCount;
  127.	    }
  128.	
  129.	    /**
  130.	     * @return the countHandledByte
  131.	     */
  132.	    public AtomicLong getHandledBytes() {
  133.	        return handledBytes;
  134.	    }
  135.	
  136.	    /**
  137.	     * @return the countHandledPacket
  138.	     */
  139.	    public AtomicLong getHandledPackets() {
  140.	        return handledPackets;
  141.	    }
  142.	
  143.	    /**
  144.	     * @return the timeLatestReceivedMsg
  145.	     */
  146.	    public long getLatestTimeOfReceivedPacket() {
  147.	        return latestTimeOfReceivedPacket;
  148.	    }
  149.	
  150.	    /**
  151.	     * @return the timeLatestSentMsg
  152.	     */
  153.	    public long getLatestTimeOfSentPacket() {
  154.	        return latestTimeOfSentPacket;
  155.	    }
  156.	
  157.	    /**
  158.	     * @return the countReceivedByte
  159.	     */
  160.	    public AtomicLong getReceivedBytes() {
  161.	        return receivedBytes;
  162.	    }
  163.	
  164.	    /**
  165.	     * @return the countReceivedPacket
  166.	     */
  167.	    public AtomicLong getReceivedPackets() {
  168.	        return receivedPackets;
  169.	    }
  170.	
  171.	    /**
  172.	     * @return the countSentByte
  173.	     */
  174.	    public AtomicLong getSentBytes() {
  175.	        return sentBytes;
  176.	    }
  177.	
  178.	    /**
  179.	     * @return the countSentPacket
  180.	     */
  181.	    public AtomicLong getSentPackets() {
  182.	        return sentPackets;
  183.	    }
  184.	
  185.	    /**
  186.	     * @return the timeClosed
  187.	     */
  188.	    public long getTimeClosed() {
  189.	        return timeClosed;
  190.	    }
  191.	
  192.	    /**
  193.	     * @return the timeCreated
  194.	     */
  195.	    public long getTimeCreated() {
  196.	        return timeCreated;
  197.	    }
  198.	
  199.	    /**
  200.	     * @return the timeFirstConnected
  201.	     */
  202.	    public Long getTimeFirstConnected() {
  203.	        return timeFirstConnected;
  204.	    }
  205.	
  206.	    /**
  207.	     * @return the timeInReconnQueue
  208.	     */
  209.	    public long getTimeInReconnQueue() {
  210.	        return timeInReconnQueue;
  211.	    }
  212.	
  213.	    /**
  214.	     * @param timeLatestSentMsg the timeLatestSentMsg to set
  215.	     */
  216.	    public void setLatestTimeOfSentPacket(long latestTimeOfSentPacket) {
  217.	        this.latestTimeOfSentPacket = latestTimeOfSentPacket;
  218.	    }
  219.	
  220.	    /**
  221.	     * @param timeClosed the timeClosed to set
  222.	     */
  223.	    public void setTimeClosed(long timeClosed) {
  224.	        this.timeClosed = timeClosed;
  225.	    }
  226.	
  227.	    /**
  228.	     * @param timeFirstConnected the timeFirstConnected to set
  229.	     */
  230.	    public void setTimeFirstConnected(Long timeFirstConnected) {
  231.	        this.timeFirstConnected = timeFirstConnected;
  232.	    }
  233.	
  234.	    /**
  235.	     * @param timeInReconnQueue the timeInReconnQueue to set
  236.	     */
  237.	    public void setTimeInReconnQueue(long timeInReconnQueue) {
  238.	        this.timeInReconnQueue = timeInReconnQueue;
  239.	    }
  240.	
  241.	    /**
  242.	     * @return the latestTimeOfReceivedByte
  243.	     */
  244.	    public long getLatestTimeOfReceivedByte() {
  245.	        return latestTimeOfReceivedByte;
  246.	    }
  247.	
  248.	    /**
  249.	     * @param latestTimeOfReceivedByte the latestTimeOfReceivedByte to set
  250.	     */
  251.	    public void setLatestTimeOfReceivedByte(long latestTimeOfReceivedByte) {
  252.	        this.latestTimeOfReceivedByte = latestTimeOfReceivedByte;
  253.	    }
  254.	
  255.	    /**
  256.	     * @return the latestTimeOfSentByte
  257.	     */
  258.	    public long getLatestTimeOfSentByte() {
  259.	        return latestTimeOfSentByte;
  260.	    }
  261.	
  262.	    /**
  263.	     * @param latestTimeOfSentByte the latestTimeOfSentByte to set
  264.	     */
  265.	    public void setLatestTimeOfSentByte(long latestTimeOfSentByte) {
  266.	        this.latestTimeOfSentByte = latestTimeOfSentByte;
  267.	    }
  268.	
  269.	    /**
  270.	     * @return the receivedTcps
  271.	     */
  272.	    public AtomicLong getReceivedTcps() {
  273.	        return receivedTcps;
  274.	    }
  275.	
  276.	    public AtomicLong getHandledPacketCosts() {
  277.	        return handledPacketCosts;
  278.	    }
  279.	
  280.	    /**
  281.	     * 处理packet平均耗时，单位：毫秒
  282.	     * @return
  283.	     */
  284.	    public double getHandledCostsPerPacket() {
  285.	        if (handledPackets.get() > 0) {
  286.	            return handledPacketCosts.get() / handledPackets.get();
  287.	        }
  288.	        return 0;
  289.	    }
  290.	}
#+END_SRC

** 5.9 ObjWithLock带读写锁的对象
:PROPERTIES:
:ID:       288f4c3f-8b4e-4c0b-8fb2-feb67756255a
:END:
网络编程中会伴随大量并发操作，大家对ConcurrentModificationException一定不会陌生，这个是典型的并发操作集合引发的异常。为了更好的处理并发，tio自创了一个ObjWithLock对象，这个对象很简单，但给并发编程带来了极大的方便，如果您阅读过tio源代码，相信已经体会到这个对象在tio中是无处不在的。ObjWithLock顾名思义，它就是一个自带了一把（读写）锁的普通对象（一般是集合对象），每当要对这个对象进行同步安全操作（并发下对集合进行遍历或对集合对象进行元素修改删除增加）时，就得用这个锁。
ObjWithLock对象源代码见下


#+BEGIN_SRC java

  1.	package org.tio.utils.lock;
  2.	
  3.	import java.io.Serializable;
  4.	import java.util.concurrent.locks.ReentrantReadWriteLock;
  5.	import java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;
  6.	import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;
  7.	
  8.	import org.slf4j.Logger;
  9.	import org.slf4j.LoggerFactory;
  10.	
  11.	/**
  12.	 * 自带读写锁的对象.
  13.	 *
  14.	 * @author tanyaowu
  15.	 */
  16.	public class ObjWithLock<T> implements Serializable {
  17.	
  18.	    private static final long serialVersionUID = -3048283373239453901L;
  19.	
  20.	    private static Logger log = LoggerFactory.getLogger(ObjWithLock.class);
  21.	
  22.	    /**
  23.	     * 
  24.	     */
  25.	    private T obj = null;
  26.	
  27.	    /**
  28.	     * 
  29.	     */
  30.	    private ReentrantReadWriteLock lock = null;
  31.	
  32.	    /**
  33.	     * 
  34.	     * @param obj
  35.	     * @author tanyaowu
  36.	     */
  37.	    public ObjWithLock(T obj) {
  38.	        this(obj, new ReentrantReadWriteLock());
  39.	    }
  40.	
  41.	    /**
  42.	     * 
  43.	     * @param obj
  44.	     * @param lock
  45.	     * @author tanyaowu
  46.	     */
  47.	    public ObjWithLock(T obj, ReentrantReadWriteLock lock) {
  48.	        super();
  49.	        this.obj = obj;
  50.	        this.lock = lock;
  51.	    }
  52.	
  53.	    /**
  54.	     * 
  55.	     * @return
  56.	     * @author tanyaowu
  57.	     */
  58.	    public ReentrantReadWriteLock getLock() {
  59.	        return lock;
  60.	    }
  61.	
  62.	    /**
  63.	     * 获取写锁
  64.	     * @return
  65.	     */
  66.	    public WriteLock writeLock() {
  67.	        return lock.writeLock();
  68.	    }
  69.	
  70.	    /**
  71.	     * 获取读锁
  72.	     * @return
  73.	     */
  74.	    public ReadLock readLock() {
  75.	        return lock.readLock();
  76.	    }
  77.	
  78.	    /**
  79.	     * 
  80.	     * @return
  81.	     * @author tanyaowu
  82.	     */
  83.	    public T getObj() {
  84.	        return obj;
  85.	    }
  86.	
  87.	    /**
  88.	     * 
  89.	     * @param obj
  90.	     * @author tanyaowu
  91.	     */
  92.	    public void setObj(T obj) {
  93.	        this.obj = obj;
  94.	    }
  95.	
  96.	    /**
  97.	     * 操作obj时，带上读锁
  98.	     * @param readLockHandler
  99.	     */
  100.	    public void handle(ReadLockHandler<T>  readLockHandler) {
  101.	        ReadLock readLock = lock.readLock();
  102.	        readLock.lock();
  103.	        try {
  104.	            readLockHandler.handler(obj);
  105.	        } catch (Throwable e) {
  106.	            log.error(e.getMessage(), e);
  107.	        } finally {
  108.	            readLock.unlock();
  109.	        }
  110.	    }
  111.	
  112.	    /**
  113.	     * 操作obj时，带上写锁
  114.	     * @param writeLockHandler
  115.	     */
  116.	    public void handle(WriteLockHandler<T>  writeLockHandler) {
  117.	        WriteLock writeLock = lock.writeLock();
  118.	        writeLock.lock();
  119.	        try {
  120.	            writeLockHandler.handler(obj);
  121.	        } catch (Throwable e) {
  122.	            log.error(e.getMessage(), e);
  123.	        } finally {
  124.	            writeLock.unlock();
  125.	        }
  126.	    }
  127.	
  128.	}
#+END_SRC
为了更便捷地操作，tio提供了三个ObjWithLock子类
•	ListWithLock
•	MapWithLock
•	SetWithLock
ListWithLock里面有Obj就是List对象，MapWithLock里面有Obj就是Map对象，SetWithLock里面有Obj就是Set对象
掌握这些对象，我觉得最好的方法是看个例子，SetWithLock就是个活生生的例子，它的源代码如下


#+BEGIN_SRC java

  1.	package org.tio.utils.lock;
  2.	
  3.	import java.util.Set;
  4.	import java.util.concurrent.locks.ReentrantReadWriteLock;
  5.	import java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;
  6.	import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;
  7.	
  8.	import org.slf4j.Logger;
  9.	import org.slf4j.LoggerFactory;
  10.	
  11.	/**
  12.	 * @author tanyaowu
  13.	 * 2017年5月14日 上午9:55:37
  14.	 */
  15.	public class SetWithLock<T> extends ObjWithLock<Set<T>> {
  16.	    private static final long serialVersionUID = -2305909960649321346L;
  17.	    private static final Logger log = LoggerFactory.getLogger(SetWithLock.class);
  18.	
  19.	    /**
  20.	     * @param set
  21.	     * @author tanyaowu
  22.	     */
  23.	    public SetWithLock(Set<T> set) {
  24.	        super(set);
  25.	    }
  26.	
  27.	    /**
  28.	     * @param set
  29.	     * @param lock
  30.	     * @author tanyaowu
  31.	     */
  32.	    public SetWithLock(Set<T> set, ReentrantReadWriteLock lock) {
  33.	        super(set, lock);
  34.	    }
  35.	
  36.	    /**
  37.	     *
  38.	     * @param t
  39.	     * @return
  40.	     * @author tanyaowu
  41.	     */
  42.	    public boolean add(T t) {
  43.	        WriteLock writeLock = this.writeLock();
  44.	        writeLock.lock();
  45.	        try {
  46.	            Set<T> set = this.getObj();
  47.	            return set.add(t);
  48.	        } catch (Throwable e) {
  49.	            log.error(e.getMessage(), e);
  50.	        } finally {
  51.	            writeLock.unlock();
  52.	        }
  53.	        return false;
  54.	    }
  55.	
  56.	    /**
  57.	     *
  58.	     *
  59.	     * @author tanyaowu
  60.	     */
  61.	    public void clear() {
  62.	        WriteLock writeLock = this.writeLock();
  63.	        writeLock.lock();
  64.	        try {
  65.	            Set<T> set = this.getObj();
  66.	            set.clear();
  67.	        } catch (Throwable e) {
  68.	            log.error(e.getMessage(), e);
  69.	        } finally {
  70.	            writeLock.unlock();
  71.	        }
  72.	    }
  73.	
  74.	    /**
  75.	     *
  76.	     * @param t
  77.	     * @return
  78.	     * @author tanyaowu
  79.	     */
  80.	    public boolean remove(T t) {
  81.	        WriteLock writeLock = this.writeLock();
  82.	        writeLock.lock();
  83.	        try {
  84.	            Set<T> set = this.getObj();
  85.	            return set.remove(t);
  86.	        } catch (Throwable e) {
  87.	            log.error(e.getMessage(), e);
  88.	        } finally {
  89.	            writeLock.unlock();
  90.	        }
  91.	        return false;
  92.	    }
  93.	
  94.	    /**
  95.	     * 
  96.	     * @return
  97.	     * @author tanyaowu
  98.	     */
  99.	    public int size() {
  100.	        ReadLock readLock = this.readLock();
  101.	        readLock.lock();
  102.	        try {
  103.	            Set<T> set = this.getObj();
  104.	            return set.size();
  105.	        } finally {
  106.	            readLock.unlock();
  107.	        }
  108.	    }
  109.	}
#+END_SRC

先拿到相应的锁（根据业务需要获取读锁或写锁，如果只是读取数据，则获取读锁，如果需要对集合进行修改，则获取写锁），然后【 lock()—>业务处理—>unlock() 】，注意一定要在try前面进行lock()，在finally块中进行unlock()操作，这样可以保证一个获取锁到释放锁形成一个原子操作。图解如下

[[file:img/5.9ObjLock.png][对象锁]]


** 5.8 TioClient客户端入口
:PROPERTIES:
:ID:       e1789e1d-b699-42c0-8895-387d9ec90f94
:END:
只有当你在用t-io作为TCP客户端时，才用得到TioClient，此处简单贴一下它的源代码，它的用法，见后面的showcase示范工程

#+BEGIN_SRC java
  1.	package org.tio.client;
  2.	
  3.	import java.io.IOException;
  4.	import java.net.InetSocketAddress;
  5.	import java.net.StandardSocketOptions;
  6.	import java.nio.channels.AsynchronousChannelGroup;
  7.	import java.nio.channels.AsynchronousSocketChannel;
  8.	import java.util.Set;
  9.	import java.util.concurrent.CountDownLatch;
  10.	import java.util.concurrent.LinkedBlockingQueue;
  11.	import java.util.concurrent.TimeUnit;
  12.	import java.util.concurrent.locks.ReentrantReadWriteLock;
  13.	import java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;
  14.	import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;
  15.	
  16.	import org.slf4j.Logger;
  17.	import org.slf4j.LoggerFactory;
  18.	import org.tio.client.intf.ClientAioHandler;
  19.	import org.tio.core.ChannelContext;
  20.	import org.tio.core.Node;
  21.	import org.tio.core.Tio;
  22.	import org.tio.core.intf.Packet;
  23.	import org.tio.core.ssl.SslFacadeContext;
  24.	import org.tio.core.stat.ChannelStat;
  25.	import org.tio.utils.SystemTimer;
  26.	import org.tio.utils.hutool.StrUtil;
  27.	import org.tio.utils.lock.SetWithLock;
  28.	
  29.	/**
  30.	 *
  31.	 * @author tanyaowu
  32.	 * 2017年4月1日 上午9:29:58
  33.	 */
  34.	public class TioClient {
  35.	    /**
  36.	     * 自动重连任务
  37.	     * @author tanyaowu
  38.	     *
  39.	     */
  40.	    private static class ReconnRunnable implements Runnable {
  41.	        ClientChannelContext channelContext = null;
  42.	        TioClient tioClient = null;
  43.	
  44.	        //        private static Map<Node, Long> cacheMap = new HashMap<>();
  45.	
  46.	        public ReconnRunnable(ClientChannelContext channelContext, TioClient tioClient) {
  47.	            this.channelContext = channelContext;
  48.	            this.tioClient = tioClient;
  49.	        }
  50.	
  51.	        /**
  52.	         * @see java.lang.Runnable#run()
  53.	         *
  54.	         * @author tanyaowu
  55.	         * 2017年2月2日 下午8:24:40
  56.	         *
  57.	         */
  58.	        @Override
  59.	        public void run() {
  60.	            ReentrantReadWriteLock closeLock = channelContext.closeLock;
  61.	            WriteLock writeLock = closeLock.writeLock();
  62.	            writeLock.lock();
  63.	            try {
  64.	                if (!channelContext.isClosed) //已经连上了，不需要再重连了
  65.	                {
  66.	                    return;
  67.	                }
  68.	                long start = SystemTimer.currTime;
  69.	                tioClient.reconnect(channelContext, 2);
  70.	                long end = SystemTimer.currTime;
  71.	                long iv = end - start;
  72.	                if (iv >= 100) {
  73.	                    log.error("{},重连耗时:{} ms", channelContext, iv);
  74.	                } else {
  75.	                    log.info("{},重连耗时:{} ms", channelContext, iv);
  76.	                }
  77.	
  78.	                if (channelContext.isClosed) {
  79.	                    channelContext.setReconnCount(channelContext.getReconnCount() + 1);
  80.	                    //                    cacheMap.put(channelContext.getServerNode(), SystemTimer.currTime);
  81.	                    return;
  82.	                }
  83.	            } catch (java.lang.Throwable e) {
  84.	                log.error(e.toString(), e);
  85.	            } finally {
  86.	                writeLock.unlock();
  87.	            }
  88.	
  89.	        }
  90.	    }
  91.	
  92.	    private static Logger log = LoggerFactory.getLogger(TioClient.class);
  93.	
  94.	    private AsynchronousChannelGroup channelGroup;
  95.	
  96.	    private ClientGroupContext clientGroupContext;
  97.	
  98.	    /**
  99.	     * @param serverIp 可以为空
  100.	     * @param serverPort
  101.	     * @param aioDecoder
  102.	     * @param aioEncoder
  103.	     * @param aioHandler
  104.	     *
  105.	     * @author tanyaowu
  106.	     * @throws IOException
  107.	     *
  108.	     */
  109.	    public TioClient(final ClientGroupContext clientGroupContext) throws IOException {
  110.	        super();
  111.	        this.clientGroupContext = clientGroupContext;
  112.	        this.channelGroup = AsynchronousChannelGroup.withThreadPool(clientGroupContext.groupExecutor);
  113.	
  114.	        startHeartbeatTask();
  115.	        startReconnTask();
  116.	    }
  117.	
  118.	    /**
  119.	     *
  120.	     * @param serverNode
  121.	     * @throws Exception
  122.	     *
  123.	     * @author tanyaowu
  124.	     *
  125.	     */
  126.	    public void asynConnect(Node serverNode) throws Exception {
  127.	        asynConnect(serverNode, null);
  128.	    }
  129.	
  130.	    /**
  131.	     *
  132.	     * @param serverNode
  133.	     * @param timeout
  134.	     * @throws Exception
  135.	     *
  136.	     * @author tanyaowu
  137.	     *
  138.	     */
  139.	    public void asynConnect(Node serverNode, Integer timeout) throws Exception {
  140.	        asynConnect(serverNode, null, null, timeout);
  141.	    }
  142.	
  143.	    /**
  144.	     *
  145.	     * @param serverNode
  146.	     * @param bindIp
  147.	     * @param bindPort
  148.	     * @param timeout
  149.	     * @throws Exception
  150.	     *
  151.	     * @author tanyaowu
  152.	     *
  153.	     */
  154.	    public void asynConnect(Node serverNode, String bindIp, Integer bindPort, Integer timeout) throws Exception {
  155.	        connect(serverNode, bindIp, bindPort, null, timeout, false);
  156.	    }
  157.	
  158.	    /**
  159.	     *
  160.	     * @param serverNode
  161.	     * @return
  162.	     * @throws Exception
  163.	     *
  164.	     * @author tanyaowu
  165.	     *
  166.	     */
  167.	    public ClientChannelContext connect(Node serverNode) throws Exception {
  168.	        return connect(serverNode, null);
  169.	    }
  170.	
  171.	    /**
  172.	     *
  173.	     * @param serverNode
  174.	     * @param timeout
  175.	     * @return
  176.	     * @throws Exception
  177.	     * @author tanyaowu
  178.	     */
  179.	    public ClientChannelContext connect(Node serverNode, Integer timeout) throws Exception {
  180.	        return connect(serverNode, null, 0, timeout);
  181.	    }
  182.	
  183.	    /**
  184.	     *
  185.	     * @param serverNode
  186.	     * @param bindIp
  187.	     * @param bindPort
  188.	     * @param initClientChannelContext
  189.	     * @param timeout 超时时间，单位秒
  190.	     * @return
  191.	     * @throws Exception
  192.	     * @author tanyaowu
  193.	     */
  194.	    public ClientChannelContext connect(Node serverNode, String bindIp, Integer bindPort, ClientChannelContext initClientChannelContext, Integer timeout) throws Exception {
  195.	        return connect(serverNode, bindIp, bindPort, initClientChannelContext, timeout, true);
  196.	    }
  197.	
  198.	    /**
  199.	     *
  200.	     * @param serverNode
  201.	     * @param bindIp
  202.	     * @param bindPort
  203.	     * @param initClientChannelContext
  204.	     * @param timeout 超时时间，单位秒
  205.	     * @param isSyn true: 同步, false: 异步
  206.	     * @return
  207.	     * @throws Exception
  208.	     * @author tanyaowu
  209.	     */
  210.	    private ClientChannelContext connect(Node serverNode, String bindIp, Integer bindPort, ClientChannelContext initClientChannelContext, Integer timeout, boolean isSyn)
  211.	            throws Exception {
  212.	
  213.	        AsynchronousSocketChannel asynchronousSocketChannel = null;
  214.	        ClientChannelContext channelContext = null;
  215.	        boolean isReconnect = initClientChannelContext != null;
  216.	        //        ClientAioListener clientAioListener = clientGroupContext.getClientAioListener();
  217.	
  218.	        long start = SystemTimer.currTime;
  219.	        asynchronousSocketChannel = AsynchronousSocketChannel.open(channelGroup);
  220.	        long end = SystemTimer.currTime;
  221.	        long iv = end - start;
  222.	        if (iv >= 100) {
  223.	            log.error("{}, open 耗时:{} ms", channelContext, iv);
  224.	        }
  225.	
  226.	        asynchronousSocketChannel.setOption(StandardSocketOptions.TCP_NODELAY, true);
  227.	        asynchronousSocketChannel.setOption(StandardSocketOptions.SO_REUSEADDR, true);
  228.	        asynchronousSocketChannel.setOption(StandardSocketOptions.SO_KEEPALIVE, true);
  229.	
  230.	        InetSocketAddress bind = null;
  231.	        if (bindPort != null && bindPort > 0) {
  232.	            if (false == StrUtil.isBlank(bindIp)) {
  233.	                bind = new InetSocketAddress(bindIp, bindPort);
  234.	            } else {
  235.	                bind = new InetSocketAddress(bindPort);
  236.	            }
  237.	        }
  238.	
  239.	        if (bind != null) {
  240.	            asynchronousSocketChannel.bind(bind);
  241.	        }
  242.	
  243.	        channelContext = initClientChannelContext;
  244.	
  245.	        start = SystemTimer.currTime;
  246.	
  247.	        InetSocketAddress inetSocketAddress = new InetSocketAddress(serverNode.getIp(), serverNode.getPort());
  248.	
  249.	        ConnectionCompletionVo attachment = new ConnectionCompletionVo(channelContext, this, isReconnect, asynchronousSocketChannel, serverNode, bindIp, bindPort);
  250.	
  251.	        if (isSyn) {
  252.	            Integer realTimeout = timeout;
  253.	            if (realTimeout == null) {
  254.	                realTimeout = 5;
  255.	            }
  256.	
  257.	            CountDownLatch countDownLatch = new CountDownLatch(1);
  258.	            attachment.setCountDownLatch(countDownLatch);
  259.	            asynchronousSocketChannel.connect(inetSocketAddress, attachment, clientGroupContext.getConnectionCompletionHandler());
  260.	            boolean f = countDownLatch.await(realTimeout, TimeUnit.SECONDS);
  261.	            if (f) {
  262.	                return attachment.getChannelContext();
  263.	            } else {
  264.	                log.error("countDownLatch.await(realTimeout, TimeUnit.SECONDS) 返回false ");
  265.	                return attachment.getChannelContext();
  266.	            }
  267.	        } else {
  268.	            asynchronousSocketChannel.connect(inetSocketAddress, attachment, clientGroupContext.getConnectionCompletionHandler());
  269.	            return null;
  270.	        }
  271.	    }
  272.	
  273.	    /**
  274.	     *
  275.	     * @param serverNode
  276.	     * @param bindIp
  277.	     * @param bindPort
  278.	     * @param timeout 超时时间，单位秒
  279.	     * @return
  280.	     * @throws Exception
  281.	     *
  282.	     * @author tanyaowu
  283.	     *
  284.	     */
  285.	    public ClientChannelContext connect(Node serverNode, String bindIp, Integer bindPort, Integer timeout) throws Exception {
  286.	        return connect(serverNode, bindIp, bindPort, null, timeout);
  287.	    }
  288.	
  289.	    /**
  290.	     * @return the channelGroup
  291.	     */
  292.	    public AsynchronousChannelGroup getChannelGroup() {
  293.	        return channelGroup;
  294.	    }
  295.	
  296.	    /**
  297.	     * @return the clientGroupContext
  298.	     */
  299.	    public ClientGroupContext getClientGroupContext() {
  300.	        return clientGroupContext;
  301.	    }
  302.	
  303.	    /**
  304.	     *
  305.	     * @param channelContext
  306.	     * @param timeout
  307.	     * @return
  308.	     * @throws Exception
  309.	     *
  310.	     * @author tanyaowu
  311.	     *
  312.	     */
  313.	    public void reconnect(ClientChannelContext channelContext, Integer timeout) throws Exception {
  314.	        connect(channelContext.getServerNode(), channelContext.getBindIp(), channelContext.getBindPort(), channelContext, timeout);
  315.	    }
  316.	
  317.	    /**
  318.	     * @param clientGroupContext the clientGroupContext to set
  319.	     */
  320.	    public void setClientGroupContext(ClientGroupContext clientGroupContext) {
  321.	        this.clientGroupContext = clientGroupContext;
  322.	    }
  323.	
  324.	    /**
  325.	     * 定时任务：发心跳
  326.	     * @author tanyaowu
  327.	     *
  328.	     */
  329.	    private void startHeartbeatTask() {
  330.	        final ClientGroupStat clientGroupStat = (ClientGroupStat)clientGroupContext.groupStat;
  331.	        final ClientAioHandler aioHandler = clientGroupContext.getClientAioHandler();
  332.	
  333.	        final String id = clientGroupContext.getId();
  334.	        new Thread(new Runnable() {
  335.	            @Override
  336.	            public void run() {
  337.	                while (!clientGroupContext.isStopped()) {
  338.	//                    final long heartbeatTimeout = clientGroupContext.heartbeatTimeout;
  339.	                    if (clientGroupContext.heartbeatTimeout <= 0) {
  340.	                        log.warn("用户取消了框架层面的心跳定时发送功能，请用户自己去完成心跳机制");
  341.	                        break;
  342.	                    }
  343.	                    SetWithLock<ChannelContext> setWithLock = clientGroupContext.connecteds;
  344.	                    ReadLock readLock = setWithLock.readLock();
  345.	                    readLock.lock();
  346.	                    try {
  347.	                        Set<ChannelContext> set = setWithLock.getObj();
  348.	                        long currtime = SystemTimer.currTime;
  349.	                        for (ChannelContext entry : set) {
  350.	                            ClientChannelContext channelContext = (ClientChannelContext) entry;
  351.	                            if (channelContext.isClosed || channelContext.isRemoved) {
  352.	                                continue;
  353.	                            }
  354.	
  355.	                            ChannelStat stat = channelContext.stat;
  356.	                            long compareTime = Math.max(stat.latestTimeOfReceivedByte, stat.latestTimeOfSentPacket);
  357.	                            long interval = currtime - compareTime;
  358.	                            if (interval >= clientGroupContext.heartbeatTimeout / 2) {
  359.	                                Packet packet = aioHandler.heartbeatPacket(channelContext);
  360.	                                if (packet != null) {
  361.	                                    if (log.isInfoEnabled()) {
  362.	                                        log.info("{}发送心跳包", channelContext.toString());
  363.	                                    }
  364.	                                    Tio.send(channelContext, packet);
  365.	                                }
  366.	                            }
  367.	                        }
  368.	                        if (log.isInfoEnabled()) {
  369.	                            log.info("[{}]: curr:{}, closed:{}, received:({}p)({}b), handled:{}, sent:({}p)({}b)", id, set.size(), clientGroupStat.closed.get(),
  370.	                                    clientGroupStat.receivedPackets.get(), clientGroupStat.receivedBytes.get(), clientGroupStat.handledPackets.get(),
  371.	                                    clientGroupStat.sentPackets.get(), clientGroupStat.sentBytes.get());
  372.	                        }
  373.	
  374.	                    } catch (Throwable e) {
  375.	                        log.error("", e);
  376.	                    } finally {
  377.	                        try {
  378.	                            readLock.unlock();
  379.	                            Thread.sleep(clientGroupContext.heartbeatTimeout / 4);
  380.	                        } catch (Throwable e) {
  381.	                            log.error(e.toString(), e);
  382.	                        } finally {
  383.	
  384.	                        }
  385.	                    }
  386.	                }
  387.	            }
  388.	        }, "tio-timer-heartbeat" + id).start();
  389.	    }
  390.	
  391.	    /**
  392.	     * 启动重连任务
  393.	     *
  394.	     *
  395.	     * @author tanyaowu
  396.	     *
  397.	     */
  398.	    private void startReconnTask() {
  399.	        final ReconnConf reconnConf = clientGroupContext.getReconnConf();
  400.	        if (reconnConf == null || reconnConf.getInterval() <= 0) {
  401.	            return;
  402.	        }
  403.	
  404.	        final String id = clientGroupContext.getId();
  405.	        Thread thread = new Thread(new Runnable() {
  406.	            @Override
  407.	            public void run() {
  408.	                while (!clientGroupContext.isStopped()) {
  409.	                    //log.info("准备重连");
  410.	                    LinkedBlockingQueue<ChannelContext> queue = reconnConf.getQueue();
  411.	                    ClientChannelContext channelContext = null;
  412.	                    try {
  413.	                        channelContext = (ClientChannelContext) queue.take();
  414.	                    } catch (InterruptedException e1) {
  415.	                        log.error(e1.toString(), e1);
  416.	                    }
  417.	                    if (channelContext == null) {
  418.	                        continue;
  419.	                        //                        return;
  420.	                    }
  421.	
  422.	                    if (channelContext.isRemoved) //已经删除的，不需要重新再连
  423.	                    {
  424.	                        continue;
  425.	                    }
  426.	
  427.	                    SslFacadeContext sslFacadeContext = channelContext.sslFacadeContext;
  428.	                    if (sslFacadeContext != null) {
  429.	                        sslFacadeContext.setHandshakeCompleted(false);
  430.	                    }
  431.	
  432.	                    long sleeptime = reconnConf.getInterval() - (SystemTimer.currTime - channelContext.stat.timeInReconnQueue);
  433.	                    //log.info("sleeptime:{}, closetime:{}", sleeptime, timeInReconnQueue);
  434.	                    if (sleeptime > 0) {
  435.	                        try {
  436.	                            Thread.sleep(sleeptime);
  437.	                        } catch (InterruptedException e) {
  438.	                            log.error(e.toString(), e);
  439.	                        }
  440.	                    }
  441.	
  442.	                    if (channelContext.isRemoved || !channelContext.isClosed) //已经删除的和已经连上的，不需要重新再连
  443.	                    {
  444.	                        continue;
  445.	                    }
  446.	                    ReconnRunnable runnable = new ReconnRunnable(channelContext, TioClient.this);
  447.	                    reconnConf.getThreadPoolExecutor().execute(runnable);
  448.	                }
  449.	            }
  450.	        });
  451.	        thread.setName("tio-timer-reconnect-" + id);
  452.	        thread.setDaemon(true);
  453.	        thread.start();
  454.	
  455.	    }
  456.	
  457.	    /**
  458.	     * 
  459.	     * @return
  460.	     * @author tanyaowu
  461.	     */
  462.	    public boolean stop() {
  463.	        boolean ret = true;
  464.	        try {
  465.	            clientGroupContext.groupExecutor.shutdown();
  466.	        } catch (Exception e1) {
  467.	            log.error(e1.toString(), e1);
  468.	        }
  469.	        try {
  470.	            clientGroupContext.tioExecutor.shutdown();
  471.	        } catch (Exception e1) {
  472.	            log.error(e1.toString(), e1);
  473.	        }
  474.	
  475.	
  476.	        clientGroupContext.setStopped(true);
  477.	        try {
  478.	            ret = ret && clientGroupContext.groupExecutor.awaitTermination(6000, TimeUnit.SECONDS);
  479.	            ret = ret && clientGroupContext.tioExecutor.awaitTermination(6000, TimeUnit.SECONDS);
  480.	        } catch (InterruptedException e) {
  481.	            log.error(e.getLocalizedMessage(), e);
  482.	        }
  483.	        log.info("client resource has released");
  484.	        return ret;
  485.	    }
  486.	}

#+END_SRC

** 5.7 TioServer服务端入口
:PROPERTIES:
:ID:       67055909-2615-4bfc-9332-cf3c0dd29b89
:END:
这个对象大家稍微了解一下即可，服务器启动时会用到这个对象，简单贴一下它的源代码吧，大家只需要关注它有一个start()方法是用来启动网络服务的即可

#+BEGIN_SRC java

  1.	package org.tio.server;
  2.	
  3.	import java.io.IOException;
  4.	import java.lang.management.ManagementFactory;
  5.	import java.lang.management.RuntimeMXBean;
  6.	import java.net.InetSocketAddress;
  7.	import java.net.StandardSocketOptions;
  8.	import java.nio.channels.AsynchronousChannelGroup;
  9.	import java.nio.channels.AsynchronousServerSocketChannel;
  10.	import java.util.ArrayList;
  11.	import java.util.Date;
  12.	import java.util.List;
  13.	import java.util.concurrent.TimeUnit;
  14.	
  15.	import org.slf4j.Logger;
  16.	import org.slf4j.LoggerFactory;
  17.	import org.tio.core.Node;
  18.	import org.tio.utils.SysConst;
  19.	import org.tio.utils.date.DateUtils;
  20.	import org.tio.utils.hutool.StrUtil;
  21.	
  22.	/**
  23.	 * @author tanyaowu
  24.	 *
  25.	 */
  26.	public class TioServer {
  27.	    private static Logger log = LoggerFactory.getLogger(TioServer.class);
  28.	
  29.	    private ServerGroupContext serverGroupContext;
  30.	
  31.	    private AsynchronousServerSocketChannel serverSocketChannel;
  32.	
  33.	    private AsynchronousChannelGroup channelGroup = null;
  34.	
  35.	    private Node serverNode;
  36.	
  37.	    private boolean isWaitingStop = false;
  38.	
  39.	    /**
  40.	     *
  41.	     * @param serverGroupContext
  42.	     *
  43.	     * @author tanyaowu
  44.	     * 2017年1月2日 下午5:53:06
  45.	     *
  46.	     */
  47.	    public TioServer(ServerGroupContext serverGroupContext) {
  48.	        super();
  49.	        this.serverGroupContext = serverGroupContext;
  50.	    }
  51.	
  52.	    /**
  53.	     * @return the serverGroupContext
  54.	     */
  55.	    public ServerGroupContext getServerGroupContext() {
  56.	        return serverGroupContext;
  57.	    }
  58.	
  59.	    /**
  60.	     * @return the serverNode
  61.	     */
  62.	    public Node getServerNode() {
  63.	        return serverNode;
  64.	    }
  65.	
  66.	    /**
  67.	     * @return the serverSocketChannel
  68.	     */
  69.	    public AsynchronousServerSocketChannel getServerSocketChannel() {
  70.	        return serverSocketChannel;
  71.	    }
  72.	
  73.	    /**
  74.	     * @return the isWaitingStop
  75.	     */
  76.	    public boolean isWaitingStop() {
  77.	        return isWaitingStop;
  78.	    }
  79.	
  80.	    /**
  81.	     * @param serverGroupContext the serverGroupContext to set
  82.	     */
  83.	    public void setServerGroupContext(ServerGroupContext serverGroupContext) {
  84.	        this.serverGroupContext = serverGroupContext;
  85.	    }
  86.	
  87.	    /**
  88.	     * @param isWaitingStop the isWaitingStop to set
  89.	     */
  90.	    public void setWaitingStop(boolean isWaitingStop) {
  91.	        this.isWaitingStop = isWaitingStop;
  92.	    }
  93.	
  94.	    public void start(String serverIp, int serverPort) throws IOException {
  95.	        long start = System.currentTimeMillis();
  96.	        this.serverNode = new Node(serverIp, serverPort);
  97.	        channelGroup = AsynchronousChannelGroup.withThreadPool(serverGroupContext.groupExecutor);
  98.	        serverSocketChannel = AsynchronousServerSocketChannel.open(channelGroup);
  99.	
  100.	        serverSocketChannel.setOption(StandardSocketOptions.SO_REUSEADDR, true);
  101.	        serverSocketChannel.setOption(StandardSocketOptions.SO_RCVBUF, 64 * 1024);
  102.	
  103.	        InetSocketAddress listenAddress = null;
  104.	
  105.	        if (StrUtil.isBlank(serverIp)) {
  106.	            listenAddress = new InetSocketAddress(serverPort);
  107.	        } else {
  108.	            listenAddress = new InetSocketAddress(serverIp, serverPort);
  109.	        }
  110.	
  111.	        serverSocketChannel.bind(listenAddress, 0);
  112.	
  113.	        AcceptCompletionHandler acceptCompletionHandler = serverGroupContext.getAcceptCompletionHandler();
  114.	        serverSocketChannel.accept(this, acceptCompletionHandler);
  115.	
  116.	        serverGroupContext.startTime = System.currentTimeMillis();
  117.	
  118.	        //下面这段代码有点无聊，写得随意，纯粹是为了打印好看些
  119.	        String baseStr = "|----------------------------------------------------------------------------------------|";
  120.	        int baseLen = baseStr.length();
  121.	        StackTraceElement[] ses = Thread.currentThread().getStackTrace();
  122.	        StackTraceElement se = ses[ses.length - 1];
  123.	        int xxLen = 18;
  124.	        int aaLen = baseLen - 3;
  125.	        List<String> infoList = new ArrayList<>();
  126.	        infoList.add(StrUtil.fillAfter("Tio gitee address", ' ', xxLen) + "| " + SysConst.TIO_URL_GITEE);
  127.	        infoList.add(StrUtil.fillAfter("Tio site address", ' ', xxLen) + "| " + SysConst.TIO_URL_SITE);
  128.	        infoList.add(StrUtil.fillAfter("Tio version", ' ', xxLen) + "| " + SysConst.TIO_CORE_VERSION);
  129.	
  130.	        infoList.add(StrUtil.fillAfter("-", '-', aaLen));
  131.	
  132.	        infoList.add(StrUtil.fillAfter("GroupContext name", ' ', xxLen) + "| " + serverGroupContext.getName());
  133.	        infoList.add(StrUtil.fillAfter("Started at", ' ', xxLen) + "| " + DateUtils.formatDateTime(new Date()));
  134.	        infoList.add(StrUtil.fillAfter("Listen on", ' ', xxLen) + "| " + this.serverNode);
  135.	        infoList.add(StrUtil.fillAfter("Main Class", ' ', xxLen) + "| " + se.getClassName());
  136.	
  137.	        try {
  138.	            RuntimeMXBean runtimeMxBean = ManagementFactory.getRuntimeMXBean();
  139.	            String runtimeName = runtimeMxBean.getName();
  140.	            String pid = runtimeName.split("@")[0];
  141.	            long startTime = runtimeMxBean.getStartTime();
  142.	            long startCost = System.currentTimeMillis() - startTime;
  143.	            infoList.add(StrUtil.fillAfter("Jvm start time", ' ', xxLen) + "| " + startCost + " ms");
  144.	            infoList.add(StrUtil.fillAfter("Tio start time", ' ', xxLen) + "| " + (System.currentTimeMillis() - start) + " ms");
  145.	            infoList.add(StrUtil.fillAfter("Pid", ' ', xxLen) + "| " + pid);
  146.	
  147.	        } catch (Exception e) {
  148.	
  149.	        }
  150.	        //100
  151.	        String printStr = "\r\n"+baseStr+"\r\n";
  152.	        //        printStr += "|--" + leftStr + " " + info + " " + rightStr + "--|\r\n";
  153.	        for (String string : infoList) {
  154.	            printStr += "| " + StrUtil.fillAfter(string, ' ', aaLen) + "|\r\n";
  155.	        }
  156.	        printStr += baseStr + "\r\n";
  157.	        if (log.isInfoEnabled()) {
  158.	            log.info(printStr);
  159.	        } else {
  160.	            System.out.println(printStr);
  161.	        }
  162.	    }
  163.	
  164.	    /**
  165.	     * 
  166.	     * @return
  167.	     * @author tanyaowu
  168.	     */
  169.	    public boolean stop() {
  170.	        isWaitingStop = true;
  171.	        boolean ret = true;
  172.	
  173.	        try {
  174.	            channelGroup.shutdownNow();
  175.	        } catch (Exception e) {
  176.	            log.error("channelGroup.shutdownNow()时报错", e);
  177.	        }
  178.	
  179.	        try {
  180.	            serverSocketChannel.close();
  181.	        } catch (Exception e1) {
  182.	            log.error("serverSocketChannel.close()时报错", e1);
  183.	        }
  184.	
  185.	        try {
  186.	            serverGroupContext.groupExecutor.shutdown();
  187.	        } catch (Exception e1) {
  188.	            log.error(e1.toString(), e1);
  189.	        }
  190.	        try {
  191.	            serverGroupContext.tioExecutor.shutdown();
  192.	        } catch (Exception e1) {
  193.	            log.error(e1.toString(), e1);
  194.	        }
  195.	
  196.	        serverGroupContext.setStopped(true);
  197.	        try {
  198.	            ret = ret && serverGroupContext.groupExecutor.awaitTermination(6000, TimeUnit.SECONDS);
  199.	            ret = ret && serverGroupContext.tioExecutor.awaitTermination(6000, TimeUnit.SECONDS);
  200.	        } catch (InterruptedException e) {
  201.	            log.error(e.getLocalizedMessage(), e);
  202.	        }
  203.	
  204.	        log.info(this.serverNode + " stopped");
  205.	        return ret;
  206.	    }
  207.	}
#+END_SRC

** 5.6 AioListener消息来往监听
:PROPERTIES:
:ID:       dacf7e47-73c9-4413-9fc9-0d8b32e10ede
:END:
AioListener是处理消息的核心接口，它有两个子接口，ClientAioListener和ServerAioListener，当用tio作tcp客户端时需要实现ClientAioListener，当用tio作tcp服务器时需要实现ServerAioListener，它主要定义了如下方法

#+BEGIN_SRC java
1.	package org.tio.core.intf;
2.	
3.	import org.tio.core.ChannelContext;
4.	
5.	/**
6.	 *
7.	 * @author tanyaowu
8.	 * 2017年4月1日 上午9:34:08
9.	 */
10.	public interface AioListener {
11.	
12.	
13.	    /**
14.	     * 建链后触发本方法，注：建链不一定成功，需要关注参数isConnected
15.	     * @param channelContext
16.	     * @param isConnected 是否连接成功,true:表示连接成功，false:表示连接失败
17.	     * @param isReconnect 是否是重连, true: 表示这是重新连接，false: 表示这是第一次连接
18.	     * @throws Exception
19.	     * @author: tanyaowu
20.	     */
21.	    public void onAfterConnected(ChannelContext channelContext, boolean isConnected, boolean isReconnect) throws Exception;
22.	
23.	    /**
24.	     * 原方法名：onAfterDecoded
25.	     * 解码成功后触发本方法
26.	     * @param channelContext
27.	     * @param packet
28.	     * @param packetSize
29.	     * @throws Exception
30.	     * @author: tanyaowu
31.	     */
32.	    public void onAfterDecoded(ChannelContext channelContext, Packet packet, int packetSize) throws Exception;
33.	
34.	    /**
35.	     * 接收到TCP层传过来的数据后
36.	     * @param channelContext
37.	     * @param receivedBytes 本次接收了多少字节
38.	     * @throws Exception
39.	     */
40.	    public void onAfterReceivedBytes(ChannelContext channelContext, int receivedBytes) throws Exception;
41.	
42.	    /**
43.	     * 消息包发送之后触发本方法
44.	     * @param channelContext
45.	     * @param packet
46.	     * @param isSentSuccess true:发送成功，false:发送失败
47.	     * @throws Exception
48.	     * @author tanyaowu
49.	     */
50.	    public void onAfterSent(ChannelContext channelContext, Packet packet, boolean isSentSuccess) throws Exception;
51.	
52.	    /**
53.	     * 处理一个消息包后
54.	     * @param channelContext
55.	     * @param packet
56.	     * @param cost 本次处理消息耗时，单位：毫秒
57.	     * @throws Exception
58.	     */
59.	    public void onAfterHandled(ChannelContext channelContext, Packet packet, long cost) throws Exception;
60.	
61.	    /**
62.	     * 连接关闭前触发本方法
63.	     * @param channelContext the channelcontext
64.	     * @param throwable the throwable 有可能为空
65.	     * @param remark the remark 有可能为空
66.	     * @param isRemove
67.	     * @author tanyaowu
68.	     * @throws Exception 
69.	     */
70.	    public void onBeforeClose(ChannelContext channelContext, Throwable throwable, String remark, boolean isRemove) throws Exception;
71.	
72.	    /**
73.	     * 连接关闭前后触发本方法
74.	     * 警告：走到这个里面时，很多绑定的业务都已经解绑了，所以这个方法一般是空着不实现的
75.	     * @param channelContext the channelcontext
76.	     * @param throwable the throwable 有可能为空
77.	     * @param remark the remark 有可能为空
78.	     * @param isRemove 是否是删除
79.	     * @throws Exception
80.	     * @author: tanyaowu
81.	     */
82.	//    public void onAfterClose(ChannelContext channelContext, Throwable throwable, String remark, boolean isRemove) throws Exception;
83.	}
#+END_SRC


** 5.5 AioHandler:编码、解码、处理
:PROPERTIES:
:ID:       08f05aad-e860-47e2-ac61-8050dcf60cbe
:END:
AioHandler是处理消息的核心接口，它有两个子接口，ClientAioHandler和ServerAioHandler，当用tio作tcp客户端时需要实现ClientAioHandler，当用tio作tcp服务器时需要实现ServerAioHandler，它主要定义了3个方法，见下

#+BEGIN_SRC java
1.	package org.tio.core.intf;
2.	
3.	import java.nio.ByteBuffer;
4.	
5.	import org.tio.core.ChannelContext;
6.	import org.tio.core.GroupContext;
7.	import org.tio.core.exception.AioDecodeException;
8.	
9.	/**
10.	 * 
11.	 * @author tanyaowu 
12.	 * 2017年10月19日 上午9:40:15
13.	 */
14.	public interface AioHandler {
15.	
16.	    /**
17.	     * 根据ByteBuffer解码成业务需要的Packet对象.
18.	     * 如果收到的数据不全，导致解码失败，请返回null，在下次消息来时框架层会自动续上前面的收到的数据
19.	     * @param buffer 参与本次希望解码的ByteBuffer
20.	     * @param limit ByteBuffer的limit
21.	     * @param position ByteBuffer的position，不一定是0哦
22.	     * @param readableLength ByteBuffer参与本次解码的有效数据（= limit - position）
23.	     * @param channelContext
24.	     * @return
25.	     * @throws AioDecodeException
26.	     */
27.	    Packet decode(ByteBuffer buffer, int limit, int position, int readableLength, ChannelContext channelContext) throws AioDecodeException;
28.	
29.	    /**
30.	     * 编码
31.	     * @param packet
32.	     * @param groupContext
33.	     * @param channelContext
34.	     * @return
35.	     * @author: tanyaowu
36.	     */
37.	    ByteBuffer encode(Packet packet, GroupContext groupContext, ChannelContext channelContext);
38.	
39.	    /**
40.	     * 处理消息包
41.	     * @param packet
42.	     * @param channelContext
43.	     * @throws Exception
44.	     * @author: tanyaowu
45.	     */
46.	    void handler(Packet packet, ChannelContext channelContext) throws Exception;
47.	
48.	}
#+END_SRC


** 5.4 GroupContext:服务器配置与维护
:PROPERTIES:
:ID:       370b4d2f-5eac-46ec-8d10-ac70c353db28
:END:
我们在写TCP Server时，都会先选好一个端口以监听客户端连接，再创建N组线程池来执行相关的任务，譬如发送消息、解码数据包、处理数据包等任务，还要维护客户端连接的各种数据，为了和业务互动，还要把这些客户端连接和各种业务数据绑定起来，譬如把某个客户端绑定到一个群组，绑定到一个userid，绑定到一个token等。GroupContext就是用来配置线程池、确定监听端口，维护客户端各种数据等的。
GroupContext是个抽象类，如果你是用tio作tcp客户端，那么你需要创建ClientGroupContext，如果你是用tio作tcp服务器，那么你需要创建ServerGroupContext
GroupContext对象包含的信息非常多，主要对象见下图
 [[file:img/5.4GroupContext.png][GroupContext]]

如何获取GroupContext对象

很多用户在使用t-io时，不知道如何获取GroupContext，其实这是个伪命题，因为这个对象是你创建
•	如果你只用了tio-core
获取GroupContext的方式就很简单了，因为这个对象就是你创建的，你把这个对象存为全局变量就可以了

#+BEGIN_SRC java
•	如果你用了tio-websocket-server
1.	WsServerStarter wsServerStarter = new WsServerStarter(port, wsMsgHandler);
2.	ServerGroupContext  serverGroupContext = wsServerStarter.getServerGroupContext();//此处把serverGroupContext存为全局变量即可
#+END_SRC

•	如果你是用了tio-http-server

#+BEGIN_SRC java
1.	org.tio.http.common.HttpRequest.channelContext.groupContext;
#+END_SRC



** 5.3 ChannelContext:TCP链接上下文
:PROPERTIES:
:ID:       b07f3079-43a4-419b-a2c1-d412736b6f23
:END:
每一个tcp连接的建立都会产生一个ChannelContext对象，这是个抽象类，如果你是用t-io作tcp客户端，那么就是ClientChannelContext，如果你是用tio作tcp服务器，那么就是ServerChannelContext
    [[file:img/5.3tcp.png][tcp]] 
用户可以把业务数据通过ChannelContext对象和TCP连接关联起来，像下面这样设置属性

#+BEGIN_SRC java
1.	ChannelContext.setAttribute(String key, Object value)
#+END_SRC

然后用下面的方式获取属性

#+BEGIN_SRC java
1.	ChannelContext.getAttribute(String key)
#+END_SRC

当然最最常用的还是用t-io提供的强大的bind功能，譬如用下面的代码绑定userid

#+BEGIN_SRC java
1.	Tio.bindUser(ChannelContext channelContext, String userid)
#+END_SRC

然后可以通过userid进行操作，示范代码如下

#+BEGIN_SRC java
1.	//获取某用户的ChannelContext集合
2.	SetWithLock<ChannelContext> set = Tio.getChannelContextsByUserid(groupContext, userid);
3.	
4.	//给某用户发消息
5.	Tio.sendToUser(GroupContext, userid, Packet)
#+END_SRC

除了可以绑定userid，t-io还内置了如下绑定API
•	绑定业务id

#+BEGIN_SRC java
1.	Tio.bindBsId(ChannelContext channelContext, String bsId)
#+END_SRC

•	绑定token

#+BEGIN_SRC java
0.	Tio.bindToken(ChannelContext channelContext, String token)
#+END_SRC

•	绑定群组

#+BEGIN_SRC java
0.	Tio.bindGroup(ChannelContext channelContext, String group)
#+END_SRC

ChannelContext对象包含的信息非常多，主要对象见下图
 [[file:img/5.3ChannelContext.png][ChannelContext]]

说明：

ChannelContext是t-io中非常重要的类，他是业务和连接的沟通桥梁！


** 5.2 Packet： 应用层包
:PROPERTIES:
:ID:       509e5370-dd8d-4dd8-aab9-f4f42aaadc3c
:END:
Packet是用于表述业务数据结构的，我们通过继承Packet来实现自己的业务数据结构，对于各位而言，把Packet看作是一个普通的VO对象即可。
此处贴一下Packet的源代码以凑一些字数，不过用户其实并不需要太关心这个源代码，只需要知道要继承这个类以实现自己的业务数据结构类即可。


#+BEGIN_SRC java
  1.	package org.tio.core.intf;
  2.	
  3.	import java.nio.ByteBuffer;
  4.	import java.util.concurrent.CountDownLatch;
  5.	import java.util.concurrent.atomic.AtomicLong;
  6.	
  7.	import org.slf4j.Logger;
  8.	import org.slf4j.LoggerFactory;
  9.	
  10.	/**
  11.	 *
  12.	 * @author tanyaowu
  13.	 * 2017年4月1日 上午9:34:59
  14.	 */
  15.	public class Packet implements java.io.Serializable, Cloneable {
  16.	    private static Logger log = LoggerFactory.getLogger(Packet.class);
  17.	
  18.	    private static final long serialVersionUID = 5275372187150637318L;
  19.	
  20.	    private static final AtomicLong ID_ATOMICLONG = new AtomicLong();
  21.	
  22.	    private Long id = ID_ATOMICLONG.incrementAndGet();
  23.	
  24.	    private int byteCount = 0;
  25.	
  26.	    private Long respId = null;
  27.	
  28.	    private PacketListener packetListener;
  29.	
  30.	    private boolean isBlockSend = false;
  31.	
  32.	    private Meta meta = null;
  33.	
  34.	    /**
  35.	     * 消息是否是另外一台机器通过topic转过来的，如果是就不要死循环地再一次转发啦
  36.	     * 这个属性是tio内部使用，业务层的用户请勿使用
  37.	     */
  38.	    private boolean isFromCluster = false;
  39.	
  40.	    /**
  41.	     * 同步发送时，需要的同步序列号
  42.	     */
  43.	    private Integer synSeq = 0;
  44.	
  45.	    /**
  46.	     * 预编码过的bytebuffer，如果此值不为null，框架则会忽略原来的encode()而直接用此值
  47.	     */
  48.	    private ByteBuffer preEncodedByteBuffer = null;
  49.	
  50.	    /**
  51.	     * 是否已经进行ssl加密过
  52.	     */
  53.	    private boolean isSslEncrypted = false;
  54.	
  55.	    @Override
  56.	    public Packet clone() {
  57.	        try {
  58.	            Packet ret = (Packet) super.clone();
  59.	            ret.setPreEncodedByteBuffer(null);
  60.	            ret.setSslEncrypted(false);
  61.	            return ret;
  62.	        } catch (CloneNotSupportedException e) {
  63.	            log.error("", e);
  64.	            return null;
  65.	        }
  66.	    }
  67.	
  68.	    /**
  69.	     * @return the byteCount
  70.	     */
  71.	    public int getByteCount() {
  72.	        return byteCount;
  73.	    }
  74.	
  75.	    /**
  76.	     * @return the id
  77.	     */
  78.	    public Long getId() {
  79.	        return id;
  80.	    }
  81.	
  82.	    /**
  83.	     * @return the packetListener
  84.	     */
  85.	    public PacketListener getPacketListener() {
  86.	        return packetListener;
  87.	    }
  88.	
  89.	    /**
  90.	     * @return the preEncodedByteBuffer
  91.	     */
  92.	    public ByteBuffer getPreEncodedByteBuffer() {
  93.	        return preEncodedByteBuffer;
  94.	    }
  95.	
  96.	    /**
  97.	     * @return the respId
  98.	     */
  99.	    public Long getRespId() {
  100.	        return respId;
  101.	    }
  102.	
  103.	    /**
  104.	     * @return the synSeq
  105.	     */
  106.	    public Integer getSynSeq() {
  107.	        return synSeq;
  108.	    }
  109.	
  110.	    /**
  111.	     * @return the isBlockSend
  112.	     */
  113.	    public boolean isBlockSend() {
  114.	        return isBlockSend;
  115.	    }
  116.	
  117.	    public String logstr() {
  118.	        return "";
  119.	    }
  120.	
  121.	    /**
  122.	     * @param isBlockSend the isBlockSend to set
  123.	     */
  124.	    public void setBlockSend(boolean isBlockSend) {
  125.	        this.isBlockSend = isBlockSend;
  126.	    }
  127.	
  128.	    /**
  129.	     * @param byteCount the byteCount to set
  130.	     */
  131.	    public void setByteCount(int byteCount) {
  132.	        this.byteCount = byteCount;
  133.	    }
  134.	
  135.	    /**
  136.	     * @param id the id to set
  137.	     */
  138.	    public void setId(Long id) {
  139.	        this.id = id;
  140.	    }
  141.	
  142.	    /**
  143.	     * @param packetListener the packetListener to set
  144.	     */
  145.	    public void setPacketListener(PacketListener packetListener) {
  146.	        this.packetListener = packetListener;
  147.	    }
  148.	
  149.	    /**
  150.	     * @param preEncodedByteBuffer the preEncodedByteBuffer to set
  151.	     */
  152.	    public void setPreEncodedByteBuffer(ByteBuffer preEncodedByteBuffer) {
  153.	        this.preEncodedByteBuffer = preEncodedByteBuffer;
  154.	    }
  155.	
  156.	    /**
  157.	     * @param respId the respId to set
  158.	     */
  159.	    public void setRespId(Long respId) {
  160.	        this.respId = respId;
  161.	    }
  162.	
  163.	    /**
  164.	     * @param synSeq the synSeq to set
  165.	     */
  166.	    public void setSynSeq(Integer synSeq) {
  167.	        this.synSeq = synSeq;
  168.	    }
  169.	
  170.	    public boolean isFromCluster() {
  171.	        return isFromCluster;
  172.	    }
  173.	
  174.	    public void setFromCluster(boolean isFromCluster) {
  175.	        this.isFromCluster = isFromCluster;
  176.	    }
  177.	
  178.	    public boolean isSslEncrypted() {
  179.	        return isSslEncrypted;
  180.	    }
  181.	
  182.	    public void setSslEncrypted(boolean isSslEncrypted) {
  183.	        this.isSslEncrypted = isSslEncrypted;
  184.	    }
  185.	
  186.	    public Meta getMeta() {
  187.	        return meta;
  188.	    }
  189.	
  190.	    public void setMeta(Meta meta) {
  191.	        this.meta = meta;
  192.	    }
  193.	
  194.	    public static class Meta {
  195.	        private Boolean isSentSuccess = false;
  196.	        private CountDownLatch countDownLatch = null;
  197.	
  198.	        public Boolean getIsSentSuccess() {
  199.	            return isSentSuccess;
  200.	        }
  201.	
  202.	        public void setIsSentSuccess(Boolean isSentSuccess) {
  203.	            this.isSentSuccess = isSentSuccess;
  204.	        }
  205.	
  206.	        public CountDownLatch getCountDownLatch() {
  207.	            return countDownLatch;
  208.	        }
  209.	
  210.	        public void setCountDownLatch(CountDownLatch countDownLatch) {
  211.	            this.countDownLatch = countDownLatch;
  212.	        }
  213.	
  214.	    }
  215.	
  216.	}

#+END_SRC

** 5.1 t-io收发消息过程
:PROPERTIES:
:ID:       ab4e1993-37be-4596-b9bf-8cf2884eea75
:END:
t-io收发消息及处理过程，可以用一张图清晰地表达出来
    [[file:img/5.1getAndReceive.png][消息收发过程]]
* 4. t-io示范工程
:PROPERTIES:
:ID:       d2b73732-8b6f-4d18-b488-a76f7106d7d5
:END:
** 4.4 tio-udf-showcase
:PROPERTIES:
:ID:       d736fcbd-680c-4697-b09b-1a2536488228
:END:
引言
•	t-io提供了非常实用的示范工程，这些示范工程不仅仅是供用户学习t-io用的，也是作者本人用来快速搭建新项目的脚手架
•	在t-io提供文档前，大量用户就是通过这些示范工程掌握t-io的，并且将这些项目作为脚手架，直接用到生产环境，这一方面表明掌握t-io并不困难，另一方面表明这些示范工程极具教学和实战价值
•	tio-udp是包含在tio-core的一个功能子集
tio-udp-showcase工程简介
•	用于学习tio-udp-server的示范工程
•	工程地址：https://gitee.com/tywo45/tio-udp-showcase
学习步骤
•	把工程以maven的形式导入到eclipse后
•	运行org.tio.showcase.udp.server.ShowcaseUdpServerStarter启动udp服务器，启动成功后，日志如下


#+BEGIN_SRC java
  1.	2018-12-30 21:08:23,764 INFO  org.tio.core.udp.UdpServer[136]: started tio udp server: 0.0.0.0:3000
#+END_SRC
  •	运行org.tio.showcase.udp.client.UdpClientStarter
  •	观察服务器端的console，会看到如下日志
#+BEGIN_SRC java
  0.	2018-12-30 21:11:27,336 INFO  o.t.s.u.s.ShowcaseUdpHandler[29]: 收到来自127.0.0.1:62699的消息:【775008、用tio开发udp，有点意思】
  1.	2018-12-30 21:11:27,336 INFO  o.t.s.u.s.ShowcaseUdpHandler[29]: 收到来自127.0.0.1:62699的消息:【775009、用tio开发udp，有点意思】
  2.	2018-12-30 21:11:27,336 INFO  o.t.s.u.s.ShowcaseUdpHandler[29]: 收到来自127.0.0.1:62699的消息:【775010、用tio开发udp，有点意思】
  3.	2018-12-30 21:11:27,336 INFO  o.t.s.u.s.ShowcaseUdpHandler[29]: 收到来自127.0.0.1:62699的消息:【775011、用tio开发udp，有点意思】
  4.	2018-12-30 21:11:27,336 INFO  o.t.s.u.s.ShowcaseUdpHandler[29]: 收到来自127.0.0.1:62699的消息:【775012、用tio开发udp，有点意思】
  5.	2018-12-30 21:11:27,336 INFO  o.t.s.u.s.ShowcaseUdpHandler[29]: 收到来自127.0.0.1:62699的消息:【775013、用tio开发udp，有点意思】
  6.	2018-12-30 21:11:27,336 INFO  o.t.s.u.s.ShowcaseUdpHandler[29]: 收到来自127.0.0.1:62699的消息:【775014、用tio开发udp，有点意思】
#+END_SRC

•	整个工程才3个类，简单到极致，少年加油吧！

** 4.3 tio-http-server-showcase
:PROPERTIES:
:ID:       268737f3-942e-4150-93d8-e69799397b00
:END:

引言
•	t-io提供了非常实用的示范工程，这些示范工程不仅仅是供用户学习t-io用的，也是作者本人用来快速搭建新项目的脚手架
•	在t-io提供文档前，大量用户就是通过这些示范工程掌握t-io的，并且将这些项目作为脚手架，直接用到生产环境，这一方面表明掌握t-io并不困难，另一方面表明这些示范工程极具教学和实战价值
•	tio-http-server是基于tio-core实现的http服务器，自带t-io提供的各项API以及一流的性能和稳定性
tio-http-server-showcase工程简介
•	用于学习tio-http-server的示范工程
•	工程地址：https://gitee.com/tywo45/tio-http-server-showcase
入口程序

#+BEGIN_SRC java
1.	org.tio.http.server.showcase.HttpServerShowcaseStarter
#+END_SRC

控制器

#+BEGIN_SRC java
1.	org.tio.http.server.showcase.controller.ShowcaseController
#+END_SRC

启动成功日志

#+BEGIN_SRC java
  12-30 20:43:46 INFO  org.tio.server.TioServer[158]
  |----------------------------------------------------------------------------------------|
  | Tio gitee address | https://gitee.com/tywo45/t-io                                      |
  | Tio site address  | https://t-io.org/                                                  |
  | Tio version       | 3.2.4.v20181218-RELEASE                                            |
  | ---------------------------------------------------------------------------------------|
  | GroupContext name | Tio Http Server                                                    |
  | Started at        | 2018-12-30 20:43:46                                                |
  | Listen on         | 0.0.0.0:80                                                         |
  | Main Class        | org.tio.http.server.showcase.HttpServerShowcaseStarter             |
  | Jvm start time    | 624 ms                                                             |
  | Tio start time    | 21 ms                                                              |
  | Pid               | 9792                                                               |
  |----------------------------------------------------------------------------------------|
#+END_SRC
访问
用浏览器打开：http://127.0.0.1
 
    [[file:img/4.3browser.png][浏览器]]

** 4.2 tio-websocket-showcase
:PROPERTIES:
:ID:       6b6805dc-b178-4ed6-8369-0ddbc8e96586
:END:

引言
•	t-io提供了非常实用的示范工程，这些示范工程不仅仅是供用户学习t-io用的，也是作者本人用来快速搭建新项目的脚手架
•	在t-io提供文档前，大量用户就是通过这些示范工程掌握t-io的，并且将这些项目作为脚手架，直接用到生产环境，这一方面表明掌握t-io并不困难，另一方面表明这些示范工程极具教学和实战价值
•	tio-websocket-server是基于tio-core实现的websocket服务器，自带t-io提供的各项API以及一流的性能和稳定性
tio-websocket-showcase工程简介
•	用于学习tio-websocket-server的示范工程
•	包括wss和流量监控及处理等高级特性
•	还包括t-io作者写的一个用于连接websocket服务器的js小框架——tiows.js（内置断链重连、定时主动发心跳等功能，使用API极其简单）
•	工程地址：https://gitee.com/tywo45/tio-websocket-showcase
•	效果图
 
    [[file:img/4.2weixin.png][微信聊天窗口]]
学习步骤
•	把工程以maven的形式导入到eclipse后
•	运行org.tio.showcase.websocket.server.ShowcaseWebsocketStarter
•	用chrome打开http://127.0.0.1/index.html（说明：本工程不仅会启动websocket服务器，还会启动一个http服务器用于访问websocket服务器）
•	这是个用iframe嵌入了两个demo.html的页面，方便在一个窗口查看群聊效果
•	可以愉快地聊天了
说明
•	服务器端，大家看代码就好，用起来比较简单
•	客户端（js），page/tio/tiows.js是和业务无关的websocket js小框架，主要是实现了重连、定时发心跳等和业务无关的功能

** 4.1 Tio-showcase
:PROPERTIES:
:ID:       a1342ea8-bf92-40e9-919c-2e7d193f6b8b
:END:
引言
•	t-io提供了非常实用的示范工程，这些示范工程不仅仅是供用户学习t-io用的，也是作者本人用来快速搭建新项目的脚手架
•	在t-io提供文档前，大量用户就是通过这些示范工程掌握t-io的，并且将这些项目作为脚手架，直接用到生产环境，这一方面表明掌握t-io并不困难，另一方面表明这些示范工程极具教学和实战价值
tio-showcase工程简介
•	用于学习t-io的示范工程，一共3个示范工程
•	在t-io工程结构一节中已经说了：一般用户口中的t-io就是指tio-core
•	工程地址：https://gitee.com/tywo45/tio-showcase
•	下面分别对这三个工程进行简介
helloworld
•	helloworld是入门t-io最好的方式！而作者也是用心写了一个对生产项目有参考价值的hello tio，而不是仅仅是show hello而hello
•	服务器端入口程序：org.tio.examples.helloworld.server.HelloServerStarter
•	客户端入口程序：org.tio.examples.helloworld.client.HelloClientStarter
•	本例子演示的是一个典型的TCP长连接应用，大体业务简介如下。
•	分为server和client工程，server和client共用common工程
•	服务端和客户端的消息协议比较简单，消息头为4个字节，用以表示消息体的长度，消息体为一个字符串的byte[]
•	服务端先启动，监听6789端口
•	客户端连接到服务端后，会主动向服务器发送一条消息
•	服务器收到消息后会回应一条消息
•	之后，框架层会自动从客户端发心跳到服务器，服务器也会检测心跳有没有超时（这些事都是框架做的，业务层只需要配一个心跳超时参数即可）
•	框架层会在断链后自动重连（这些事都是框架做的，业务层只需要配一个重连配置对象即可）
showcase
•	showcase工程用于进一步掌握t-io，甚至可以用作你项目的脚手架（@精灵007 同学已经用这个工程完成了3个项目）
•	这里有一篇博客，可以参考：ShowCase设计分析
•	服务器端入口程序：org.tio.examples.showcase.server.ShowcaseServerStarter
•	客户端入口程序：org.tio.examples.showcase.client.ShowcaseClientStarter
IM
•	im项目在1.7.0版本前一直都开放的（见：https://gitee.com/tywo45/t-io/tree/v1.7.0），考虑到im的复杂性，这会给作者带来一些额外的咨询工作，所以在后面的版本没有放出来，现在重新放出来
•	j-im项目是在本项目的基础上改造而来的，有兴趣的可以看看j-im
•	服务器端入口程序：org.tio.examples.im.server.ImServerStarter
•	客户端入口程序：org.tio.examples.im.client.ImClientStarter
•	当年有用户用这个工程 轰出每秒收发500万条聊天消息 （当然现在t-io加了各种流量监控后，简单测试发现性能大约降了一半）

[[file:img/4.1ChatRoom.png][chatRoom]]
* 3. 性能和稳定性
:PROPERTIES:
:ID:       e6a57c18-f69e-4a37-a544-aa80a5c9ce52
:END:
** 3.2 TFB性能PK平台
:PROPERTIES:
:ID:       dccc530c-1e38-4350-a141-7ef5e51f9549
:END:
•	在actframework作者罗总的怂恿下，t-io未也加入了全球最大的免费性能PK平台——TFB，t-io拿去PK的作品是基于tio-http-server的tio-mvc，说是叫tio-mvc，其实这个tio-mvc是内置在tio-http-server中的
•	观战地址：https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext

•	特别说明：不少非常大众的很多框架是排在tio-mvc后面的，譬如… …（此处还是不点名），排在tio-mvc前面的框架有少数框架是不具备生产实战能力的，譬如有的框架可能连基本的参数绑定、甚至post都不支持（此处亦不点名），纯粹一玩物！
•	当然：性能到这份上，再对性能斤斤计较，也是没太多必要，还是花更大精力去提供更优质的业务功能更实在一些。像actframework的性能就非常靠前，但actframework的作者也是很少提及它家作品的性能了，而是强调actframework的表达力
** 3.1 t-io 30W长连接并发压力测试报告
:PROPERTIES:
:ID:       fff89213-3e04-413f-9b85-e65a890d007f
:END:
开始前准备。操作系统Ubuntu 12
在/etc/sysctl.conf中添加如下配置：

#+BEGIN_SRC java

  s.file-max = 1048576
  2.	net.ipv4.ip_local_port_range = 1024 65535
  3.	net.ipv4.tcp_mem = 786432 2097152 3145728
  4.	net.ipv4.tcp_rmem = 4096 4096 16777216
  5.	net.ipv4.tcp_wmem = 4096 4096 16777216
  6.	
  7.	net.ipv4.tcp_tw_reuse = 1
  8.	net.ipv4.tcp_tw_recycle = 1
#+END_SRC

在/etc/security/limits.conf中添加如下配置：

#+BEGIN_SRC java
1.	*    soft nofile 1048576
2.	*    hard nofile 1048576
#+END_SRC

最后使用ulimit -an查询设置是否生效。
测试主机cpu:
[[file:img/3.1cpu.png][CPU]] 
内存：
[[file:img/3.2memory.png][内存]] 
客户端测试机用VMware创建12台虚拟机。机器性能就不列举了。每台虚拟机可以跑3W链接
1：t-io启动时内存占用率以及链接情况
[[file:img/3.1free.png][内存占用率以及链接情况]] 
2：5W链接时内存占用情况
[[file:img/3.1ss.png][ss]] 
3：10W
[[file:img/3.110w.png][10W]] 
4：20W
[[file:img/3.120w.png][20w]] 
5：30W
[[file:img/3.130w.png][30w]] 
java进程统计情况
[[file:img/3.1proced.png][进程]] 
cpu
 
 
jvm

[[file:img/3.1jvm.png][jvm1]] 

[[file:img/3.1jvm2.png][jvm2]]
 
2小时后观察内存变化情况如下图
[[file:img/3.1free2.png][2小时内存使用情况]] 

*** 结论如下

•	0-10万连接。内存变化较大。主要是由于内存初始化时jvm会占用一部分内存。
•	10万之后。每增加10万连接 内存占用率上升300M左右。
•	随着连接数增加可以发现cpu性能对连接数影响不大。
•	新生代内存与老生代内存占用率比较合理。
•	并发30W连接在2小时内。内存变化不明显。处于合理状态
根据以上数据可以推论 —-> 以8G内存(可使用内存为7.5G左右)为例:当内存占用率达到5G左右时足以支撑100W并发连接。


* 2. t-io背景
:PROPERTIES:
:ID:       430b7bc8-c366-4419-a10d-ac8b378af230
:END:

** 2.3 t-io工程结构及讲解
:PROPERTIES:
:ID:       01bc1d17-89af-4bce-bc3c-8ff970690223
:END:
先用一张图描述t-io的工程结构
[[file:img/11.1extend.png][工程结构图]]
各工程分别讲解
*** tio-utils

1. tio-utils是笔者在项目开发中积累的部分工具类
2. 	里面有少部分代码是在开源许可范围内摘自第三方开源项目代码的，还有部分代码是其它开源作者提供的，譬如hutool的作者路神就提供了许多类，在此也是表示感谢！笔者这么做，仅仅是因为广大用户强力要求tio减少第三方依赖！
3. 当然笔者更愿意使第三方工具类，譬如hutool
4. 在tio-utils中目前鄙人用得最多的Cache
5. 首先这个Cache是个门面——把市面上的各路Cache统一成了ICache，操作方法统一了，
6.  其次它内置了一级cache，两级cache，并且性能极好、操作省心、稳定性也在大量项目中得到了考验
7. 哦，说这么，其实就是想挑战J2cache，不过tio-utils也把J2cache门面化了^_^
*** tio-core

•	大家口中的t-io或tio指的就是tio-core，这个一定要记住，要不然会混掉
•	tio-core依赖tio-utils

•	tio-core基于java aio的网络编程框架（很多人说t-io是基于netty，大家不要听信这样不负责任的言论）
•	如果你知道netty是啥，那理解tio-core就很容易了，因为tio-core是和netty类似的框架
•	关于社区的问答
•	问：市面上已经有netty这样优秀的框架，为何还要自己写一个tio-core？
•	答：每个人心中有杆秤，你认为优秀的，不代表所有人都这样认为
•	问：和netty比，tio-core有何优势和劣势？
•	答：很难回答这个问题，说几个事实：
•	在t-io没提供任何文档的情况下，许多用户仅依靠笔者提供的示范工程就掌握了tio，并用于生产项目中，这表明t-io很容易上手
*** tio-mvc
•	tio-mvc是基于tio-http-server的mvc框架，它在TFB上的性能排名不差（不得不严肃提醒各位：TFB上部分排在tio-mvc前面的框架，并不具备用于生产项目的能力，而只是DEMO级别的，譬如协议容错、协议防攻击、session支持、分布session支持，流控这些都没有，重要的是普通开发工程师难以入手）

 
•	tio-mvc在TFB上的PK排名表明t-io性能很好
•	观察了解t-io的历史，以及大量生产项目以及真实用户的口碑，这个能表明t-io足够稳定！
•	性能达到一定高度的前提下，再对比性能，其已经意义不大，稳定性、易用性、坑多否才是后面主要的竞技场！
•	貌似说了一堆和问题无关的内容？！是的，和netty的对比，只能由第三方公正处给出，而不是我！
*** tio-http-common
•	一个给tio-http-server和tio-http-client共用的工程，大家可以略过
*** tio-http-server
•	基于tio-core（为啥不说是基于tio-http-common？怎么说都可以）实现的http服务器
•	内置了极易使用的MVC框架
•	内置了流控、拉黑、forward、拦截器等常用能力
•	性能优秀，前面已经有地方描述了它在TFB上的性能表现，在TFB上tio-mvc的性能远超使用人群最多的springmvc，当然这不是说springmvc不优秀，而是说性能到这份上了，再说性能没啥意义！
*** tio-websocket-common
•	一个给tio-websocket-server和tio-websocket-client共用的工程，大家可以略过
*** tio-websocket-server
•	基于tio-core（为啥不说是基于tio-websocket-common？怎么说都可以）实现的websocket服务器
•	请注意：tio-http-server和tio-websocket-server是分开的，不能在同一端口用tio-http-server和tio-websocket-server，这么样的原因很简单：为了提升性能。
•	“哦，那为什么其它框架是放在一起的？”
•	“我想说的是websocket协议是后来硬扯在http协议之上的，从设计上来讲：这俩货根本就不应该呆在一起，搞得笔者在实现websocket协议时，还得用http协议来完成握手”
*** tio-webpack-core
•	笔者在tio-http-server的基础之上依赖freemarker实现的类似nodejs webpack的功能，现在还没完全封装到位，就笔者一人在用
•	你现在正在浏览的网页就是基于tio-webpacke-core的，不信你用右键点击查看源代码，全TM压缩或加密的^_^

** 2.2 t-io应用场景和能力
:PROPERTIES:
:ID:       d4125bb8-f634-442e-ba15-771603350636
:END:
t-io是基于JVM的网络编程框架，和netty属同类，所以netty能做的t-io都能做，考虑到t-io是从项目抽象出来的框架，所以t-io提供了更多的和业务相关的API，大体上t-io具有如下特点和能力

1. 提供了最强级别的监控和流控能力
2. 内置半包粘包处理
3. 最强最稳级别的资源管理能力
4. 内置心跳检查和心跳发送能力
5. IP拉黑
6. 各种花式群发能力
7. 一流的性能
8. 极其稳定的表现(很多用户还是停在t-io 1.x版本，就是因为太过稳定，不想变动)
9. 内置慢攻击防御
10. 异步发送、阻塞发送、同步发送一个不落
11. 	内置简单的集群发送消息能力(集群更多的是和业务耦合的，所以内置的集群始终是有限的)
12. 	多端口资源共享能力（譬如一个端口是websocket协议，一个端口是私有的im协议，这两个端口的资源可以共享，这对协议适配极其有用）
13. 	极强的资源和业务绑定能力：绑定group、绑定userid、绑定token、绑定bsId，这些绑定几乎囊括了所有业务需求

把t-io的使用场景和能力用一张图简述一下

[[file:img/11.1talent.png][使用场景和历史]]
** 2.1 t-io发展历史
:PROPERTIES:
:ID:       bc9e6f46-9e05-49d4-be24-6fd3fba2fad8
:END:

2018年

1.       基于tio-core、tio-websocket、tio-http、tio-webpack的大型金融直播平台—— 牛吧云播正式上线
2. GVP开源项目贝密游戏在已经大量使用netty的情况下，用t-io重写通讯模块，并表示：” 换上t-io后，吃嘛嘛香 “
3. 开源java区块链平台md_blockchain表示：” t-io在联盟链的网络通信中表现非常稳定 “
4. 基于t-io的开源IM项目 J-IM ，获得开源社区的极大关注，并斩获GVP大奖，据说J-IM作者薪水大涨^_^
5. 氦氪云 的协议网关采用t-io实现
6. 上市公司 长飞光纤 ，S8000协议采用t-io实现
7. 更多的用户愿意反馈t-io使用案例

2017年

1. talent-aio改名为t-io
2. 用t-io实现了http、websocket协议
3. 基于tio-http创建了用于传统前端的tio-webpack框架
4. t-io案例大量产生，用户口碑极佳
5. 获GVP(Gitee Most Valuable Projects) - 码云最有价值开源项目计划、年度欢迎开源项目等奖


2016年

1. 用AIO技术创建了talent-aio框架，代码入驻码云

2015年

1. 开始关注AIO技术，同时进一步提升和封装多线程、锁等技术

2014年

1. 用talent-nio实现了热波直播平台的IM模块

2013年

1. 短暂性介入开源项目mycat，并用talent-nio实现了Mycat-Balance(不是pom方式引入)

2012年

1. 在离开中兴后，用开发EMF积累的NIO及多线程等知识，创建了talent-nio框架

2011年

1. 新EMF框架应用于新的网管项目V4，该项目迄今(2018-12-27)仍然稳定运行

2010年

1. 用NIO技术重写中兴网管底层通讯框架EMF，解决了大量不稳定因素

* 1.网络编程预备知识
:PROPERTIES:
:ID:       ae3c881e-9a21-4628-8e23-b64fb130f54a
:END:

** 1.4 半包和粘包
:PROPERTIES:
:ID:       f80a5332-4716-4140-bd09-2069b99ce2ee
:END:
*** 半包
1. 顾名思义，就是收到了半个包，这个时候不足以组成一个应用层的包。就像你要对你喜欢的人说“我喜欢你”，但是因为喝水咽着了，第一次只说了“我”字，第二次说了个“喜”字，第三个次了个“欢你”，那么就发生了半包问题，对方只有等待你说完这4个字后才知道你是想说“我喜欢你”！
2. 用http协议为例，展示半包场景

[[file:img/1.4ban.png][半包实例]] 

*** 粘包
1.      粘包与半包相反，就是把多个想说的话，一口气说完了，对方反应不过来，得把你的话拆开一条一条地理解
2. 用http协议为例，展示粘包场景
[[file:img/1.4nianbao.png][粘包实例]] 
说明：http协议是一来一回的，所以正常场景是不会有粘包的，但pipeline模式下是允许一方连续发多个请求的，所以会有粘包产生
为何坑人无数
3. 初涉网络编程的同学，往往认为每次收到的数据刚好是一个完整的数据包
4.    于是当网络不好，或是消息包过大时，半包的情况就发生了，而程序并没有考虑到半包的情况，结果就是解码失败，导致消息丢失
5. 当通信的对方把数条数据包放在一个TCP包中发过来时，粘包就产生了，而程序没有考虑到一次TCP收包会收到多个业务包，从而解析到第一个业务包后把后面的业务包丢弃了
6. 百度一下半包粘包，一定会搜到很多记录，这也证明这俩货确实坑人无数，所以看完本节内容，你还会继续犯半包粘包的错吗？

** 1.3ByteBuffer:网络编程必须的数据结构
:PROPERTIES:
:ID:       1e8c0b61-ade6-4fd2-96b8-b9b524a96c3c
:END:

ByteBuffer是nio/aio编程所必须掌握的一个数据结构，也是掌握tio所必须要学会的基础知识。
设想你不懂Map，不懂List，不懂Set，那么你在编程领域将会一事无成，同样的道理ByteBuffer是nio/aio编程领域必不可缺的必备技能
初识ByteBuffer
我们可以把bytebuffer理解成如下几个属性组成的一个数据结构

#+BEGIN_SRC java
•	byte[] bytes: 用来存储数据
•	int capacity: 用来表示bytes的容量，那么可以想像capacity就等于bytes.size()，此值在初始化bytes后，是不可变的。
•	int limit: 用来表示bytes实际装了多少数据，可以容易想像得到limit <= capacity，此值是可灵活变动的
•	int position: 用来表示在哪个位置开始往bytes写数据或是读数据，此值是可灵活变动的
#+END_SRC

一图感知一下ByteBuffer

[[file:img/1.3bb.png][bytebuffer定义]]
*** 创建ByteBuffer
ByteBuffer.allocate(int cap)即可创建一个指定容器大小的ByteBuffer，见图

[[file:img/1.3bb2.png][创建byteBuffer]] 

*** 往ByteBuffer中写入数据
调用ByteBuffer.put(byte b)即可ByteBuffer中写入一个字节，见图
[[file:img/1.3bb3.png][写入bytebuffer]] 
*** 从ByteBuffer读取数据
对于刚刚写好的bytebuffer，我们要读取它的内容，需要先设置一下position和limit，否则读的位置就不对

#+BEGIN_SRC java
1.	byteBuffer.position(0);  //设置position到0位置，这样读数据时就从这个位置开始读
2.	byteBuffer.limit(1);     //设置limit为1，表示当前bytebuffer的有效数据长度是1
#+END_SRC

[[file:img/1.3getData.png][读取数据1]] 
接下来调用ByteBuffer.get()即可读取一个字节，在读取数据的同时，ByteBuffer的position也会跟关位移，见图

[[file:img/1.3bb4.png][读取数据2]] 


** 1.2 应用层和传输成的关系
:PROPERTIES:
:ID:       642c0766-633f-4dbc-a40a-e42cbc9fc376
:END:

1.	以http协议为例，我们在访问一个网站时，浏览器会通过TCP协议发送如下字符串到服务器的应用层

#+BEGIN_SRC java
1.	GET /test/abtest HTTP/1.1
2.	Host: 127.0.0.1
3.	Connection: keep-alive
4.	Cache-Control: max-age=0
5.	Upgrade-Insecure-Requests: 1
6.	User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36
7.	Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
8.	Accept-Encoding: gzip, deflate, br
9.	Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
10.	Cookie: PHPSESSID=970260278652571648
#+END_SRC

2. 程序调试截图(tio的HttpRequest.toString())
[[file:img/1.2debug.png][程序调试图]] 
3. 这些字符串就是应用层数据，应用层数据是按照一定格式来组织的，这个格式就是应用层协议，譬如http协议。
4. 传输层在往应用层传递数据时，并不保证每次传递的数据是一个完整的应用层数据包（以http协议为例，就是并不保证应用层收到的数据刚好可以组成一个http包），这就是我们经常提到的半包和粘包。传输层只负责传递byte[]数据，应用层需要自己对byte[]数据进行解码，以http协议为例，就是把byte[]解码成http协议格式的字符串。

** 1.1 TCP/IP协议分层模型
:PROPERTIES:
:ID:       2d2880f1-eab8-4a62-88bc-4f5f80d2e665
:END:
	大学教科书中有说分成7层，也有说分成4层的，笔者觉得4层更合适一些，像七层中的第5、6层完全不是必须的，就算有也是各自制定协议，而制定协议的人基本不会去考虑第5层叫会话层第6层叫表示层，在私有应用层协议中，更多的是会私定一个握手互信协议，以表示通讯双方是互信的
[[file:img/1.1tcp.jpg][tcp/ip网络协议]]
*** 应用层？

1. 你想用java写一个网络程序，你写的这个程序就是应用层
2. 所以QQ、微信、以及你正在使用的浏览器，都是应用层
*** 应用层数据？
1. 你想通过你前面写的这个网络程序发一个字符串”are you ok”到对方，这个字符串”are you ok”就是应用层数据
2. 对方回你一句”yes, I am fine”，这个”yes, I am fine”也是应用层数据
*** 传输层?

1. 传输层要么走TCP协议，要么走UDP协议，没有第三种协议
2. TCP协议的通信双方，需要知道彼此都在家呆着，且由客户端主动发起连接
3. UDP协议，客户端知道服务器家住在哪，但并不知道服务器在不在家，扔条消息去服务器家，如果服务器不在家这条消息就被丢了
4. 应用层把数据丢给传输层后，传输层把数据进行一下包装，包装纸上面写着“源端口、目的端口、序号、确认序号、检验和等TCP自身的数据”
5. 传输层把数据给应用层时，会拆开对方的包装纸，应用层只看得到对方应用层发的数据

*** 传输层数据?

1. 就是应用层的数据带上一张包装纸后的数据
2. 这层包装纸就是传输层的元数据或叫头部数据
3. 为什么要带包装纸？因为要实名呀，现在快递都要实名了
