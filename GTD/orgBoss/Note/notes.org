* Quick notes

:LOGBOOK:
CLOCK: [2017-10-02 周一 11:09]--[2017-10-02 周一 11:10] =>  0:01
CLOCK: [2017-09-29 周五 11:03]j


CLOCK: [2017-09-28 周四 13:41]--[2017-09-28 周四 13:42] =>  0:01
:END:
** tomato time [#B]                                                  :@F708:
                           Added: [2017-10-02 周一 11:09]
  ● 开心网的偷菜游戏？你是不是老是惦记着收菜的时间？你收的不是菜，是番茄
  ● 奥运会倒计时，高考倒计时？很大很重要的一个番茄
  ● 老板明天要的资料？味道不怎么样的番茄
我想说的是，番茄时间的核心是倒计时所产生的紧迫感。这是中科院心理学专业毕业的老郭（郭军峰）告诉我的，感谢哦。 

** cljrefactor call last thread call [#B]                            :@work:
                           Added: [2017-09-30 周六 05:21]
-https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-thread-first-all


** cljr thread first all [#B]                                        :@work:
                           Added: [2017-09-30 周六 05:23]
                           
https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-thread-last-all

Start with:

(map square (filter even? [1 2 3 4 5]))

Put your cursor in front of the s-exp, and call cljr-thread-last-all:

(->> [1 2 3 4 5]
     (filter even?)
     (map square))

** CFD nacell wiwith bump [#B]                                       :@work:
                           Added: [2017-09-29 周五 11:02]
     首先，总算完成了大小网格的嵌套功能。 划分到机舱的过程中基本上比较正常，就是做了几次o剖而已，然后对应关联而已，
只不过在几何的处理上，有一个很小的技巧就是需要把机舱的线往前copy一个buffer长度的距离，这样就能够做到两次o剖，第三次o剖在过渡到
圆上，在两次o剖后，就可以把机舱的内部网格删掉；而在第三次o剖圆的过程，把圆内的网格再删掉； 还有在第一次o剖机舱头部的时候，需要把
机舱上尾部的点进行split block,尾部的点、线进行关联操作，当然机舱的头部也要进行split block，进行线关联。
     完成了上述的过程之后，也就是最后一步达到buffer区域圆的删除，就可以进一步做bump的切割。这一步的切割很有讲究，流线方向上切上两刀
即可（这边需要注意的是，不要切上三刀，只是bump的前后面即可，把他当作一个正方体去对待，防止切多了，不需要进行流线的线关联了，事先在机
舱头的o剖就已经进行了关联）。注意在你每进行切割的时候，都得把质量检查打开，防止出现太糟糕的网格质量。 要注意的是，从bump开始的切割都
是使用visible select block的方式，而不是All, 现在得选择bump上面的三个block快，然后选择斜边，选择bump竖直方向的第二个点，紧接着切割选择
第三个点，这样就算完成了，然后就是一个关联工作，把bump点关联上，然后是线关联。
      至此完工。 这边有一个对应关系，也就是你需要把梯形体，想成六面体进行切割，正如你在进行o剖的时候，把直翼段想成圆柱段的感觉一样，
然后进行o剖。
** emacs auto open gtd file                                           :NOTE:
                           Added: [2017-09-28 周四 13:40]
  
== Automatically open your todo.org every time you start Emacs ==

Make your life a little bit easier by automatically opening ~/todo.org every time you open Emacs. Add this to the end of your Emacs configuration. To do that,

    C-x C-f ~/.emacs.d/init.el - use find-file to open your configuration file. If it does not yet exist, it is created.
    Go to the end of this file. (Handy shortcut: C-end)
    Add (find-file "~/todo.org")
    Save with C-x C-s (save-buffer).

You can test it with M-x eval-buffer while looking at your ~/.emacs.d/init.el. If it works, it should show you your ~/todo.org file.

You have just written a little Emacs Lisp. Totally not scary.



http://members.optusnet.com.au/~charles57/GTD/datetree.html
 %^g prompts for a tag
I timestamp all my captured items with the line: Added: %U
Some of my items are filed after a specific headline in a file. Appointments are filed under a heading Calendar.
Other entries are filed in date trees. These are explained in the next section


http://blog.csdn.net/u011729865/article/details/54236547


http://blog.csdn.net/jiluben/article/details/39587723
关于org-capture-templates配置代码的解释
原创 2014年09月26日 22:13:02

      对于org-capture-templates的配置，网上只有如下几行代码：

   (setq org-capture-templates
      '(("t" "Todo" entry (file+headline "~/org/gtd.org" "Tasks")
             "* TODO %?\n  %i\n  %a")
        ("j" "Journal" entry (file+datetree "~/org/journal.org")
             "* %?\nEntered on %U\n  %i\n  %a")))
    大家都是这么写，但是并没有解释每个代码的含义。
    经过几次的测试，各个代码的意义大体如下：
    
    现在以

("t" "Todo" entry (file+headline "~/org/gtd.org" "Tasks")
             "* TODO %?\n  %i\n  %a")

为例进行说明。
   "t"代表快捷键，如果我们要调用org-capture，必须按下C-c c的组合键，此时emacs就会显示出
一写字母等，如t、j等，这个"t"就是代码中的"t",我们可以根据自己的意愿设置。
   "Todo"目前还不清楚。
    当为"file+headline"时，后面要跟两个参数，一个是文件的地址，如"~/org/gtd.org"，另一个是
我们当前文档所属的标题。本配置中是"Tasks",意味着当我们在按下C-c c t，并输入内容，再按下
C-c C-c后，我们的内容会自动归档到gtd.org文件的Tasks标题下，若文件gtd.org中没有Tasks标题，
系统会自动产生一个。
    "*"具体意义不知道，如果没有，在按下C-c c后，再按t，无法调出gtd文件。
     "TODO"会显示再文本标题中，大家也可以换成"SOMEDAY"等，自己想要的状态。
      "%a"代表你按C-c c前，鼠标所在的内容。
      其它的内容还没有弄明白。

     附：

     %a          annotation, normally the link created with org-store-link
     %i          initial content, the region when capture is called with C-u.
     %t          timestamp, date only
     %T          timestamp with date and time
     %u, %U      like the above, but inactive timestamps
     %?          表示cursor定位于此 开始输入

http://doc.norang.ca/org-mode.html

https://github.com/bbatsov/prelude

https://www.zhihu.com/question/26384934/answer/32686989
大半年前正值我开写博士论文， 对于这种大部头的写作， 提纲无疑十分重要， 我也尝试过许多mindmap软件来做规划， 结果都乱做一团。 最后还是把维度降到1


Org能识别无序列表、有序列表、和描述表


https://link.zhihu.com/?target=http%3A//orgmode.org/org.pdf
** org-bookmark-heading [#B]                                         :@work:
                         Added: [2017-10-14 周六 20:05]
                         
This package provides Emacs bookmark support for org-mode. You can bookmark headings in org-mode files and jump to them using standard Emacs bookmark commands.

It seems like this file should be named org-bookmark.el, but a package by that name already exists in org-mode/contrib which lets org-mode links point to Emacs bookmarks, sort-of the reverse of this package.

It also seems like this should be built-in to org-mode… ;)
** org time budget [#B]                                              :@work:
:LOGBOOK:
CLOCK: [2017-10-14 周六 23:23]--[2017-10-14 周六 23:30] =>  0:07
:END:
                         Added: [2017-10-14 周六 23:23]
** 秀才饿死不买书 [#B]                                               :@F708:
:LOGBOOK:
CLOCK: [2017-10-15 周日 00:29]--[2017-10-15 周日 00:29] =>  0:00
:END:
                         Added: [2017-10-15 周日 00:28]
                        
壮士饿死不迈剑 
** 工作 [#B]                                                         :@work:
:LOGBOOK:
CLOCK: [2017-10-15 周日 01:18]--[2017-10-15 周日 01:24] =>  0:06
:END:
                         Added: [2017-10-15 周日 01:17]
                         
1. 你做了什么
2. 你希望的结果是什么
3. 实际上的结果是什么
https://github.com/marboo/orgmode-cn/blob/master/org.org#Clocking%20work%20time


8.1 时间戳
http://www.cnblogs.com/Open_Source/archive/2011/07/17/2108747.html#sec-8
跟普通时间戳一样，但是这里是方括号而不是尖括号。这种时间戳是未激活的
，它 不 会让一个条目显示在议程中
** defmulti [#B]                                                     :@work:
:LOGBOOK:
CLOCK: [2017-10-15 周日 13:49]--[2017-10-15 周日 13:49] =>  0:00
:END:
                         Added: [2017-10-15 周日 13:49]

                         http://clojuredocs.org/clojure.core/defmulti
** clojure programming [#B]                                          :@F708:
:LOGBOOK:
CLOCK: [2017-10-16 周一 09:16]--[2017-10-16 周一 10:23] =>  1:07
:END:
                         Added: [2017-10-16 周一 09:15]
                         
programming clojure2012.pdf

Chapter7

Macro

With most programming techniques, you build features within language.

when you write macros, it is more accurate to say that you area
"adding features to" the language. This is a powerful and dangerous
ability, so you should follow the rules in 7.1

At least until you have enough experience to decide for yourself when
to bend the rules.

While powerful, macros are not always simple. Clojure works to make macros
as simple as feasible by including convenience to solve many common
problems that occur when writing macros.

taxonomy(分类系统) taxonomy of Macros(7.4 introduces a taxonomy of 
clojure macros, based on the macros in clojure and contrib libraries.

In clojure, you just implement feature X using a macro(while in most
languages, you sense that incompleteness whenever you say,"My life
would be easier if only my language had feature X."

Some expressions, such as
1. numbers
   1. Integers
   2. floats
   3. rationals
2. symbols
3. keywords(numbers,symbols and keywords are self evaluating)
4. Booleans
5. characters
6. functions
7. functions calls
8. macros
9. strings
10. literal maps
11. vectors
12. queues
13. records
14. sets
** PIC [#B]                                                          :@F708:
:LOGBOOK:
CLOCK: [2017-10-25 周三 18:32]--[2017-10-25 周三 18:33] =>  0:01
:END:
                         Added: [2017-10-25 周三 18:32]
                         
PIC:记忆时候需要考虑三个组成部分，一purpose二interesting三curiosity也就是你要对你的记忆的目的有一个理性的认识，
进行理性的思考，才能明白其重要性，才能让你持续性工作(理性和专注)，这个过程还得有趣，这样能够保持你的好奇心

当你能跟别人讲的清楚的时候，事先你的记忆也肯定是完全清楚的

好奇心和童心挺像，也就是保持空杯状态

目标写在纸上，量化并且场景化，会让你理性和专注* Quick notes
** emacs highlight [#B]                                              :@F708:
                         Added: [2017-10-09 周一 15:07]
                         作者：BigBoss

(global-hi-lock-mode 1) ;开启全局 hi lock 模式
;避免每次开启 hi lock mode 时询问是否需要高亮指定表达式
(setq hi-lock-file-patterns-policy #'(lambda (dummy) t)) 
; 各种 face 的定义
(defface phone-number-lock-face '((t (:foreground "FF0000"))) t)
(defface language-lock-face '((t (:foreground "00FF00"))) t)
(defface emacs-vim-lock-face '((t (:foreground "9900FF"))) t)

; 利用 highlight-regexp 高亮指定的正则表达式
(defun bigboss-highlight ()
  (interactive)
  (highlight-regexp "0[0-9]\\{2\\}-[0-9]\\{8\\}" 'phone-number-lock-face)
  (highlight-regexp "Lisp\\|Scheme" 'language-lock-face)
  (highlight-regexp "神之编辑器\\|编辑器之神" 'emacs-vim-lock-face)


)

; org mode 中开启高亮
(add-hook 'org-mode-hook 'bigboss-highlight)

https://www.zhihu.com/question/28830039?sort=created
** latex author [#B]                                                 :@work:
                         Added: [2017-10-09 周一 21:41]
                          LaTeX 的作者 Leslie Lamport 

本论文全篇使用Emacs25.3进行文字编辑，Tex Live 2013进行排版设计，git2.13进行版本控制
org——mode进行进度管理。因此要感谢Emacs的发明者Richard Stallman;Tex的发明者Donald Knuth;
git的发明者Linus Torvalds, latex的作者Lesile Lamport;以及Org-mode的发明者carsten Dominik.
** schedule zone [#B]                                                :@work:
                         Added: [2017-10-09 周一 21:44]
                         精确到时间是可以的，时间区间都可以。 格式是：
SCHEDULED: <2015-04-04 Sat 09:00-12:00 ++1d>
这样。上面这句的意思是从4-4日开始， 每天早上的9-12点规划干某件事情。

至于提醒功能， 可以试试org-notify， 不过这个我自己没有用过， 所以不好回答你。
** shift+l [#B]                                                      :@work:
                         Added: [2017-10-09 周一 21:49]
             
你好～想问一下第一张图里面的每个Day下的时间是怎么显示的，
我用C-c C-s 和C-c C-d设置了时间，但是在界面里面却没有显示，我现在用的是emacs25.1。

在 org-agenda 里面按 Shift-l 就可以啦
** add clock summary [#B]                                            :@work:
                         Added: [2017-10-09 周一 22:14]
                         
如何在一个org文件创建clock summary
C-c C-x C-r

** org blog jekyll [#B]                                              :@work:
                         Added: [2017-10-09 周一 22:16]
                         
org-mode可以直接拿来写blog， 这不是什么新鲜事了。  不过最近发现几个项目， 可以方便地从org 输出到jekyll支持的格式。
对于喜欢jekyll，但更喜欢org-mode的同学是个好的解决方案。  当然也有直接从org-mode生成静态网页的。


https://github.com/noinil/prelude/blob/master/personal/noinil.el
https://github.com/noinil/prelude/blob/75d41be0c5da3383cde1bd073c2aa5a9f4b7d792/personal/noinil.el#L397
** emacs 看电影 [#B]                                                 :@F708:
                         Added: [2017-10-09 周一 22:46]
                         用Emacs看电影

大多数人用emacs听歌，我却喜欢用emacs看电影。用 EMMS 和 mplayer 结合，看电影真是太方便了。

不要从源里安装EMMS，它可能给你安装别的播放器，没必要，我们有 mplayer 足够了。从 EMMS 的主页下载，然后编译安装 EMMS 。

然后在 .emacs 中加入如下的配置：
1
2
3
4
5
6
7
8
9
10
11
12
	
(require 'emms-setup)
(emms-standard)
(setq emms-player-list '(emms-player-mplayer) emms-player-mplayer-command-name "mplayer" emms-player-mplayer-parameters '("-slave"))
(setq emms-repeat-playlist nil emms-source-file-default-directory "~/音乐/" emms-lyrics-dir "~/音乐/" emms-lyrics-coding-system nil emms-playlist-buffer-name "*EMMS*")
(global-set-key (kbd "C-c e g") 'emms-play-directory)
(global-set-key (kbd "C-c e d") 'emms-play-dired)
(global-set-key (kbd "C-c e v") 'emms-playlist-mode-go)
(global-set-key (kbd "C-c e x") 'emms-start)
(global-set-key (kbd "C-c e SPC") 'emms-pause)
(global-set-key (kbd "C-c e s") 'emms-stop)
(global-set-key (kbd "C-c e n") 'emms-next)
(global-set-key (kbd "C-c e p") 'emms-previous)

我的emms設置比較簡單，我只是通過它調用mplayer聽歌看電影，不需要看歌詞等額外的功能。我要说的是用 EMMS + mplayer + Dired 可以非常方便地看碟。

通過 Dired 打開電影目錄，比如其中有一個文件夾 辛德勒名單 ，裏面有4 個媒體文件：辛德勒名單CD1.avi、辛德勒名單CD2.avi、辛德勒名單CD3.avi、辛德勒名單CD4.avi。我只需要將光標停在 辛德勒名單 文件夾上，按 C-c e d ，調用 emms-play-dired 函數，則會自動建立播放列表，mplayer 按順序播放這4個文件。

比如有一個電視劇的文件夾 手機 ，裏面共有 36 集，我今天想看 10-12集，用 Dired 進入 手機 文件夾，用 m 在 10-12 集上做標記，然後按 C-c e d ，mplayer 就會順次播放 10-12集。
** emacs多标签 [#B]                                                  :@F708:
                         Added: [2017-10-10 周二 00:41]
                         你的Emacs多标签是用的什么呢？
tabbar-ruler
** win [#B]                                                          :@work:
                         Added: [2017-10-10 周二 01:03]
                         
想在竞赛中获胜， 关键就是要挑自己最在行的项目啊！
所以结论是， 跟他们比笨， 比懒， 比穷。
恭喜你完胜。
** java syscall [#B]                                                 :@F708:
                         Added: [2017-10-10 周二 10:58]
                         
语法糖+syscal
设计的好渐进式发张 即使单进程 照样锤爆
socket 也就是 syscall的问题
和多线程 多进程 协程一样

1:技术是设计的基础，有了技术然后运用技术就能设计出好的产品
2:答：没有设计的产品技术再牛逼也没用，设计才是有技术含量的
技术都是垃圾
** 学习 pattern for life [#B]                                         :NOTE:mm
- State "学习"       from              [2017-10-12 周四 09:55]
                         Added: [2017-10-10 周二 14:00]
                       
在面向对象编程的世界中，我们大量听到"模式"（pattern）这个词，
我觉得那些"模式"就是现实中的因素（c），也就是人肉编译器。
 当我在自己的程序中，发现用到了模式，我觉得这就表明某个地方出错了。
程序的形式，应该仅仅反映它所要解决的问题。代码中其他任何外加的形式，
都是一个信号，（至少对我来说）表明我对问题的抽象还不够深，
也经常提醒我，自己正在手工完成的事情，本应该写代码，通过宏的扩展自动实现。
** blog idea [#B]                                                    :@F708:
                         Added: [2017-10-10 周二 14:02]
                         
当然 blog 还有一个好处就是在把自己的想法表达给大家, 
大家能够听懂的知识才是自己的(有些知识并不是大家都能听懂,有些知识hard to 
understand, hard to use,总是有简单和复杂才能构成真实的世界，都简单的话
那就肯定不真实，这样想也能拓宽你的知识面、认识面)
http://www.woola.net/me
** 产学研 [#B]                                                       :@work:
                         Added: [2017-10-11 周三 11:19]
                         
学校忙着发论文，评职称。私企忙着签合同赚钱。
国企忙着完成资金计划，形象工程。这三者之间有一个共同的利益纽带，是钱。而不是科学。
** RSS Feed [#B]                                                     :@F708:
                         Added: [2017-10-11 周三 22:19]
                         
Use ‘G R’ in the group buffer to create a new group for the feed. When asked, paste the URL to the XML or RDF file 
(I usually paste the URL to the RSS 1.0 feed when given the choice). (You must use G R only when the pointer is not 
on any other group, else it triggers group rename. 
An empty line in the group buffer should work fine.)

The ‘G R’ method does not work for me on gnus 5.10.8, for instance when tried with the url below it says “no such
 newsgroup nnrss:EmacsWiki”. What works for me is hitting ‘G m’ then typing a group name, and specifying nnrss as 
the backend, this creates a group, when entering the group for the first time it prompts for a url.
** fortran+c混编 [#B]                                             :PERSONAL:
:LOGBOOK:
CLOCK: [2017-10-14 周六 22:24]--[2017-10-14 周六 22:25] =>  0:01
:END:
                         Added: [2017-10-12 周四 21:31]
                         
你肯定是没用 ISO_C_binding
现在有了规范的混编方法，一切都简单而优

** logical sequence introduction [#B]                                :@work:
:LOGBOOK:
CLOCK: [2017-10-29 周日 22:06]--[2017-10-29 周日 22:15] =>  0:09
:END:
                         Added: [2017-10-29 周日 22:05]
                         

Before we look at the primary collection types individually, we'll 
discuss the things they have in common. For example, you may have 
heard of clojure's sequence abstraction(都是基于sequence)---all the
persistent collection use it(all :keyword, they :keyword , collective
nouns and abjectives), so we'll examine that as well as some algorithmic
complexity concepts we'll refer to throughout the chapter.


Before....individually ... in common....

is very important. 一方面可以体现出你的逻辑的完整性，另一方面体现你的专业性
同时也可以让你把握重要性，这部分内容只是描述性部分，充当点缀，不是特别核心的地方
相当于引言部分，核心的在不同的地方。


如果你第一次碰到该句话，就可以当作是一个全面性的了解
所以他也是挺重要的
** clojure interop with java [#B]                                    :@work:
:LOGBOOK:
CLOCK: [2017-10-29 周日 22:31]--[2017-10-29 周日 22:31] =>  0:00
:END:
                         Added: [2017-10-29 周日 22:31]
                         

Handling Interop with Java

When a new language comes into being, it faces the library problem. That is, to be useful in everyday situations, 
a language needs to do all the things that current dominant languages do. These current dominant languages have a 
full array of libraries that support things like parsing JSON and logging.

Clojure solved this new language library problem by running on the JVM and having interoperability with Java
 classes. When you use Clojure, you can use Java classes and Java libraries. Clojure builds on the strength 
of the production-hardened and tested JVM and existing Java libraries. In fact, many of the popular Clojure
 libraries in use today utilize Java libraries as fundamental building blocks. We are going to cover the most
 common areas that you will encounter: how to import Java libraries/classes, how to create new instances of 
them, and how to interact with their methods.
** matlab coding style [#B]                                          :@F708:
:LOGBOOK:
CLOCK: [2017-10-30 周一 20:57]--[2017-10-30 周一 20:57] =>  0:00
:END:
                         Added: [2017-10-30 周一 20:57]
                         
MATLAB Coding Style

This document suggests a MATLAB coding style. This file is directed to those who code with me in the lab, but might serve for everyone out there.
Coding style

    No whitespace at the end of the line.
    Use Unix style line breaks (LF only).
    Keep line lenghts under 80 characters.
    Use 4 spaces to indent code. Add indentation for each logic level but the function operator:

function a = ackermann(m, n)
% Computes the Ackermann function.
%
if m == 0
    a = n+1;
elseif and(m > 0, n == 0)
    a = ackermann(m-1, 1);
else
    a = ackermann(m-1, ackermann(m, n-1));
end

    For while loops, the counter variable must be declared just before the while keyword:

n = 0;
while n <= 10
    disp(n);
    n = n+10;
end

    If a line is not enough to write the whole statement, break it into meaningful places, like after an operator or separating a line for each function argument:

pyt = sqrt(x^2 + ...
           y^2);
set(handles.edit, ...
    'String', ...
    sprintf('This is worth %.2f$', ...
            pyt));

Keep LISP style indentation in this case for better legibility. Sometimes, it might be a good idea too to break the line before a mathematical operator, to give a more meaningful sense to your code:

result = viscosity ...
       + shear ...
       - (acceleration * mass);

    Name variables and functions using camelCase, as it is Java after all.
    Name constants using UPPERCASE_SEPARATED_BY_UNDERSCORES.
    Always add a space near the equals sign.
    Add spaces after and before brackets in case they define an array or a cell. This space is not needed when accessing data, calling a function or anything like that:

% defining cells or arrays:
emptyCell = { };
someNumbers = [ 1 1 2 3 5 8 13 42 ];

% function call:
someNumbers(5);
someTrouble = ackermann(4, 2);

% accessing data:
emptyCell{end+1} = 19;

    Add spaces between expressions to make them more readable in case they are too long or full of text:

% expressions that needs space for readability:
result = sqrt(x1^2 + y1^2) + sqrt(x2^2 + y2^2) + sqrt(x3^2 + y3^2);
force = mass * acceleration;

% expressions that does not need space for readability:
z = i+1;
f = m*a;

    Your code is mostly like a text, with sentences are paragraphs. Therefore it is a good idea to visually separate concerns within your code with empty lines so new-comers know these concerns. Sometimes, this separations of paragraphs is more useful than documentation itself.

General practices

    Write documentation before writing code. Write documentation before writing code. Write documentation before writing code.
    State your functions' inputs and outputs when documenting it, specially the data types.
    Whenever possible, try to use MATLAB's own math functions. And try to make your own functions comply with their functions. This will make your script a lot more faster and readable.
    Make every function return something unless it is a procedure. 'What does it mean?', you might ask. Ask why for MATLAB and it will answer for you. Actually not. Procedures here can be understand as a series of transformations and steps to achieve a goal, while a function is the transformation itself. A procedure's goal is to cause a side-effect on your system, and this side-effect must be well documented and defined. A function's goal is to create another variable based on other variable's state. This distinction will make your programs less confusing to outsiders, even if they do not know it is there; specially when there are graphical user interfaces (GUIs for short) involved. For example: when you a press a button, it will usually cause a side-effect somewhere, like saving some data to a file or change something else on your GUI. This can be done by performing a procedure, creating and updating variables based on the system's current state. This distinction is subtle but turns everything clearer with practice. Seriously.

Module organization

Regardless of language, we can define a module as a collection of code that tries to solve one problem. This problem can be broad or not, but the idea is to encapsulate this problem into small pieces so the user does not have to think about what is inside. With that in mind, there are some precautions that are considered good taste:

    A MATLAB module is a folder containing functions. So try to keep all your code into one folder. Each file must contain one function that solves one problem inside this bigger problem. If this function needs a helper function, really specific to that domain, then it can be appended to this same file; the outside scripts will not see this helper function. Unless it is desired that it appears somewhere else or it is used repeatedly, this helper should not have a script file for its own.
    Whenever possible, try to solve your problem using only one script file. Most solutions should be considered just another procedure to be included in someone else's code. This is not always the case, since some problems actually need user interfaces and the whatnot, but it can be really nice to just incorporate a single file to the codebase instead of a whole system.

One issue that I have come accross during this time working with this language is that there is considerable namespace pollution given MATLAB does not have any mechanisms to deal with it. Therefore some care is desired when work with them:

    Unless the given module is always used, do not incorporate it directly to MATLAB. Instead, for each script, run the addpath function with the module path. This will keep the current namespace organized. The same applies to the Java classpath.
    One thing to pay attention is that MATLAB does not add nested modules when a folder is inserted to its path. Therefore it might be a good idea to write a function to add the modules whithin for better incorporation, unless you've got somethign to hide from everyone else.
** 流动分离 [#B]                                                     :@work:
:LOGBOOK:
CLOCK: [2017-11-01 周三 14:22]--[2017-11-01 周三 16:43] =>  2:21
:END:
                         Added: [2017-11-01 周三 14:21]
                         

风力机时常处于变风速的流动中，当来流风速接近或超过设计风速时，在叶片的根部或大部分叶展范围都有可能发生流动分离。发生流动分离后，分离流的湍流强度大大增加，引起气动损失迅速增加。同时，流动分离区导致压力平台，减小了内叶展甚至中叶展位置翼型的升力，增加了翼型的阻力。通过在叶片表面加装涡发生器，可以有效控制流动分离，提高翼型升力，降低翼型阻力，从而提高叶片风能吸收效率。
** 三维旋转效应和流动分离 [#B]                                       :@work:
:LOGBOOK:
CLOCK: [2017-11-01 周三 18:20]--[2017-11-02 周四 00:55] =>  6:35
CLOCK: [2017-11-01 周三 17:17]--[2017-11-01 周三 18:19] =>  1:02
:END:
                         Added: [2017-11-01 周三 17:17]
                         
[风力机叶片表面压力的计算与外场测试分析][李仁年] 外场试验表明，叶片表面压力分布
特征沿展向出现较大的差异性，主要原因是在外场多变环境下，高速旋转的风力机叶片存在
较强的三维旋转效应，且三维旋转效应越靠近叶片根部越明显。

当风速超过额定风速后，沿叶展方向的翼型截面会发生动态失速现象，尾涡的形成
和脱落涡将对叶片表面压力分布产生较大影响，产生剧烈的压力波动，致使叶片表面
压力与计算值出现较大差异
** whatis habits [#B]                                                :@work:
:LOGBOOK:
CLOCK: [2017-11-02 周四 20:59]--[2017-11-02 周四 21:00] =>  0:01
:END:
                         Added: [2017-11-02 周四 20:59]
                         
5.3.3 Tracking your habits

Org has the ability to track the consistency of a special category of TODOs, called “habits”. A habit has the following properties:

    You have enabled the habits module by customizing org-modules.
    The habit is a TODO item, with a TODO keyword representing an open state.
    The property STYLE is set to the value habit.
    The TODO has a scheduled date, usually with a .+ style repeat interval. A ++ style may be appropriate for habits with time constraints, e.g., must be done on weekends, or a + style for an unusual habit that can have a backlog, e.g., weekly reports.
    The TODO may also have minimum and maximum ranges specified by using the syntax ‘.+2d/3d’, which says that you want to do the task at least every three days, but at most every two days.
    You must also have state logging for the DONE state enabled (see Tracking TODO state changes), in order for historical data to be represented in the consistency graph. If it is not enabled it is not an error, but the consistency graphs will be largely meaningless. 

To give you an idea of what the above rules look like in action, here's an actual habit with some history:
{{{
     ** TODO Shave
        SCHEDULED: <2009-10-17 Sat .+2d/4d>
        - State "DONE"       from "TODO"       [2009-10-15 Thu]
        - State "DONE"       from "TODO"       [2009-10-12 Mon]
        - State "DONE"       from "TODO"       [2009-10-10 Sat]
        - State "DONE"       from "TODO"       [2009-10-04 Sun]
        - State "DONE"       from "TODO"       [2009-10-02 Fri]
        - State "DONE"       from "TODO"       [2009-09-29 Tue]
        - State "DONE"       from "TODO"       [2009-09-25 Fri]
        - State "DONE"       from "TODO"       [2009-09-19 Sat]
        - State "DONE"       from "TODO"       [2009-09-16 Wed]
        - State "DONE"       from "TODO"       [2009-09-12 Sat]
        :PROPERTIES:
        :STYLE:    habit
        :LAST_REPEAT: [2009-10-19 Mon 00:36]
        :END:
}}}
What this habit says is: I want to shave at most every 2 days (given by the SCHEDULED date and repeat interval) and
 at least every 4 days. If today is the 15th, then the habit first appears in the agenda on Oct 17, after the minimum 
of 2 days has elapsed, and will appear overdue on Oct 19, after four days have elapsed.

What's really useful about habits is that they are displayed along with a consistency graph, to show how consistent
 you've been at getting that task done in the past. This graph shows every day that the task was done over the past 
three weeks, with colors for each day. The colors used are:

Blue
    If the task wasn't to be done yet on that day.
Green
    If the task could have been done on that day.
Yellow
    If the task was going to be overdue the next day.
Red
    If the task was overdue on that day. 

In addition to coloring each day, the day is also marked with an asterisk if the task was actually done that day,
 and an exclamation mark to show where the current day falls in the graph.

There are several configuration variables that can be used to change the way habits are displayed in the agenda.

org-habit-graph-column
    The buffer column at which the consistency graph should be drawn. This will overwrite any text in that column,
 so it is a good idea to keep your habits' titles brief and to the point.
org-habit-preceding-days
    The amount of history, in days before today, to appear in consistency graphs.
org-habit-following-days
    The number of days after today that will appear in consistency graphs.
org-habit-show-habits-only-for-today
    If non-nil, only show habits in today's agenda view. This is set to true by default. 

Lastly, pressing K in the agenda buffer will cause habits to temporarily be disabled and they won't appear at all. 
Press K again to bring them back. They are also subject to tag filtering, 
if you have habits which should only be done in certain contexts, for example. 
https://www.gnu.org/software/emacs/manual/html_mono/org.html#Tracking-your-habits
** tags important [#B]                                               :@work:
:LOGBOOK:
CLOCK: [2017-11-02 周四 21:04]--[2017-11-02 周四 21:04] =>  0:00
:END:
                         Added: [2017-11-02 周四 21:04]
                         
An excellent way to implement labels and contexts for cross-correlating information is to assign tags to headlines.
 Org mode has extensive support for tags.

Every headline can contain a list of tags; they occur at the end of the headline. Tags are normal words containing 
letters, numbers, ‘_’, and ‘@’. Tags must be preceded and followed by a single colon, e.g., ‘:work:’. Several tags
 can be specified, as in ‘:work:urgent:’. Tags will by default be in bold face with the same color as the headline. 
You may specify special faces for 
specific tags using the option org-tag-faces, in much the same way as you can for TODO keywords (see Faces for TODO keywords). 
** Dynamic Stall [#B]                                               :@NCEPU:
:LOGBOOK:
CLOCK: [2018-07-25 周三 10:50]--[2018-07-25 周三 10:55] =>  0:05
:END:
                         Added: [2018-07-25 周三 10:50]
                         
                         
Yaw misalignment introduces the unsteady load , dynamic stall is very important
 because it causes the larger load than static 
 

Yaw misaligment introduces unsteady blade load(产生位置也有了). The occurentce for dynamic stall
is of particular(采用of形式来表达) in this respect, since it can yield(产生)significantly (极大地)
higher aerodynamic blade forces(又加上了balde） than for static stall(加上for， 然后在static后面
再加上stall)

spanwise and temporal extend of the dyanmic stall region 

进一步参考 [Wind turbine aerodynamic in yaw.pdf P153]


记得在cygwin安装tree
#+BEGIN_SRC bash :dir "I:\\ScienceBase.Attachments\\data missing estimation\\"
  find
#+END_SRC


#+BEGIN_SRC bash :dir "I:\\ScienceBase.Attachments\\data missing estimation\\"
  perl hello.pl 
#+END_SRC


#+RESULTS:
** NoteExpress标记 [#B]                                             :@NCEPU:
:LOGBOOK:
CLOCK: [2018-08-04 周六 09:33]--[2018-08-04 周六 09:44] =>  0:11
:END:
                         Added: [2018-08-04 周六 09:32]
                         

标记星级+优先级(刚开始是一级，如果觉得好变成2级，再看一遍觉得特别不错，变成三级..)
** 搜索引擎出现的必然 [#B]                                          :@NCEPU:
:LOGBOOK:
CLOCK: [2018-08-04 周六 09:44]--[2018-08-04 周六 09:45] =>  0:01
:END:
                         Added: [2018-08-04 周六 09:44]
                         
从只言片语到书册，再到图书馆以及搜索引擎
https://www.baidu.com/s?wd=how%20search%20works&rsv_spt=1&rsv_iqid=0x9c499bc9000313b6&issp=1&f=8&rsv_bp=0&rsv_idx=2&ie=utf-8&tn=baiduhome_pg&rsv_enter=1&rsv_sug3=17&rsv_sug1=7&rsv_sug7=100&rsv_sug2=0&inputT=4271&rsv_sug4=4272

1. 爬虫抓取信息(following links ,inside links  connected into thousands and millions information web)，按照高质量网站优先原则
2. 进行index
3. 通过算法，better understand what you mean理解你的输入内容，进行搜索 base on the relevent clues, 
4. 不断过滤掉垃圾网页（site & page quality高质量网站显示在前! 

https://www.google.com/intl/bn/insidesearch/howsearchworks/thestory/
Jake Hubert, Google Product Manager, said in a blog, “Here you can follow the entire life of a search query,
 from the web, to crawling and indexing(1), to algorithmic ranking(2) and serving(3), to fighting webspam(去掉垃圾信息).”
 

 
1. keyword
2. rank and sort(整理)
3. qualitiy


级别1： 只会输入单词的
级别2： 关键词组合 基本逻辑关系(and：空格表示 or not)  高级检索(site:  ftp:   filetype:pdf)
句子的话涉及拆词问题(关键词组合，跟浏览器的搜商有关)，  + 强制添加   -减号强制剔除
级别3： 高校检索 黑客级别

各个搜搜引擎差异在于专业性知识收集不同、展示界面不同

乔纳森-弗莱彻：被遗忘的搜索引擎之父
腾讯科技[微博]瑞雪2013年09月05日02:47我要分享
[导读]20年前，弗莱彻发明了全世界第一个能进行网络搜索的搜索引擎。

乔纳森-弗莱彻：被遗忘的搜索引擎之父

弗莱彻（中）与SIGIR大会的其他与会者在一起（腾讯科技配图）

腾讯科技 瑞雪 9月5日编译

在谷歌(微博)庆祝其15周年诞辰之际，这家网络巨头已经成为信息检索的代名词。

但是，如果你在谷歌搜索引擎中输入乔纳森·弗莱彻（Jonathon Fletcher）的名字，那么在马上得出的搜索结果中不会找到什么线索指向他曾在万维网发展的过程中所扮演的角色。当然，也不会有任何信息能表明他作为现代搜索引擎之父的身份。

但在20年以前，正是弗莱彻在苏格兰斯特灵大学（University of Stirling）的一个电脑实验室中发明了全世界第一个能进行网络搜索的搜索引擎，也正是他发明的这种技术为谷歌、必应（Bing）、雅虎和今天网络上的所有大型搜索工具提供了支持。

解决网络搜索问题

在1993年时，网络正处于刚刚开始发展的婴儿期。在那时，第一个拥有类似于今天我们使用的界面的流行浏览器Mosaic刚刚发布，网页的总数量还只是以千为单位来进行计算而已。

尽管当时网络已经诞生，但如何在网络上找到内容的问题尚未得到解决。Mosaic拥有一个名为“What's New”的页面，能在新网站被创立时检索到这些网站。但问题在于，如果想要Mosaic的开发者能够知道一个新网站的诞生，那么其创立者就必须写信给美国伊利诺伊大学香槟分校（University of Illinois Urbana-Champaign）的国家超级计算应用中心（NCSA），也就是Mosaic浏览器团队的基地。

在那时，弗莱彻是斯特灵大学一名颇有前途的研究生，而且已经被推荐到格拉斯哥大学（University of Glasgow）攻读博士学位。但是，格拉斯哥大学的资金链在弗莱彻还没能到这所大学以前就已断裂，这让他变得无所事事。

“在突然之间，我变得非常渴望找到一种收入来源。”弗莱彻回忆道。“因此我回到了原来的大学，找到了一个为技术部门工作的岗位。”

正是在这个工作岗位上，弗莱彻第一次与万维网和Mosaic的“What's New”页面邂逅。

更好的方法

在为斯特灵大学建设一个网络服务器的过程中，弗莱彻意识到，“What's New”页面存在根本上的缺陷。由于网站是以人工方式被添加到这个网页的列表中的缘故，没有什么东西能被用来追踪网站内容的变化。其结果是，许多链接很快就会变得过期或是被错误标记。

“如果你想要看看有什么东西发生了变化，那么就不得不回过头去查看。”弗莱彻在谈及Mosaic的链接时说道。“抱着必须推出一种更好的方法的念头，拥有计算机科学学位的我决定要编写一些东西来改变这种情况。”

弗莱彻所说的“一些东西”就是全世界的第一个“网络爬虫”（web crawler）。弗莱彻把自己的这种发明称作“JumpStation”，他建立起了一个页面索引，能通过“网络爬虫”来对页面进行搜索，这基本上来说是一种自动化的处理程序，能对被其发现的每个网站页面进行访问和索引。这种自动化处理的程序会一直继续下去，直到“网络爬虫”再也找不到东西可以访问时为止。

在十年以后，也就是1993年12月21日，JumpStation就再也找不到可以访问的东西，结果是将2.5万个页面编入索引。而在今天，谷歌已经编入索引的页面数量已经超过了1万亿个。

乔纳森-弗莱彻：被遗忘的搜索引擎之父

JumpStatio诞生几个月以前的“What's New”页面（腾讯科技配图）

搜索的诞生

弗莱彻很快就为这个索引开发出了一种易于导航的搜索工具，将自己的网站嵌入了Mosaic的“What's New”页面，这标志着全世界第一个现代搜索引擎开始运作。

“我会说，他是网络搜索引擎之父。”墨尔本皇家理工大学（Royal Melbourne Instituteof Technology）的马克·桑德森（Mark Sanderson）教授说道，他专门负责研究信息检索的历史。“（在弗莱彻发明第一个网络搜索引擎之前的）很长一段时间里，很明显一直都有计算机在从事搜索工作；在网络诞生以前，当然也已经有搜索引擎存在。然而，是弗莱彻第一个创造了一种拥有现代搜索引擎所有组成部分的搜索引擎。”

但在今天，谷歌的两名联合创始人塞吉·布林（Sergey Brin）和拉里·佩奇（Larry Page）都已经成为家喻户晓的名人，而目前居住在中国香港的弗莱彻却几乎没有因为他为互联网进化作出的贡献而为人所知。

之所以会出现这种情况，或许与他的项目最终被放弃有关。随着JumpStation的成长，这个项目需要的投资越来越大，而这种投资却是斯特灵大学所不愿提供的。“当时JumpStation是在一个共享服务器上运行的。”弗莱彻解释道。“那时没有很大的磁盘空间，而且当时的磁盘很小，价格也很昂贵。”

空间控制

到1994年6月份，JumpStation已经对27.5万个页面进行了索引。空间方面的限制迫使弗莱彻仅对网页的标题进行索引，而不是对网页的全部内容进行索引；但即使是在作出了这种妥协以后，JumpStation也仍旧开始面临着过载的困境。

弗莱彻也同样已不堪重负。“那并非我的本职工作。”他说道。“那时我的工作职责是维持学生实验室的正常运作，并从事一些系统管理和技术方面的杂活儿。”

在当时，弗莱彻得到了一个到东京工作的机会。对他来说，这个工作机会的吸引力大到令人难以抗拒，而斯特灵大学也几乎没有尝试做些什么来挽留他或是挽留JumpStation。

“很明显，在尝试说服他们相信这个项目很有潜力的问题上，我做得很不成功。”弗莱彻说道。“在当时，我做了自己认为是正确的事情（到日本去工作）。但在过去20年时间里，总有那么些时候我会回首这段往事。”

斯特灵大学计算机科学及数学系主任莱斯利·史密斯（Leslie Smith）教授还记得弗莱彻，他承认JumpStation最终“被证明是领先于时代的”，并在接受BBC采访时表示：“斯特灵大学的同仁们都为他能因自己取得的成就而为人所知感到高兴。”

未来展望

尽管弗莱彻对不得不放弃JumpStation项目而感到失望，但他的这种先驱技术在后来却成为了所有网络搜索引擎的基础。

“在1993年时，网络社区的规模非常小。”桑德森教授说道。“在当时，在网上做任何事情的人都会知道JumpStation。”他还补充道：“到1994年年中前后，网络搜索引擎将变得非常重要这件事情已经开始变得明显。谷歌直到1998年才出现，而弗莱彻在1993年就已经做了这件事情。”

在几个星期以前于爱尔兰首都都柏林召开的SIGIR（国际计算机协会主办的国际信息检索大会）上，弗莱彻由于他在网络搜索引擎方面作出的成就而获得了一些知名度。在当时，他曾跟来自于微软、雅虎和谷歌的与会代表进行过小组讨论。但在弗莱彻的言谈中，他所谈论的并非自己以往的成就，而是对未来作出了展望。

“在我看来，网络不会永远存在。”弗莱彻说道。“但是，找到信息的问题则将永远存在，因为对内容进行搜索并找到信息的愿望是独立于媒介以外的。”

对于追随弗莱彻其后建立起网络搜索引擎的人们来说，当前的这种媒介已经让他们赚到了大笔的钞票。但是，弗莱彻这位出生于英格兰自治市斯卡伯勒（Scarborough）的先驱者并不对此感到遗憾。“我的父母以我为骄傲，我的妻子和孩子也是如此。对我来说，这才是无价之宝，所以我感到非常幸福。”
** 最喜欢的一段perl代码 [#B]                                        :@NCEPU:
** 
                         Added: [2018-08-05 周日 03:47]
                         

#+BEGIN_SRC perl

#!/usr/bin/env perl
#===============================================================================
#
#         FILE: accessPeople.pl
#
#        USAGE: ./accessPeople.pl
#
#  DESCRIPTION:
#
#      OPTIONS: ---
# REQUIREMENTS: ---
#         BUGS: ---
#        NOTES: ---
#       AUTHOR: YOUR NAME (),
# ORGANIZATION:
#      VERSION: 1.0
#      CREATED: 2017/12/10 22:03:34
#     REVISION: ---
#===============================================================================

use strict;
use warnings;
use utf8;

my @records;
my @cols = ( 's_name', 'f_name', 'job' );

my $FILE_file_name = 'people.dat';    # output file name

open my $FILE, '<', $FILE_file_name
    or die "$0 : failed to open  output file '$FILE_file_name' : $!\n";
while (<$FILE>) {
    chomp;
    my %rec;
    @rec{@cols} = split /,/;
    push @records, \%rec;
}

close $FILE
    or warn "$0 : failed to close output file '$FILE_file_name' : $!\n";

foreach (@records) {
    print "$_->{f_name} ", "$_->{s_name} ", "is a $_->{job}\n";
}

#+END_SRC





#+BEGIN_EXAMPLE people.dat
Jones, Martha, UNIT
Harkness,JACK,Torchwood
Smith,Sarah Jane, Journalist
#+END_EXAMPLE
** 常用perl解析中文 [#B]                                            :@NCEPU:
                         Added: [2018-08-05 周日 03:55]
                         


#+BEGIN_SRC perl

# 统一形式  '*(<|>|>>):encoding\(\w+\)'

open my( $read_fh), '<:encoding(UTF-8)', $filename;
open my( $write_fh), '>:encoding(UTF-8)', $filename;
open my( $append_fh), '>>:encoding(UTF-8)', $filename;
#+END_SRC


#+BEGIN_SRC perl
#!/usr/bin/env perl
#===============================================================================
#
#         FILE: analysisFeiji.pl
#
#        USAGE: ./analysisFeiji.pl  
#
#  DESCRIPTION: 
#
#      OPTIONS: ---
# REQUIREMENTS: ---
#         BUGS: ---
#        NOTES: ---
#       AUTHOR: Ye Zhao Liang (YZL), yezhaoliang@ncepu.edu.cn
# ORGANIZATION: NCEPU
#      VERSION: 1.0
#      CREATED: 2017/12/19 21:46:42
#     REVISION: ---
#===============================================================================

use strict;
use warnings;
use utf8;

binmode(STDIN,":encoding(gb2312)");
binmode(STDOUT,":encoding(gb2312)");

# while ( <> ) {
#     chomp;
#     print $_,"\n";
#     last if $_ =~ m/q/xm;
# }

open(FEIJI,"feiji.txt") or die "can't open the file \n";
my $car ="尾翼";

binmode(FEIJI,":encoding(gb2312)");
# binmode( STDIN,  ':encoding(gbk2312)' );
#binmode( FEIJI,  ':encoding(utf8)' );
#binmode( STDOUT, ':encoding(gbk2312)' );   
#binmode( STDERR, ':encoding(gbk2312)' ); 
#while( my $line = <FEIJI>){
#my $re = Encode::decode('GB2312','汽车');
my $count=1;
while( <FEIJI>){
    #print "$_ \n" ;
    #     print "$_ \n" if $_ =~ /.*$re.*/;
    #    Encode::_utf8_on($_);
    #    Encode::decode_utf8($_);
    #print "$_\n" ;#if $_ =~ m/$car/xm;
    #print "$count: $_\n" if $_ =~ m/$car/xm;
    #$count +=1;

    s/汽车/风力机/g;
    print;
}

#+END_SRC
** perl正则学习 [#B]                                                  :perl:
                         Added: [2018-08-13 周一 11:38]
                         

                         
perl中有一个tr命令，代表代换，任何的编译器也有着代换的概念（代换就是一一代换吗，
在perl中其实就是一个一个字母进行代换

s///其实是模式代换，tr叫做字母代换，不考虑模式

现在编辑器，vim，emacs等对于多文件搜索(配合上fzf，ag等代码、字符搜索工具）,可以很容易进行

很多编辑器内置了正则表达式引擎，比如vim和emacs的:%s///功能,


*** 反向引用

如果想在s"""运算符的第一部分使用反向引用，使用语法\1 \2等
如果相杂第二部分使用反向引用，使用$1,$2

比如 
#+BEGIN_SRC  perl
$string=~ s"(far)(out)" $2 $1"; ====> 'Out far’

$string=' sample examples'; if($string=~m"(amp..) ex\1") {print "matches!\n";}

#+END_SRC
所以s命令进行匹配的时候是有进行两个隐式的赋值工作(很多人没说好这一点，因为比较细)

比如

#+BEGIN_SRC perl

  $string = ' bballball';
  $string =~ s" (b)\1(a...)\1\2" $1$2";

  #让我们详细地看看这个例子。该例完成匹配，但是原因不是太明显。对这个字符串的匹
  #配有五个步骤：
      1)在圆括号中的第一个b匹配字符串的开头，接着将其存放在\1 和$1 中。
      2)\1 于是匹配字符串中的第二个b，因为与b 相等，而第二个字符碰巧是b。
      3)(a..)匹配字符串all且被存在\2 和$2 中。
      4)\1 匹配下一个b。
      5)因为\2等于all所以匹配下一个且是最后三个字符(all)。
      将他们放到一起就得到正则表达式匹配bballball，或者说是整个字符串。既然$1 等于'
      b'，$2 等于all，则整个表达式：

  $string = ' bballball' ;
  $string =~ s" (b)\1(a..)\1\2" $1$2";
  #(在这个例子中)转换为如下代码：
  $string =~ s" (b)b(all)ball" ball";
  #或者用行话讲，用bballball 替换ball。


  一般第一部分替换比较少一些(第二部分可以直接使用)
#+END_SRC


***  scalars

三种内建的数据结构
1. scalars
2. arrays of scalars(arrays)
3. associates arrays of scalars(hashes)


基于scalars的语法规则！


#my  @words   = $_=~/(\S+)/g; 等效于 #my  @words =  /(\S+)/g; 



*** 零宽断言

从假设出发吧！假设存在那么一个位置！我想找到他的右边单词是。。。就用(?=)
我想找打他的左侧单词就用(?<=)

但是该位置可能不存在， 而匹配词也可能不存在，假设有风险!夹逼须果断！

位置坐落于匹配单词物理上的左侧(?=匹配词) (?!匹配词)  ---或者这样说以当前位置角度出发：如果当前位置的右边存在匹配词
位置坐落于匹配单词物理上的右侧(?<=匹配词) (?<!匹配词)---如果当前位置的左边存在该匹配信息(假设存在这个位置)


#+BEGIN_EXAMPLE
   源字符串：<div>a test</div>

   正则表达式：(?<=<div>)[^<]+(?=</div>)
    这个正则的意义就是匹配<div>和</div>标签之间的内容，而不包括<div>和</div>标签本身。

有个问题，是否领款断言的表达式可以匹配呢
   正则表达式：(?=<div>)[^<]+(?=</div>)
#+END_EXAMPLE\b匹配单词边界

\w匹配[a-zA-Z0-9]  \W匹配非\w
\d匹配[0-9] \D匹配非数字
^匹配行字符串开头  $ 匹配行字符串结尾
\A匹配行头  \Z匹配行尾


#+BEGIN_SRC perl
  print "**********************zero width predicting and backslash g**************************************\n";

  my  $divS= "<div> a test </div>               <div> hello  another test</div>";

  #注意这边不适用//,而使用""来代替，避免和html标签</div>冲突
  #$divS =~ m"(?<=<div>)[^<]+(?=</div>)"xm;
  $divS =~ m"((?<=<div>)[^<]+)(?=</div>)"mx;

  print "THe matched string is $1\n";

  while ( $divS =~ m"((?<=<div>)[^<]+)(?=</div>)"mxg ) {
      print "THe matched string is $1\n";
  }


  ## result
  #**********************zero width predicting and backslash g**************************************
  THe matched string is  a test
  THe matched string is  a test
  THe matched string is  hello  another test
#+END_SRC

注意还有一点，正则表达式\< 和\>匹配单词边界(分别匹配the start position of a word and the end position of a word
还有就是命名捕获也会用尖括号！

由于零宽断言，最终只获得一个位置，我们是否可以获取其匹配的内容？多此一举，直接不使用零宽断言不就ok了！！

零宽断言其实也叫作夹逼定理(洛必达法则，嘚瑟的说出来 luo重音 必(重音)达(达平音）

边界本身也是一个夹逼的过程，答案本身也是夹逼的过程，数值计算也是夹逼的过程！人生也是夹逼的过程！
并行： 分别夹逼的过程!
所以一定得把逼夹紧！

**** 正则命名捕获


#+BEGIN_SRC perl
  print "*********************** named capture*************************************\n";

  ## All named capture string are stored in the associative arrays of scalars(hash) named %+
  # So yuu can use $+{name} to reference the value of the captured term.
  my $str = "jack and rose"; 
  if ($str =~ /(?<first>\S+) (and|or) (?<second>\S+)/) { 
      my ($first, $second) = ($+{first}, $+{second}); 
      print "$first\n$second\n";  # jack, rose 
      print "the current \$1 \$2 \$3 is $1 , $2 , $3\n";
  } 

#+END_SRC

#+BEGIN_EXAMPLE


#########*********************** named capture*************************************
jack
rose
the current $1 $2 $3 is jack , and , rose



#+END_EXAMPLE

**** 不捕获


use ?: to stop capturing the content into $number array!
#+BEGIN_SRC perl
  if ($str =~ /(?<first>\S+) (?:and|or) (?<second>\S+)/) { 
      my ($first, $second) = ($+{first}, $+{second}); 
      print "$first\n$second\n";  # jack, rose 
      print "Now  \$1 \$2 \$3 is $1 , $2 , $3\n";
  } 

#+END_SRC


#+BEGIN_EXAMPLE
#*********************** named capture*************************************
jack
rose
Use of uninitialized value $3 in concatenation (.) or string at testArray2.pl line 118.
Now  $1 $2 $3 is jack , rose ,

#+END_EXAMPLE

所以命名捕获其实是让程序多做事情!


*** 两字字符


跟踪一个人并不简单，至少得10个人，如果只有一个人，那么至少要挡住自己的脸


perl有两种字符单元
1. 元字符(\w \b \a \z ^ $ \1 \2 $1 $2 \< \>  a-zA-Z0-9 \s \S \d \D .   + ? {3,5} -) 特殊意义的字符
2. 基本字符a-z A-Z 0-9（字面值）
   
正则表达式的思维！

要想正确使用正则表达式，清楚地了解目标文本是非常重要的


****  字符组和多选结构的区别

字符组(character set)只是针对单个单词，基本可以算是一门独立的微型语言(例如 对于元字符，他们有自己的规定)

而多选结构(alternative)是"正则表达式语言主体(main regular expression language)"的一部分。
多选结构(alternative)可以包括很多字符，但不能超越括号的界限！

gr[ae]y 和 gr(a|e)y虽然一样，但是理念不一样

'^From|Subject|Date:' 查三种类型的信息

'^(From|Subject|Date):'  查询From或者Subject或者Date开头并以冒号结尾的


竖线的本质就是匹配分割两边的任意一个表达式
也就是说括号通常是和竖线合在一起使用的,也就是限制竖线的作用范围！


一般字符组的效率差些，最好用分支结构!
多选项缺点: 没有像字符组那样排除功能，可以匹配任意长度的文本,相当于一个一个选项!


#+BEGIN_SRC perl
  ([\u4e00-\u9fa5\w])\1+


  ([a-zA-Z0-9]+)\1+  查找重复英文
    
  (\w+)\1+
  (\w+)\s\1+    可以查到the the

#+END_SRC



正则表达式包含多个流派！
弄懂正则表达式的工作原理，才是真正理解的关键

学习正则表达式犹如造车一样，是一种艺术形式，而不是仅仅开车（不需要懂得车运行原理）
在造车之前，必须了解汽车的工作原理。

你有开过车，知道怎么用起来就可以了！但是真想开的好，也不一定得精通车的原理！

1. 开车的经验
2. 开车的历史 详细考察正则表达式的流派的主要内容
3. 正则表达式流派重要引擎
4. 更为复杂内容
5. 设置具体的正则引擎
6. 检查具体的产品和模型！
   

***  华氏转为摄氏度


#+BEGIN_SRC perl
  print "**********************huashi ******************************************\n";

  print "Enter a temperature (e.g., 32F, 100C):\n";
  my  $input= <STDIN>; ## 接收用户一行文本
  chomp($input);


  #if ( $input =~ m/^([-+]?[0-9]+)([CF])$/xm ) {
  #此时 $1 保存 数字     $2保存类型
  if ( $input =~ m/^([-+]?[0-9]+(\.[0-9]*)?)([CF])$/xm ) {
  #此时 $1 保存 数字和小数点数字    $2保存小数点 $3保存类型
     my $InputNum = $1; ## 数据存储
     my  $type = $3;  ## 保证程序清晰易懂

     my  $celsius;
     my  $fahrenheit;

     if ( $type eq "C" ) {
         #输入为摄氏温度
         $celsius = $InputNum;
         $fahrenheit = ($celsius * 9 /5.0) + 32;
     }
     else {
         $fahrenheit = $InputNum;
         $celsius = ($fahrenheit - 32)*5 / 9.0;
     }

     printf "%.2f C is %.2f F \n", $celsius,$fahrenheit;
  }
  else {
      print "Expecting a number followed by \"C\" or \"F\", \n";
      print "So I don't understand \"$input\". \n";
  }

#+END_SRC


改进写法，支持大小写(也许你更喜欢/i,因为它更简洁，类似\s)，支持小数点!
#+BEGIN_SRC perl
  ##if ( $input =~ m/^([-+]?[0-9]+)([CF])$/xm ) {
  #此时 $1 保存 数字     $2保存类型
  #if ( $input =~ m/^([-+]?[0-9]+(\.[0-9]*)?)([CF])$/xm ) {
  #if ( $input =~ m/^([-+]?[0-9]+(\.[0-9]*)?)\s*([cCfF])$/xm ) {
  if ( $input =~ m/^([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$/ixm ) {
  ## /i 不区分大小写
  #此时 $1 保存 数字和小数点数字    $2保存小数点 $3保存类型
     my $InputNum = $1; ## 数据存储
     my  $type = $3;  ## 保证程序清晰易懂

     my  $celsius;
     my  $fahrenheit;

     if ( $type eq "C" || $type eq "c" ) {
    # if ( $type =~ m/c/i) {   #或者这种方式更加简洁些！ 伟大的i    伟大的g

         #输入为摄氏温度
         $celsius = $InputNum;
         $fahrenheit = ($celsius * 9 /5.0) + 32;
     }
     else {
         $fahrenheit = $InputNum;
         $celsius = ($fahrenheit - 32)*5 / 9.0;
     }

     printf "%.2f C is %.2f F \n", $celsius,$fahrenheit;
  }
  else {
      print "Expecting a number followed by \"C\" or \"F\", \n";
      print "So I don't understand \"$input\". \n";
  }

#+END_SRC

***  括号三种用法

1. 限定多选方案的范围比如 gr(a|e)y  竖线的作用范围只能在a和e之间，而如果是gra|ey则变成gra和ey两个表达式
2. 分组，比如(wor)fdf(hel)  分组$1 $2
3. 捕获 。。。 也有不捕获比如(?:...)


*** 反斜杠(反斜线)backslash的四种用法

1. \> \< 构成元字符(不同流程构成了不同对应元字符的定义)
2. \w([a-zA-Z0-9] \W([^a-zA-Z0-9] \d([0-9]) \D([^0-9] \s(所有空白字符:空格符、制表符、换行符、
   回车符, 更方便些) \S \A \Z 和字母结合构成元字符, \b单词边界 \B
3. \\ \( \) 去除某些元字符的意义，保存字符特殊含义
4. \t(字表符) \n \r \l 构成特殊孔子字符
   
*** 斜杠(斜线)slash两种用法
1. 斜线用来标记正则表达式的边界 比如m//  s///也可以用m""  m{}等来代替斜线！
2. /和某些字母结合，充当匹配表达式的拓展功能，比如/i表示不区分大小写，/g表示全局匹配行， /m多行匹配 , /x表示正则表达式
   正则表达式可以写成多行的形式，忽略中间的换行符!


***  破折号两种用法

1. 放在character set第一个位置表示破折号意思
2. 放在character set中间某个位置比如[a-z] 表示到（范围的意思）
3. perl -i 表示直接写进文件, -p表示对目标文件每一行进行查找和替换  perl -p -e -i 's/sysread/read/g' file

类似的意思还比如尖角号

****  尖角号三种用法

1. 放在character set第一个位置表示逻辑非
2. 放在character set其他位置表示尖角字面值意思
3. 放在表达式首位类表征匹配要匹配字符串的首位，对应$为尾位
   
而且一般限定尖角和dollar符号可以加快匹配速度

*** 单词的定义

perl和其他语言一样都把数字、字母、下划线当做单词一部分

单词分界符意思：在此位置一侧是单词(例如数字、字母）另一侧不是(例如行的末尾或者数字后面的空格）
一侧如此这般，另一侧如此那般：(是不是类似顺序环视和逆序环视）


*** 栈式测试操作符


#+BEGIN_SRC perl
  #perl 5.10引入栈式操作

  # 5.10以前写法
  if(-r $file and -w _){
      print "hel..";
  }

  # 5.10以后写法
  use 5.010;
  if(-w -r -d -x -o $file){
      print "My directory is readable ,writable, and executable!\n");
  }

  # 靠近$file的先进性判断

  Learning Perl P238回看可能的误用!
#+END_SRC


*** 尖括号的作用(diamond)

通配符匹配所有当前文件夹下pm结尾可以写为 "*.pm"

perl可以使用 glob "*.pm" 获取所有文件，当然也可以使用<"**.pm">获取


这种运用场景也用于文件读取

也就是说diamond（尖括号）既可以表示文件句柄读取又代表文件名通配操作，那么perl又是如何判断取舍？

因为合理的文件句柄必须是严格意义上的Perl标识符，所以如果满足Perl标识符条件的，就作为文件句柄读取，otherwise,..


#+BEGIN_SRC perl
  my @files = <FRED/*>; ## 文件名 通配符
  my @lines = <FRED>; ##文件句柄
  my @lines = <$fred>; #文件句柄
  my $nane = 'FRED';
  my @files = <$name/*>;  #文件名通配操作


  # 唯一例外

  my $name ='FRED';
  my @lines = <$name>; # $name解析为FRED句柄，当做文件句柄! 不要用间接文件句柄！！！！
#+END_SRC


**** 目录句柄

open     ---> opendir
readline ---> readdir
close    ---> closedir



#+BEGIN_SRC perl
      ## file
        my	$letterfile_file_name = 'someFiles.md';		# input file name

        open  my $letterfile, '<', $letterfile_file_name
            or die  "$0 : failed to open  input file '$letterfile_file_name' : $!\n";

        close  $letterfile
            or warn "$0 : failed to close input file '$letterfile_file_name' : $!\n";


      ## directory
        my	$letterfile_direcotry_name = 'Directory/';		# input file name

        opendir  my $letterfile, '<', $letterfile_direcotry_name
            or die  "$0 : failed to open  input file '$letterfile_direcotry_name' : $!\n";

    while($name = readdir $letterfile_direcotry_name){
        next unless $name=~ /\.pm$/;
  next if $name=~ /^\./;
next if $name eq '.' or $name eq '..';
    }
        closedir  $letterfile
            or warn "$0 : failed to close input file '$letterfile_direcotry_name' : $!\n";

#+END_SRC


****  File::Spec::Functions



#+BEGIN_SRC perl
  #为了让程序健壮和可移植 使用File::Spec::Functions

  use File::Spec::Functions;

  opendir my $somedir,$dirname or die "Cannot open$dirnmame:$!";
  while(my $name = readdir $somedir){

      next if $name =~ /^\./; # 跳过点号开头的文件
      $name =catfile($dirname,$name); #拼合完整路径
      next unless -f $name and -r $name; #如果没有拼合路径，文件测试操作符会在当前目录下查找文件，而不是在$dirname指定目录下。
  }
#+END_SRC


**** 递归访问目录 Fild::Find


File::Find:Rule和File::Finder都是基于File::Find

**** 删除文件unlink

unlink 'slate'; #会把当期目录下的slate文件扔进粉碎纸机，消失在系统中
unlink glob '*.o';
unlink <'*.o'>;


my $successful = unlink "slate","bedrock","java";
print "I deleted $successful file(s) just now\n"; #如果是0，表示没有删除任何文件
** perl seek [#B]                                                     :perl:
:LOGBOOK:
CLOCK: [2018-08-28 周二 18:05]--[2018-08-28 周二 21:21] =>  3:16
:END:
                         Added: [2018-08-28 周二 18:05]
                         
                https://blog.csdn.net/bingfengxiao/article/details/6657696         

#+BEGIN_SRC perl
                  seek 设置文件的当前位置！

                  当一个文件非常大时可以从指定位置读起。 
                  seek FILEHANDLE,POSITION,WHENCE

                  成功返回真，失败返回假。 
                  POSITION 是读入的新位置（字节）。 
                  WHENCE有3个值，0表示新位置是POSITION,1表示当前位置加上POSITION，2表示文件尾加上POSITION 
                  例如：从file.txt的12字节开始读起并打印出来。 
                  open (FILEHANDLE,"<file.txt") or die "cannot open file.txt"; 
                  seek FILEHANDLE,12,0; 
                  while (<FILEHANDLE>){ 
                  print; 
                  } 
                  close (FILEHANDLE);
#+END_SRC

perl 在操作文件指针时，可以用seek 函数移动文件指针

seek (filevar, distance, relative_to);
seek (filevar, position, whence);
在文件中向前/后移动，有三个参数：
1、filevar，文件指针
2、distance，移动的字节数，正数向前移动，负数往回移动
3、reletive_to，值可为0、1或2。为0时，0表示新位置为position位置或者distance位置，为1时，相对于当前位置（将要读的下一行,）移动(当前位置加上position)，
为2时，相对于文件末尾移动+position位置。
运行成功返回真（非零值），失败则返回零，常与tell函数合用。


如果用户想直接获得文件的字节数，可以先偏移到文件末尾(所以第二个参数为0，如果不为0，表示末尾数值加上该值)，再查看当前偏移位置来查看

#+BEGIN_SRC perl
open FILE, "<", "/opt/test/test.txt";

seek(FILE, 0, 2);

my $position = tell(FILE);
#+END_SRC



运用到实际程序


#+BEGIN_SRC perl
  #!/usr/bin/env perl
  #===============================================================================
  #
  #         FILE: testOneFileDelete.pl
  #
  #        USAGE: ./testOneFileDelete.pl  
  #
  #  DESCRIPTION: 
  #
  #      OPTIONS: ---
  # REQUIREMENTS: ---
  #         BUGS: ---
  #        NOTES: ---
  #       AUTHOR: Ye Zhao Liang (YZL), yezhaoliang@ncepu.edu.cn
  # ORGANIZATION: NCEPU
  #      VERSION: 1.0
  #      CREATED: 2018/8/28 17:32:03
  #     REVISION: ---
  #===============================================================================

  use strict;
  use warnings;
  use utf8;


  my	$journal2018_file_name = '20171000112.org';		# output file name

  open  my $journal2018, '<', $journal2018_file_name
      or die  "$0 : failed to open  output file '$journal2018_file_name' : $!\n";


  my	$journalOut_file_name = 'outputTest.org';		# output file name

  open  my $journalOut, '>', $journalOut_file_name
      or die  "$0 : failed to open  output file '$journalOut_file_name' : $!\n";

  while ( <$journal2018> ) {
    
      if (/^\*\skeep/ ) {
          print tell $journal2018,"$_\n";
          seek($journal2018,(tell $journal2018)+150,0);
      }else{
          print $journalOut $_;
      }
  }

  close  $journal2018
      or warn "$0 : failed to close output file '$journal2018_file_name' : $!\n";
  close  $journalOut
      or warn "$0 : failed to close output file '$journalOut_file_name' : $!\n";




#+END_SRC
** perl收集所有文件内容到一个文件 [#B]                                :perl:
:LOGBOOK:
CLOCK: [2018-08-28 周二 21:21]--[2018-08-28 周二 21:21] =>  0:00
:END:
                         Added: [2018-08-28 周二 21:21]
                         

#+BEGIN_SRC perl
  #!/usr/bin/env perl
  #===============================================================================
  #
  #         FILE: testCollect.pl
  #
  #        USAGE: ./testCollect.pl  
  #
  #  DESCRIPTION: 
  #
  #      OPTIONS: ---
  # REQUIREMENTS: ---
  #         BUGS: ---
  #        NOTES: ---
  #       AUTHOR: Ye Zhao Liang (YZL), yezhaoliang@ncepu.edu.cn
  # ORGANIZATION: NCEPU
  #      VERSION: 1.0
  #      CREATED: 2018/8/28 17:07:32
  #     REVISION: ---
  #===============================================================================

  use strict;
  use warnings;
  use utf8;



  my	$journalOne_file_name = '../OneJournal.org';		# output file name

  open  my $journalOne, '>', $journalOne_file_name
      or die  "$0 : failed to open  output file '$journalOne_file_name' : $!\n";

  #while ( glob("*") ) {
  while ( <*> ) {

      my	$journalF_file_name = "$_";# input file name

      print "$_\n";
      open  my $journalF, '<', $journalF_file_name
          or die  "$0 : failed to open  input file '$journalF_file_name' : $!\n";

      print $journalOne "* $_\n";
      my  $lineNumber=1;
      while ( <$journalF> ) {
          if($lineNumber >8)
          {
              print $journalOne "$_\n";
          }
          $lineNumber=$lineNumber+1;
      }
      close  $journalF
          or warn "$0 : failed to close input file '$journalF_file_name' : $!\n";

  }

  close  $journalOne
      or warn "$0 : failed to close output file '$journalOne_file_name' : $!\n";



#+END_SRC
** Sun set(光符集 sun character set)

sunset日落（日落字符)
** json parser [#B]                                                :clojure:
:LOGBOOK:
CLOCK: [2018-08-29 周三 09:16]--[2018-08-29 周三 09:20] =>  0:04
:END:
                         Added: [2018-08-29 周三 09:16]
                         
https://github.com/jiacai2050/clj-json

一个简易的clojure写的json-parser


#+BEGIN_SRC org
  \-?\d+(\.\d+)?([e|E][+|-]?\d+)?
#+END_SRC


结构挺清晰的，json-value中包含五种类型解析，我觉得可分为两类字面值解析和非字面值解析。

1. 字面值解析包含字符串，数字和布尔值，分别对应json-string,json-number,json-literals;
2. 非字面值解析包含数组和对象，分别对应json-array和json-object。实战中主要引用了parsatron库。

clojure 里面很有有趣的库
http://riemann.io/

https://github.com/nathanmarz/specter/
** perl正则匹配数字 [#B]                                              :perl:
:LOGBOOK:
CLOCK: [2018-08-29 周三 09:21]--[2018-08-29 周三 09:22] =>  0:01
:END:
                         Added: [2018-08-29 周三 09:20]
                         

#+BEGIN_SRC perl

my  $source="I have a string: 34.5 then -34.5 , also -34.5E6 or -34.56e6, finally 34.5E+10 or 34.5E-10";


while ( $source =~ m/(\-?\d+(\.\d+)?([e|E][+|-]?\d+)?)/xgm ) {
print "$1\n";
}

#+END_SRC
** 涡轮、压气机 [#B]                                                  :学术:
:LOGBOOK:
CLOCK: [2018-08-31 周五 12:26]--[2018-08-31 周五 12:36] =>  0:10
:END:
                         Added: [2018-08-31 周五 12:26]
                         

涡轮增压，航空领域（汽车、飞机）！涡轮增压器实际上是一种空气压缩机，通过压缩空气来增加进气量，它是利用惯性冲力来增加发动机的输出功率
涡轮（Turbo），是在汽车或飞机的引擎中的风扇，通过利用废气（exhaust gases）把燃料蒸汽（fuel vapour ）吹入引擎，
以提高引擎的性能。涡轮是一种将流动工质的能量转换为机械功的旋转式动力机械。
它是航空发动机、燃气轮机和蒸汽轮机的主要部件之一。

***  TURBO


本体研究（本体部件研究） ： 涡轮和压气机（核心机）

辅机： 泵与风机

别单单研究纯流场（流场围绕部件做研究）


高速转子是旋转机械(流体机械)的核心部,对其安全运行起至关重要的作用，在高效率清结构的旋转机械中更加不可忽视

第一梯队：清华、工程热物理所（涡轮、压气机） 西交
第二梯队： 哈工大，哈工程，北航，西工大
第三梯队: 上海理工，中南大学..

华电。。。


两者都是引擎中的部件，压气机是由涡轮驱动（压气机的启动部分是涡轮，进气流道增压）。两者功能如下：
压气机（compressor）：燃气涡轮发动机中利用高速旋转的叶片给空气作功以提高空气压力的部件。
压气机叶轮叶片的前端部分呈弯曲状称为导轮，起作用是将气体无冲击的导入工作叶轮，减小气流冲击损失。
小型增压器的压气机叶轮一般将导轮与工作叶轮制成一体。
压气机的叶轮出口有扩压器，使气体在叶轮中获得的动能尽可能多地转化为压力。扩压器分为叶片式和缝隙式两种。
压气机的外壳有气流的进口和出口。进口一般呈轴向布置，流道略呈渐缩，以减小进气阻力。出口一般设计成流道沿圆周渐扩的蜗壳状，使高速气流在那里继续扩压，提高增压器的总效率。压气机由涡轮驱动，其主要性能参数有：转速、流量、空气流量、增压比和效率等。
涡轮（Turbo）,也叫作燃气机，就是平时说的涡轮喷气发动机，一般用于航空航天，（空气流动，增压），是在汽车或飞机的引擎中的风扇，通过利用废气（exhaust gases）把燃料蒸汽（fuel vapour ）吹入引擎，以提高引擎的性能。涡轮是一种将流动工质的能量转换为机械功的旋转式动力机械。它是航空发动机、燃气轮机和蒸汽轮机的主要部件之一。


区别在于：
1.涡轮，turbine（将流体潜能转化为机械能的机器：比如水轮机，汽轮机，燃气轮机，风力涡轮机, 四种不同介质产生不同的涡轮)的作用，
是受到流动的气体所产生的力，使之旋转，而产生机械动力
简单是说，就是将风能转换为机械能

透平是英文turbine的音译，源于拉丁文turbo一词，意为旋转物体。
透平最主要的部件是旋转元件(转子或叶轮），被安装在透平轴上，具有沿圆周均匀排列的叶片。流体
所具有的能量在流动中经过喷管时转换成动能，流过转子时流体冲击叶片，推动转子转动，从而驱动
透平旋转轴宣州。透平轴直接或经传动机构带动其他机械，输出机械功。

透平按所用的流体工质不同可分为水轮机(用作水电站的动力源）
汽轮机（用于火力发电厂、船舶推进等）
燃气透平（用作喷气式飞机的推进动力、舰船动力，以及发电厂、尖峰负荷用小型电站等
水轮机：
2.压气机的作用
一般有一个主动力，使压气机风扇旋转，使空气流动
简单的说，就是将机械能转换成风能


燃气涡轮发动机，主要有四种类型

1. 涡轮喷气发动机（简称涡喷）
2. 涡轮风扇发动机（简称涡扇）
3. 涡轮螺旋桨发动机
4. 涡轮轴发动机（直升机的发动机） 有两组涡轮：第一组涡轮用来带动压气机，第二组用输出轴功带动直升机旋翼（涡轮做功）

涡喷发动机主要用在高速战斗机，早期的涡喷发动机与普通涡轮发动机一样，由
轴流式压气机、环形燃烧室或环管燃烧室、轴流式涡轮组成。现在的涡喷发动机增加了动力
燃烧室。----》主要功能产生高温高压燃气，从尾管中高速喷出产生推力，他就是飞机的推进器，涡喷仅
带动压气机，不向外输出机械功。多级压气机----


没有压气机和涡轮一样有推力，只不过热力循环不是最合适的。（涡轮是动力输出，压气机是高压气体输出）


有压气机的地方就必须有涡轮？？尾喷管用于调节涡轮落压比，即调节涡轮做功


涡轴发动机就能给直升机、坦克、舰船、发电机做动力（动力部件）

Ma=3, YF-12A型歼击机进气道产生净推力的70% 前椎体产恒14%， 喷嘴27% 核心机（压气机+燃烧室+涡轮）只占17%
说明进气道和尾喷管很重要，对于高速飞行飞机动力装置中起到关键性作用


***  压气机原理

一级涡轮吸收风能，使得空气流经压气机，进行压缩空气过程！

登熵绝热压缩做功

进气道压缩工程，
压气机所需动力(机械能）由涡轮提供； 压气机对气流加工，压力增加，能量增加。


增压比越大，热效率越高。发动机越好，压比越高（承受压力能力越强）

2000 年，北航陈懋章院士作出了2级大小叶片压气机实 现压比6的方案。


压气机的完整设计过程包括以下几个步骤：
（1）确定转速和流道尺寸。
（2）给定效率，确定压气机级数。
（3）计算每一级平均半径处的气流角。
（4）确定从叶根至叶尖的气流角变化。
（5）压缩效应研究。
（6）根据叶栅试验数据选择压气机叶型。
（7）使用叶栅数据，核查之前假定的效率。
（8）评估非设计点性能。
（9）台架试验。 [3] 
http://www.360doc.com/content/15/0525/20/14106735_473205015.shtml


视频介绍不错！

http://v.qq.com/iframe/player.html?vid=t1314x6rbtr&300&NaN&auto=0
** tag system [#B]                                               :emacslisp:
:LOGBOOK:
CLOCK: [2018-09-02 周日 16:25]--[2018-09-02 周日 17:04] =>  0:39
:END:
                         Added: [2018-09-02 周日 16:25]
                         
http://irreal.org/blog/?p=7447

org mode --->tag system-->reproducible research methods

  Over at the Emacs subreddit, rmberYou has a post on how he uses Org mode to get and stay organized()https://www.reddit.com/r/emacs/comments/9ajxqj/tip_how_i_organize_myself_with_orgmode/.
The post is mainly a taxonomy of his Org mode files but his setup may be useful to others.

  A couple of points are worth mentioning. First, he prefers a single large Org file for each general category.
That’s the approach taken by Carsten Dominik1, the original developer of Org mode.
I like that approach because every thing related to a given category is one place.
This is especially helpful when you’re employing reproducible research methods.

  Secondly, [one of the commentors](https://www.reddit.com/r/emacs/comments/9ajxqj/tip_how_i_organize_myself_with_orgmode/e4w71hl/) notes that you should also integrate a knowledge system
to record and help you remember bits of knowledge even if they aren’t actionable. 
I do this by recording things I’ve learned and might want later in my journal.
Org mode is really good for this because of its tag system.
I can simply add tags to the entry that reflect its content and then when I want it again,
it’s easy to find if I can remember even one of the tags.

  It’s worth spending a couple of minutes to read rmberYou’s post.
He says being organized helps you deal with today’s hectic(繁忙的) pace.
I’ve found that a little effort in being organized allows me to get things done while still indulging my basically lazy nature.
** 科研? [#B]                                                       :@NCEPU:
:LOGBOOK:
CLOCK: [2018-09-04 周二 18:09]--[2018-09-04 周二 18:54] =>  0:45
:END:
                         Added: [2018-09-04 周二 18:09]
                         

                         
我们如何把我们正在做的东西变成产品？ 能够有益于人们的认识，帮助人们》
不是说只是为了做产品，而是做产品的态度，想着帮助人们，通过产品来表达你的态度。


我们做的是科研？充满低级趣味的重复性工作,文库里面99%的东西都是没用的？！(陈芝麻烂谷子)
现在做的科研不是那个带着问题，有逼迫性、必须解决这个问题才能继续的时代！！


持续性的自主学习(知道自己的不足，并且会想着去弥补)-----这是一个博士最优秀的品质
自己主动，这边的持续只是强调学习，其实还应该是不是加上一个专注？！

需要持续学习的是沟通、交流(如何去沟通和表达)！

https://www.cn-healthcare.com/article/20180222/content-500528.html
MIT技术Review(From 克克老师)
https://www.technologyreview.com/


Phys.org
https://phys.org/

Science
http://www.sciencemag.org/


Nature:
https://www.nature.com/



MIT公开课
https://ocw.mit.edu/index.htm

网易公开课
http://open.163.com/special/opencourse/



百度开源的PaddlePaddle(google，faceBook,IBM也有，阿里也有，腾讯也有)
https://www.aliyun.com/jiaocheng/151402.html?spm=5176.100033.1.22.60oQKb

20180902华为 
http://business.sohu.com/20180902/n548273375.shtml    麒麟980
** auto-save for emacs [#B]                                      :emacslisp:
:LOGBOOK:
CLOCK: [2018-09-05 周三 11:38]--[2018-09-05 周三 11:38] =>  0:00
:END:
                         Added: [2018-09-05 周三 11:38]
                         
https://www.jianshu.com/p/998ceaf522d1
** 每页笔记想要传达的意思 [#B]                                      :@NCEPU:
:LOGBOOK:
CLOCK: [2018-09-05 周三 17:43]--[2018-09-05 周三 17:43] =>  0:00
:END:
                         Added: [2018-09-05 周三 17:43]
                         
这页笔记真的能够传达你想要表达的信息？？？？

一份笔记应该尽可能都展示，但是一个ppt则是仅仅展示重点的部分（全部展示，等于都没有展示）

研究的背景意义仅仅是想要提出一个你的研究问题

而针对研究问题提出来的研究内容则需要仔细讲，细致讲（重点讲），具体和清晰的研究思路，研究逻辑（屡清逻辑思路）！
你为什么研究这些内容，这些内容有什么意义？ 多个实现方法为什么最后选择它？ 
比如CFD算法确认（做了三项内容，1 CFD于BPM的模型及你选哪个确认，最终选择CFD，2 CFD的网格影响（包括网格无关性的校验），3 CFD湍流模型的影响（不同湍流模型的比较，最终选择什么）


概念第一次出现的时候，一定得介绍他的定义和物理意义（比如指向性分布：表示声音强度的相对值

第一次出现的图，一定得描述横坐标表示什么意思，纵坐标表示什么意思！
在多副图之间，一定要描述多副图之间的关系（他们的区别和联系）他们为什么这样变化！
** dynamic pitching and yaw [#B]                                    :@NCEPU:
:LOGBOOK:
CLOCK: [2018-09-05 周三 20:57]--[2018-09-06 周四 15:19] => 18:22
:END:
                         Added: [2018-09-05 周三 20:57]
                         
Unsteady aerodynamics of offshore floating wind turbines in platform pitching motion using vortex lattice method

Jeon[] 2014 applied vortice lattice method .

李新凯-大厚度翼型数值计算方法研究3 (2)
** 安装jekkly博客六步法 [#B]                                        :@NCEPU:
:LOGBOOK:
CLOCK: [2018-09-13 周四 14:21]--[2018-09-13 周四 15:08] =>  0:47
:END:
                         Added: [2018-09-13 周四 14:21]
                         
现在新机子上面配置github （ssh 不再root用户下）
(补充：速度快的话，一个机子10min一个博客)
第一步：
https://help.github.com/articles/set-up-git  ----

git config --user.name "Ye Zhaoliang"
git config --user.email "zhaoturkkey@163.com"

ssh-keygen -t rsa -C "zhaoturkkey@163.com" 
 
eval "$(ssh-agent -s)" # Agent pid 59566 ssh-add ~/.ssh/id_rsa 

sudo apt-get install xclip # Downloads and installs xclip. If you don't have `apt-get`, you might need to use another installer (like `yum`) xclip -sel clip < ~/.ssh/id_rsa.pub # Copies the contents of the id_rsa.pub file to your clipboard
粘帖到你的github账户即可


矫兔三库




第二步：
git clone https://github.com/jueqingsizhe66/jueqingsizhe66.github.com

git checkout 最新的source9分支即可（sourcen)


第三步：
ruby 安装( 事先检查一下  ruby --versio n add by Yezhaoliang   没用还是执行这一步较好！
             否则可能的报错是：RedCloth -v '4.2.9'无法安装) 
apt-get install ruby1.9.3(一定要做好这一步！)
(ruby supplied the gem tools)
（切换不同版本的ruby ：  
curl -L https://get.rvm.io | bash -s stable --ruby  
rvm install 1.9.3  
rvm use 1.9.3  
rvm rubygems latest 
***  To start using RVM you need to run `source /usr/local/rvm/scripts/rvm`
    in all your open shell windows, in rare cases you need to reopen all shell windows.
source /usr/local/rvm/scripts/rvm这是一个bug，经常需要执行这个，因为可能rvm就被关掉了，一关掉，rake就报错！！！切记
有时候遇到rake问题最好的办法是，重新gem install bundler ， rehash，bundle install即可重新安装rake

）



第四步：

gem sources --remove http://rubygems.org/   -----> should confirm to let it right
gem sources -a http://ruby.taobao.org/
修改gem的源 较好
   源用 http://ruby.taobao.org 会比较快一些。
apt-get install rake
rake 安装：( 注意 这一步 是在 你的 当前 source7 的 根目录 下 执行的   add by yezhaoliang) 
  
(apt-get install rbnevy已经不管用了 在ubuntu 2015 4 -28
*************apt-get install rbenv 因为写错了  应该该是rbenv***************
)
sudo gem install bundler ;apt-get install rbenv; rbenv rehash ; bundle install(
sudo apt-get install ruby-dev  ; because RedCloth 
)
(切记 根目录下执行 还是错误！！)

第五步：
最重要的一步不要忘记了,这样才可以进行deploy
（

Rake的意思是Ruby Make，一个用ruby开发的代码构建工具。Rake的英文意思是耙子，一种很朴实的劳动工具。真的是很贴切，Rake正是一个功能强大、勤勤恳恳的劳动工具。
）
rake setup_github_pages
(有可能遇到 这种情况，你的rake更新到了 rake 10.3.2 而你的Gemfile还是 rake 0.9版本，这时候就需要吧0.9改为10.3.2即可)
可以了  ,我这样弄才可以 git@github.com:jueqingsizhe66/jueqingsizhe66.github.com

第六步：
rake generate  ; rake preview.......
rake new_post[""] 
rake deploy
都是可行的
 git pull origin  source7  拉取远程最新的source7分支覆盖当前分支 
 
 第一步： configure git
第二步： clone your data
第三步： ruby install
第四步： rake install
第五步： setup_github_pages
第六步： preview 
 
 
 
//windows版本的安装：



**  测试PlantUML



#+BEGIN_SRC plantuml :file testSequence.png :cmdline -charset UTF-8

  title 时序图

  == 鉴权阶段 ==

  Alice -> Bob: 请求
  Bob -> Alice: 应答

  == 数据上传 ==

  Alice -> Bob: 上传数据
  note left: 这是显示在左边的备注

  Bob --> Canny: 转交数据
  ... 不超过 5 秒钟 ...
  Canny --> Bob: 状态返回
  note right: 这是显示在右边的备注

  Bob -> Alice: 状态返回

  == 状态显示 ==

  Alice -> Alice: 给自己发消息
#+END_SRC

#+RESULTS:
[[file:testSequence.png]]


必须加上UTF-8否则乱码

#+BEGIN_SRC plantuml :file test.uml.png :cmdline -charset UTF-8
start
:"步骤1处理";
:"步骤2处理";
if ("条件1判断") then (true)
    :条件1成立时执行的动作;
    if ("分支条件2判断") then (no)
        :"条件2不成立时执行的动作";
    else
        if ("条件3判断") then (yes)
            :"条件3成立时的动作";
        else (no)
            :"条件3不成立时的动作";
        endif
    endif
    :"顺序步骤3处理";
endif

if ("条件4判断") then (yes)
:"条件4成立的动作";
else
    if ("条件5判断") then (yes)
        :"条件5成立时的动作";
    else (no)
        :"条件5不成立时的动作";
    endif
endif
stop
#+END_SRC

#+RESULTS:
[[file:test.uml.png]]


#+BEGIN_SRC plantuml :file test_package.png :cmdline -charset UTF-8
package "组件1" {
    ["组件1.1"] - ["组件1.2"]
    ["组件1.2"] -> ["组件2.1"]
}

node "组件2" {
    ["组件2.1"] - ["组件2.2"]
    ["组件2.2"] --> [负载均衡服务器]
}

cloud {
    [负载均衡服务器] -> [逻辑服务器1]
    [负载均衡服务器] -> [逻辑服务器2]
    [负载均衡服务器] -> [逻辑服务器3]
}

database "MySql" {
    folder "This is my folder" {
        [Folder 3]
    }

    frame "Foo" {
        [Frame 4]
    }
}

[逻辑服务器1] --> [Folder 3]
[逻辑服务器2] --> [Frame 4]
[逻辑服务器3] --> [Frame 4]
#+END_SRC

中文必须加上charset

#+RESULTS:
[[file:test_package.png]]


#+BEGIN_SRC plantuml :file testUseCase.png :cmdline -charset UTF8
title 用例图
left to right direction
actor 消费者
actor 销售员
rectangle 买单 {
消费者 -- (买单)
(买单) .> (付款) : include
(帮助) .> (买单) : extends
(买单) -- 销售员
}
#+END_SRC

#+RESULTS:
[[file:testUseCase.png]]

** 测试dot graphviz


#+BEGIN_SRC dot :file test_graphviz.png :cmdline -Kdot -Tpng
  digraph G {
    size="8,6"
    ratio=expand
    edge [dir=both]
    plcnet [shape=box, label="PLC Network"]
    subgraph cluster_wrapline {
      label="Wrapline Control System"
      color=purple
      subgraph {
      rank=same
      exec
      sharedmem [style=filled, fillcolor=lightgrey, shape=box]
      }
      edge[style=dotted, dir=none]
      exec -> opserver
      exec -> db
      plc -> exec
      edge [style=line, dir=both]
      exec -> sharedmem
      sharedmem -> db
      plc -> sharedmem
      sharedmem -> opserver
    }
    plcnet -> plc [constraint=false]
    millwide [shape=box, label="Millwide System"]
    db -> millwide
 
    subgraph cluster_opclients {
      color=blue
      label="Operator Clients"
      rankdir=LR
      labelloc=b
      node[label=client]
      opserver -> client1
      opserver -> client2
      opserver -> client3
    }
  }
 
#+END_SRC

#+RESULTS:
[[file:test_graphviz.png]]
** workflow management system [#B]                                  :@NCEPU:
:LOGBOOK:
CLOCK: [2018-09-16 周日 03:35]--[2018-09-16 周日 03:44] =>  0:09
:END:
                         Added: [2018-09-16 周日 03:34]
                         
Since designing and launching a specialized workflow(knowledgement) mangement system in 2010,

a reasearch team from the US Departement of Energy's Oak Ridge National Laboratory has continuously 
updated the technology to help computaional scientists develop software, visualize data and solve
problems. 

Workflow management systems allow users to prepare ,produce and analyze scientific process to 
help simplify complex simulations. Known as the Eclipse integrated Computational Environment, or ICE
this particular system incorporates a comprehensive suite of scientific computing tools designed to 
save time and effort expended during modeling and simulation experiments.

Compiling these resources into a single platform both improves the overall user experience and 
expedites scientific breakthroughts. Using ICE, software developers, engineers, scientists and programmers
can define problems, run simulations locally on personal computers or remotely on other systems--
even supercomputers--and then analyze results and archive data. Recently, the team published an 
article in SoftwareX that both details the history of the system and previews the potential benefits of 
upcoming versions.

"What I really love about this project is making complicated computational science automatic," said Jay Jay Billings,
a researcher in ORNL's Computer Science and Mathematicas Division who leads the ICE development team. "Building workflow
management systems and automation tools is a type of futurism, and it's challenging and rewording to operate
at the edge of what's possible.""

upcoming versions.


Researchers use ICE to study topics in fields including nuclear energy, astrophysics, additive manufacturing, 
advanced materials, neutron science and quantum computing, answering questions such as how batteries behave 
and how some 3-D-printed parts deform when exposed to heat.

Several factors differentiate ICE from other workflow management systems. For example, 
because ICE exists on an open-source software framework called the Eclipse Rich Client Platform,
 anyone can access, download and use it. Users also can create custom combinations of reusable 
resources and deploy simulation environments tailored to tackle specific research challenges.

"Eclipse ICE is an excellent example of how open-source software can be leveraged to accelerate 
science and discovery, especially in scientific computing," said Eclipse Foundation 
Executive Director Mike Milinkovich. "The Eclipse Foundation, through its community-led
 Science Working Group, is fostering open-source solutions for advanced research in all areas of science

Additionally, ICE circumvents the steep and time-consuming learning curve that usually accompanies any computational science project. Although other systems require expert knowledge of the code and computer in question, ICE enables users to immediately begin facilitating their experiments, thus helping them gather data and achieve results much faster.

"We've produced a streamlined interface to computational workflows that differs from complicated systems that you have to be specifically qualified in to use properly," Billings said.

Throughout this project, Billings has also emphasized the importance of accessibility and usability to ensure that users of all ages and experience levels, including nonscientists, can use the system without prior training.
cite:LiuLu-26025
"The problem with a lot of workflow management systems and with modeling and simulation codes in general is that they are usually unusable to the lay person," Billings said. "We designed ICE to be usable and accessible so anyone can pick up an existing code and use it to address pressing computational science problems."

ICE uses the programming language Java to define workflows, whereas other systems use more obscure languages. Thus, students in grade school, high school and college have successfully run codes using ICE.

Finally, instead of relying on grid workflows—collections of orchestrated computing processes—ICE focuses on flexible modeling and simulation workflows that give users interactive control over their projects. Grid workflows are defined by strict parameters and executed without human intervention, but ICE allows users to input additional information during simulations to produce more complicated scenarios.

"In ICE you can have humans in the loop, meaning the program can stop, ask questions and receive instructions before resuming activity," Billings said. "This feature allows system users to complete more complex tasks like looping and conditional branching."

Next, the development team intends to combine the most practical aspects of ICE and other systems through workflow interoperability, a concept referring to the ability of two different systems to seamlessly communicate. Combining the best features of grid workflows with modeling and simulation workflows would allow scientists to address even greater challenges and solve scientific mysteries more efficiently.

"If I'm using ICE and someone else is using a different system, we want to be able to address problems together with our combined resources," Billings said. "With workflow interoperability, our systems would have a standard method of 'talking' to one another."

To further improve ICE's accessibility and usability, the team is also developing a cloud-based version to provide even more interactive computing services for simplifying scientific workflows.

"That's what research is—we keep figuring out the next step to understand the system better," Billings said.

Read more at: https://phys.org/news/2018-09-technology-science.html#jCp cite:叶昭良王晓东-26083 

Read more at: https://phys.org/news/2018-09-technology-science.html#jCp

https://phys.org/news/2018-09-technology-science.html

cite:叶昭良王晓东-26083
** 知识生态 [#B]                                                    :@NCEPU:
:LOGBOOK:
CLOCK: [2018-09-18 周二 15:56]--[2018-09-18 周二 16:16] =>  0:20
:END:
                         Added: [2018-09-18 周二 15:55]
                         
                         
关键词: 技术佣兵,知识生态，产品生态，工业生态, 商业价值，未来走向


地图导航，如果你纯粹用这个方式去做，你只是把一个拥挤的地方移到另外一个拥挤的地方。
经济学，它对问题的建模是不一样的。它起点是假定是一个整体的一个生态，每个人的输入
都是另外一个人的输出，你要用经济学的方式来描述地图导航的问题，你就会去算一个Equilibrium，市场也是这样

知识构成一个一个的生态。


前百度内部Engineering Leadership：陆奇（现Y Combinator中国创始人），作为计算机科学博士及优秀的管理者，
他提出的五点要求，对每一位百度工程师都适用。

    “我们一定要有一个坚定不移的深刻的理念，相信整个世界终究是为技术所驱动的。”

    “有没有其他人已经解决这个问题？然后你可以把你的时间放在更好的创新上。” 

    “做什么事情一定要做最好，一定要是做业界最强的。”

    “我把自己想象是一个软件、一个代码，今天的版本一定要比昨天版本好，明天的版本肯定会比今天好。”

    “看到问题也不要去问别人，就把它Fix。”






= 01 Believe in 技术 =

  
首先要相信技术，我刚才已经讲了，整个我们工业界，特别是像百度这样的公司，对技术坚定的、不动摇的信念特别重要。

我也分享一下，盖茨提到微软公司的宗旨就是：写软件代表的是世界的将来。

为什么？未来任何一个工业都会变成软件工业。盖茨是对的，因为任何工业任何行业自动化的程度会越来越高，最后你所处理的就是信息和知识。

但现在软件的做法又往前提了一次，因为在人工智能时代，不光是写代码，你必须懂算法，懂硬件，懂数据，整个人工智能的开发过程有一个很大程度的提高，
但是，技术，特别是我们这个工业所代表的技术一定是将来任何工业的前沿。

所以我们一定要有一个坚定不移的深刻的理念，相信整个世界终究是为技术所驱动的。



= 02 站在巨人的肩膀上做创新 =

重复了？ 你的灯还亮着?

我们观察一下，在美国硅谷、在中国，互联网创业公司也好，大型公司也好，大家的起点是越来越高的。为什么现在创新速度那么快？
主要是起点高了。我们可以使用的代码模块，使用的服务的能力，都是大大的提升。

在内部我想强调这一点，很多大公司包括微软在内，内部的Code都重做了无数遍。

我现在的要求是，每一次你写一行新的代码，第一要做的，先想一想你这行代码值得不值得写，是不是有人已经做了同样的工作，
可能做得比你还好一点。有没有其他人已经解决这个问题，然后你可以把你的时间放在更好的创新上。

特别是大公司里面重复或者是几乎重复的Code实在太多，浪费太多的资源，对每个人的职业生涯都不是好事情。

我再强调，在大公司内部，你写代码之前想一想，你这行代码要不要写，是不是别人已经有了，站在别人的肩膀上去做这件事情。



= 03 追求Engineering Excellence =

     
我要另外强调的一点就是Engineering Excellence，工程的技术的卓越性和能力。

任何市场上竞争就像打仗一样，就看你的部队体能、质量，每一个士兵他的训练的程度，和你给他使机关枪、坦克，还是什么样的武器。

所以Engineering Excellence跟这个类比，我们要建的是一支世界上最强的部队，每一个士兵，每一个领军人，每个人的能力，
他的训练都是超强的，然后我们给每个人提供的工具和武器都是一流的。

所以Engineering Excellence是一个永无止境的、个人的、团队的，能力的追求和工具平台的创新，综合在一起可以给
我们带来的长期的、核心的竞争力，为社会创造价值，最终的目的是给每个用户、每个企业、整个社会创造价值。

我另外还要在这里强调的一点就是Relentless pursuit of excellence：永无止境的不断的持续的追求。

我们要么不做，要做的事情一定做最好，这是我对大家的要求。数据库也好，做大平台也好，大数据也好，我们要做什么事情，
我们一定要下决心，这是我对你们每个人的要求，做什么事情一定要做最好，一定要是做业界最强的。



= 04 每天学习 =


每天学习，可能是对每个人都是最最重要的。

我今天分享一下，我自己怎么想我自己的。就很简单一个概念，我把自己想象是一个软件、一个代码，
今天的版本一定要比昨天版本好，明天的版本肯定会比今天好，因为即使犯了错误，我里面有If statement，说如果见到这个错误，绝对不要再犯。

英语，另外有一句说法就是Life is too short, don’t live the same day twice. 同样一天不要重活两次。
每天都是不一样，每天为什么不一样，因为每天都变成最好，每天都变得更好。今天的版本一定要比昨天好，
每个好的、杰出的工程师，杰出的技术领袖，一定要保持自己学习的能力，特别是学习的范围。

在这上面我也稍微引申一下，做Computer science的，如果只学Computer science，不去学一些其他的行业，肯定不够。
我举个例子，经济学必须要学。为什么这样讲？Computer science它有个很大的限制，他是假定你有输入以后有输出，
这种解决问题的方式有它的好处，但有它的限制性。

我给大家举个例子，地图导航，如果你纯粹用这个方式去做，你只是把一个拥挤的地方移到另外一个拥挤的地方。
经济学，它对问题的建模是不一样的。它起点是假定是一个整体的一个生态，每个人的输入都是另外一个人的输出，
你要用经济学的方式来描述地图导航的问题，你就会去算一个Equilibrium，市场也是这样。

如果把深度学习真的要想彻底，必须把物理重学一遍，把生物学看一遍，再把进化论再看一遍。
因为深度学习跟这些东西完全相关，自己肯定想不清楚，要彻底想清楚，必须学。

另外，学产品，我以前跟所有的工程师都讲，如果不懂产品，你不可能成为一个最好的工程师。
真正要做世界一流的工程师不光要懂产品，还要懂整个商业，懂生态。因为你的工作的责任，
是能够看到将来，把技术展望到将来的需求，把平台、把开发流程、把你的团队为将来做准备。所以学习是非常非常重要的。



= 05 Ownership =

     
最后是从我做起。

我们公司有个非常大的使命，用科技让复杂的世界更简单。整个世界非常非常复杂，人其实所做的事情基本上都是Reduce entropy。

因为从热力学第二定律来讲，世界是会变得越来越乱的，我们想做的事情就是把它变的更简单，让我们生活变得更美好。

而且具体的，我们可以通过人工智能技术来做到唤醒万物，但是这一切是通过每一个人的一点一滴的行为累计起来，
从我做起。还有Ownership，看到机会不需要问别人，有机会就去做，看到问题也不要去问别人，就把它Fix。

把我们的使命、把我们的公司当成我们自己每个人的事业来做，我可以坦诚的给每个人讲，如果你把公司的使命，
把公司的事业，当成你自己个人的事业，Own everything，你在职业生涯一定是走得最快。从我做起，从身边的每一件事情做起。

Believe in 技术、站在巨人的肩膀上做创新、追求Engineering Excellenc
** 穷病真没法治? [#B]                                                 :学术:
:LOGBOOK:
CLOCK: [2018-09-19 周三 02:40]--[2018-09-19 周三 02:51] =>  0:11
:END:
                         Added: [2018-09-19 周三 02:39]
                         

药贩子真的觉得穷病没法治？


虽然很多人不想买假烟，假酒等，但为什么市场就会有那么多假玩意？因为大家缺钱？
是的，正经生意不挣钱，只好作假的。

那为什么有些人喜欢通过走私人渠道、走海外通道、走水货？因为便宜，自己缺钱！

经济的到底最终都是平衡，为什么有那么多人没钱？因为很多钱流入一些人手中。

怎么从这些人手中拿出来？ 抢、起义、偷、骗、坑、蒙，没有再生，只是交换，不平衡了
就会有这种事情发生。


穷病如何治？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？
** 一个目标 [#B]                                                    :@NCEPU:
:LOGBOOK:
CLOCK: [2018-09-19 周三 22:23]--[2018-09-19 周三 22:24] =>  0:01
:END:
                         Added: [2018-09-19 周三 22:23]
                         
瞄准一个目标，纹丝不动，反复琢磨

1. 目标goal
2. 计划Plan, sketch, outline
3. 分派任务 specify  or impletation(指定谁来做，自己做，别人做)
4. 执行 do， perform
5. 获得perceive 观察
6. 解释interpret
7. 比较compare
** 对文字的敬畏 [#B]                                                :@NCEPU:
:LOGBOOK:
CLOCK: [2018-09-20 周四 19:05]--[2018-09-20 周四 19:05] =>  0:00
CLOCK: [2018-09-20 周四 17:13]--[2018-09-20 周四 17:13] =>  0:00
CLOCK: [2018-09-20 周四 15:09]--[2018-09-20 周四 16:40] =>  1:31
CLOCK: [2018-09-20 周四 13:49]--[2018-09-20 周四 15:09] =>  1:20
:END:
                         Added: [2018-09-20 周四 13:49]
                         
文字生来得让人敬畏。搞了几年文字工作，特别觉得有道理。文字上得下功夫，
因为这也能看到一个人对于工作的态度，以及对于他完成目标的决心。

有些东西可以随意，但是写出来的白纸黑字最好不要随意。

写出来的东西一定得仔细琢磨，这是老一辈科学家经常用到的，当然现在也是。

因为敬畏，所以放慢了前进的脚步，坚定了批判性的思考（不断地反思、纠正)

生而为人，应有所敬畏!懂得尊重文字，把握分寸，守住底线。

敬畏虽有畏字，但不代表害怕、怯弱，而更加强调的是一种敬，尊敬，友好，对文字工作和个人的
尊敬。

What am I investigating?
What am I doing?
What am I feeling?
What am I needing right now?
Do I have a request of myself or someone else?


Give yourself kindness & care ==  self-compassion
Remind yourself pain is part of shared human experiment
** thought of helping and thinking copy [#B]                        :@NCEPU:
:LOGBOOK:
CLOCK: [2018-09-20 周四 16:40]--[2018-09-20 周四 17:13] =>  0:33
:END:
                         Added: [2018-09-20 周四 16:39]
                         
But I shouldn’t let this get in my way(Fuck, get out of my way), since people don’t expect me to be those things.
 (And if they do, that’s under their control, not mine.) Instead, I can focus on the fact that people are often 
looking for a discussion of workflow options with some ideas, and that they’re going to translate those thoughts
 into something applicable to their situation anyway.(Tranlate the thought in your brains to his brain)
** Learn to think [#B]                                              :@NCEPU:
:LOGBOOK:
CLOCK: [2018-09-21 周五 02:39]--[2018-09-21 周五 02:40] =>  0:01
CLOCK: [2018-09-20 周四 17:13]--[2018-09-20 周四 19:05] =>  1:52
:END:
                         Added: [2018-09-20 周四 17:13]
                         
                         
You know that feeling of struggling to learn something that everyone else seems to have an easy time with?
 The one that makes you think, “Maybe this isn’t a good fit for me.” Or worse, “Maybe I’m not smart enough.”

That one.

Embrace it. Learn how to deal with it. This is the real hard work in a degree in computer science or IT or whatever.
 The rest is just implementation.

You see, there will always be more to learn. There will always be challenges to pick apart and overcome.
 If you’re not running into them, you’re not pushing yourself enough. There will always be those moments when you think,
 “How on earth do I even begin to learn how to solve this?”

1. You aren’t learning a computer language or a platform or a system of abstract concepts.
2. You are learning a way of thinking.
3. You are learning how to break down a big challenge into smaller pieces.
4. You are learning how to try different approaches to understand and solve each small part.(方法总比问题多)
5. You are learning to set aside your worries and fears so that you can focus. You are learning how to adapt,
 even as changes come quicker and quicker.
6. You are learning how to organize your thoughts. It just so happens that you’re organizing them in a way a computer can understand.

What can help you build your confidence? Start by building a small base of things you know well.
 Celebrate that. Expand through practice and curiosity. Ask for the help you need. If you don’t get it,
 fight on anyway. All learning feels weird in the beginning. It only becomes natural through repetition.

1. If you’re taking a course, learn what you have to learn, but leave yourself room to learn what you want to learn at your own pace.
 You don’t have to learn everything the first time around. 
2. If you know it takes you several tries to understand something, start before you take something up in class.
That way, you’ll have better questions. Continue afterwards, too.
 Computer science lessons build on each other, like the way mathematics lessons do.
 They assume you understand the previous material. Practice and questions pay off.

[Awesome person] There will always be people who have learned what you want to learn,
 or who will pick up things faster than you can. Most of these people are awesome.
 They know that your questions can help them learn even more,
 and they’re happy to pay it forward because people helped them too.
 Pay them back by writing about what you’ve learned and sharing that with them and others.
 Other people who are also learning will find your questions and answers useful, too.
 This is true whether you’re learning in class or on the Internet, so go ahead and share your journey.

There will always be some people who haven’t quite figured out their own insecurities – 
people who want to establish their position by putting you down.
 You can learn how to recognize what they’re doing. That makes it easier to ignore them.
 Don’t mind them if they try to make you feel bad for asking stupid questions.
 It just means they’re missing out on opportunities to learn how to ask and learn how to learn.(try to ask yourself questions)
 Don’t partner with them. Look for people who help others up, not tear them down.

It is not easy to wrap your mind around new topics or break down a complex unknown.
 If you can get good enough at it, you may come to enjoy that excitement when a problem looks like it’s solvable.
 You’ll learn how to tell if you’re going in roughly the right direction.
 You’ll be able to celebrate even the tiniest progress. If you can do that, you’ll do fine.

Besides, the real world is little like the classroom.
 Even if you never get the hang of the artificial projects you do for education,
 you may find that you like working with technology. Don’t count yourself out just yet!

 

People don’t need more information. They need to figure out where to start.
 For me, the value I provide in the Helpout is in the back-and-forth of a quick conversation that clarifies what people need.
 That way, I can either point them to the right resources or give them some tips in case there are no such resources handy.
 (And then I can build those!) It’s a little difficult to do with a group session, although maybe if I get better at Q&A,
 I might be able to pull that off.
** Emacs not a text-based tools [#B]                             :emacslisp:
:LOGBOOK:
CLOCK: [2018-09-21 周五 19:19]--[2018-09-21 周五 19:43] =>  0:24
:END:
                         Added: [2018-09-21 周五 19:19]
                         
There are few pieces of software as widely misunderstood as Emacs. Emacs
is frequetyly advertised as a text editor, but please be clear on this:
Emacs is not just a text editor.

Emacs is a platform for developing end-user applications with a text-based core.
The Emacs platform ships with a few built-in applications, such as: a calculator,
a terminal shell, a fill manager, a merge tool, and yes , a text editor. You can
extend it into the mail reading tools, music listening tools, movie playing tools,  also gtd tools.


I started using Emacs a
 

** 2018蜜柚 [#B]                                              :@NCEPU:crypt:
-----BEGIN PGP MESSAGE-----

hQEMAw7kGOoigxp9AQf/XBsInzg7gs0BpbKJSveAFzNQUU1t2TcaWdkeM98M5dQb
FV3bU/kskHWyKBDIs7BcKn6QZlVpe7BsqVyOOBvspPF1l7/yU9QUGSVbqU6xYOXp
CSuXE7tvhoZMJoR3xm9YD0zq2nAxKp7yi6WIkV6ViTfzbJcoLhpMcosR+MgQ4hMa
0SESfMM2W32tYF0SvXDd9QiwiZWs7WROorgx/VGrmCAGiyvo2oq/dUgDwlVE6svG
BvWml/ga9lG7VovHUZzegBVfJm85L2k3GH5DlzaBsxFyFa1wvLMdyfIz9Emhmgsy
5SE2Bn+0xnTw+hAM+jShTEPnNOiU7C0/uKBRSChEutLqAWhYWKfgiJ/wseyUIGVq
xW31FRipDpT055tmsYGdiTsQTnNEkZBwJDdPfsQOIpS5G9zZZYxarvhyRkP79Tr1
CQtYlGomYW6R/dLy9gw/IuvlhIgPn2HEQyjchbKpp7d1Db+dSWd3e+Iz1LbxwD4/
kXDvUljz8tN2bpkj2Qv2kvWcphoTx/4V7j1CnD2XfuI942yAkWIQMUk39cxb2DnZ
P/sFNuUnKnQy9vuMNsJu3ah7LnW6EOxfyvtMBIsX+KkRkfOjpmf1GFpBAxoRU1ki
zsEP35hG+imMxeJJxeTUNcS2EW9uRXQYlzNxphskzWnnvVgEMLy22hUx7xuqBFQ/
lOvbRaT6BYwqDiNgBuFU7wBJYgEc8T92cRCG57AFMTiCvLlCMJ5kqk6qCKtcc1m3
D3JPNAR1P11YEAgspU/7pb3SZjwHQWHcwUI0lwah3bVlrgDiScwAnkBDiuoj7S/G
jmxCz9Olsp4Gi7Gvivy5GXvaVx6RoPL8WpTJKiuV1xw04itLamZfT/paGT8aJcBA
bwfP1MRfzMeZKjBg1QVPcKbubHrMbf28jpPuAgGs2NdYnrJ55CtZLafHgogcIMvq
Vy7eGfiONzPyz73D984ta8Zc/myPj4+RAccfKrwxrwV3dRe1rQEwaNPgaPy56TQt
UKyU2/mApUhJ4dLGdyalb9XgxfBTAX0jWW8yESNC8ouRhJQh9scHbIoNWISaBODR
dtK7kQ4BI3mtwmrVz64fBwmkCBx2D0QHfGw7gUrfNzn2gnwGX9QwDsfSTTYOhKEZ
88t84DK+BptSReR2HEmg1sF1n3Iy/1JYFmYrSUZDiTbvFx3XF90OOMZu7+8J1jKE
n/v2qxQMTd1lL48t0G3RMHmlddV2Tsx+1sx3updWhRJASWuL2Mnxni0Xg0nxwVIh
okvMrk9RGbhvsTJ92SwsgxQS3608bcwdxh3i/THvIpHW/C42/ld/1jVGGvlpCP/H
bD6K26qQWu/UglNdKR1eJuCYQLvnkY0/utmgu02GaD4KFYWobvddJt/DNrzeqCnP
DAbqyHH3I74p6O4DWf2uJrkvAoVV5/BRl4SRN+V36/Yu0OxIeBypeGrNCzjFT4El
2QoI7d6HflU3rTTbRwvmS+ZrO17i8yXvpFITWKuZc0MsMPG7D+mh56BXBM95xmLi
nf0mhll5ldZZXBRJCps+IA5y89GbH2vMN+jAyfBqOyM2uy7OYTOXNgYqRZxPOMDb
o/85tGcNu6dYniZRDUmRs53VT+lQVeynvzLzRR8Q2ByVlAxw+PDslGgsHHb9RtnB
oqTe1AZTb82UhtMXSAGjxVZQqNtgcAZRdAX10AfYGfihxc9W+eaDaAP/dXpojp6V
k1EuFUJFgz/xcG9L36viIp7wzMGhBZilk5BOR5fmp6rCmAcHBXacoyQzUAxhpv8W
G8tTDA025cCaZeNbDcUcDI0a/iVE4dn2LqubHaHNJhBuKx8=
=seTR
-----END PGP MESSAGE-----
** 计算机程序技术 [#B]                                            :@Company:
:LOGBOOK:
CLOCK: [2018-09-22 周六 16:11]--[2018-09-22 周六 17:01] =>  0:50
:END:
                         Added: [2018-09-22 周六 16:11]
                         
                         
                         
第一步： 读COSMaC ELF http://www.cosmacelf.com/publications/books/short-course-in-programming.html 
      最好自已试着实現它的 emulator，以了解计算机原理和汇编
第二步: 再把 http://www.cs.utexas.edu/users/boyer/acl.pdf (400页)和一些papers http://www.cs.utexas.edu/users/moore/publications/acl2-papers.html#Books
第三步: 看看The Scientific Computation System http://www.axiom-developer.org/axiom-website/books.html 主要是源代码 
 并学会它们的用法，以了解逻辑和数学，再开始看第一卷
相比之下，Maxima (Axiom 也是用 Common Lisp 写的 CAS，但实际上技術含量远高于 Maxima)，PlantUML，Emacs Lisp 涉及的內容太 trivial 了

The art of computer programming(TAOCP)一直在更新

https://www-cs-faculty.stanford.edu/~knuth/taocp.html

量子计算的博文，和现在的编程技术貌似有很大的区别

Computer-Aided Reasoning 5 是 A Computational Logic 的续作，后者并非是 ACL2 而是其旧版本，
但大部分通用而且是 Public Domain 的，前者并非免費且定价挺高(不過 Appendices 可以免費看，是个简要使用说明，还比較有用)，
是不是要看就看个人意愿了。

http://www.cs.utexas.edu/users/moore/acl2/current/combined-manual/?topic=ACL2____BOOKS-CERTIFICATION
真要說的話 ACL2 超过了 TAOCP 的內容，但我也只是指望你能过一遍，这樣的好处在于：

看到 TAOCP 中偏向数学和逻辑的部分不会立马懵逼。
不会再产生「学会这个有什麼用」的问題。能解決几亿美圓问題的工具会沒用？
TAOCP 中的一些习題用 ACL2 做可以减少心智负担，也就是說你知道 ACL2 怎么工作，然後能用 ACL2 证明就代表你会做这个证明，
而不用亲自去做证明，which 对习慣写代碼的人很伤。


PVS 和 HOL是Higher Order Logic,  ACL2 是 first class logic。
Higher Order Logic 通常涉及 type theory，建议深入学习 Haskell 或 Standard ML 或 Ocaml 中一個再去了解。
Knuth 的书并沒有涉及 Higher Order Logic，而且使用 high order logic 的 proof assistant 自动化程度并不高，总之对于看 TAOCP 沒有太多帮助。



1. TeX 是一个偏向于美学的工具，能从中受益的基本是字体设计和排版方面的从业者。TeX 宏语言也算不上多好的编程语言，
   甚至可以当作编程语言设计和软件项目管理的反面教材。
2. LaTeX 只是一个封装，就算熟练使用它也不见得需要对 TeX 有多少理解，Don Knuth 写了说明书 The TeXbook，
然而同上条所说，这本书讲的完全是排版上的美学，和符号更是完全不沾边
当然，花点时间学会基本的使用还是值得的。反正就是想学就学，不需要什么理由，实际上写几份 paper 基本就熟悉了

到今天我认为全世界顶级 Emacs 黑客中, 日本开发者的数量和顶级程度最恐怖.
IRC 里面有很多和 RMS 同样时代的日本 emacser.
包括当年和我一起开发 anything 的 rubkitch 也是牛逼的不行了, 用 600x480 的分辨率屏幕码代码.
就freenode里面的#emacs频道，有一些六十多岁的emacs开发者，简直牛逼的不行了



这种重构主要对语言支持比较好的情况, 比如Java, 非常成熟和安全. 但是对于那些脚本语言, 很难保证重构的正确性.

IDE 的 rename refactor 主要是对变量的重构比较方便, 有时候会进行一些代码级别复杂API重构,IDE就很难做到.

举个例子: 在项目中找到匹配某个正则表达式的行并进行 API 重新设计:

1. color-moccur.el 中进行正则表达式匹配, 找到整个项目中所有匹配的行, 而不仅仅只是一个变量
2. 在 moccur buffer 中按 r 进入编辑模式
3. 然后在 moccur buffer 中用 multiple-cursor.el 进行批量匹配编辑, 多光标改 API
4. 最后 Ctrl + C Ctrl + C 重构所有 API
这种级别的操作时, IDE 那种只是单纯的改变量和函数名称的动作就做不了了.
color-moccur。把相同文件名的聚合在一起，文件名单独一行，比较方便


现在IDE都做的不错, 只是不喜欢点鼠标, 点一下, 我就忍不住卸载了.
我装 IDE 的目的就是定期去模仿一下他们优秀的插件.
商业世界, 唯快不破.
IDE世界都是面向鼠标快速出产品的, 没人像 Emacs/VIM 这些黑客慢慢磨细节.

主要是要基于抽象语法树来做这些基础设施, Emacs底层是正则表达式, 这种东西在复杂场景一定都不靠谱.

可以使用ag.el, 搜索文件, 然后生成一个类似occur的buffer, 在里面开启wgrep, 就可以同样的操作了, 一直在用.

（很多都改用rg)ag.el: https://github.com/Wilfred/ag.el 3 wgrep: https://github.com/mhayashi1120/Emacs-wgrep 8

跟你说的操作方式很类似, 不过这两个有人维护.
** rg-color.el [#B]                                                 :@NCEPU:
:LOGBOOK:
:END:
                         Added: [2018-09-22 周六 17:01]
                         
https://github.com/manateelazycat/color-rg

https://github.com/dajva/rg.el    https://github.com/mhayashi1120/Emacs-wgrep
我只说差异吧:

rg.el 一旦改成分组模式显示分组, wgrep 就废了, color-rg.el 自己就包含了 rg.el 和 wgrep.el 功能, 不需要额外安装 wgrep.el
默认尽量少问问题, 快速搜索, 搜索后觉得需要缩小范围再动态过滤不想看的文件类型
默认智能的抓取当前光标处的单词, 而不仅仅是 symbol , 比如 CSS 的 class name, .foo 和 #foo 自动回转换成 foo 再搜索 (当然搜索之前都可以调), 避免大部分情况, 要各种删除 . 或者 # 才能搜索
如果正则表达式搜索错误以后, 会智能探测, 并用 literal 模式重新刷一遍 (这个 rg.el 没有)
如果搜索出来的东西需要全部从文件中删除, 直接 C-c C-D 行了, 具体的更多贴心命令看上面的 keymap 吧.
删除的地方是先标记, 最后 C-c C-c 再删除 filter 是过滤显示结果, 不是删除 替换操作就是 query-replace 操作, 当然也有那种全部一键替换的操作.

color-rg.el 的功能非常复杂, 我建议你尝试一下, 不喜欢就不用. 这样一个一个的问, 也没有直观的认识.


rg.el比ag功能还是多不少，看看顶部的几个toggles，运行时可以随时切换，不必全部从来一次。
 几个比较好用的命令：rg, rg-dwim, rg-project, rg-literal。 默认键绑定c-c s
 
在lsp(分层服务提供商)还没有成熟的时候，这种简单的重构工具还是挺常用的，经常用，用的ag.el，调用的命令是rg。
它的搜索结果buffer是基于compilation-mode，不太好定制，因为不是专门的major-mode，功能有一些局限，
比如不能记住搜索的关键词，不能在搜索结果里的关键词之间跳转，不能二次过滤和手动删除不想要的结果项。

二次过滤和手动删除，这个功能比较需要，喜欢的体验是类似dired的效果，可以先标记，再删除。
标记好之后方便检查一遍有没有标记错误，避免删错，如果能只显示标记项，暂时隐藏其他，这样更方便检查。还可以用搜索的方式来标记，也类似dired


https://www.emacswiki.org/emacs/color-moccur.el 19 color-moccur.el 的作用是搜索指定的目录, 然后按匹配的文件进行匹配行导航

如果要重构文档, 直接按 r 进入编辑模式 (类似 wdired 的感觉), 在 moccur buffer 编辑完成以后, 按 Ctrl + C Ctrl + C 就可以改动到实际的文件中.

十年前从一个日本人的 ftp 里面翻出来的时候都把我惊呆了, 这个插件是我这么多年开发必用的超级大杀器.

然后配合我写的 https://www.emacswiki.org/emacs/moccur-extension.el (已废弃，不用) 各种方便.

给一张霸气截图, 不要小看截图, 按照我上面的方法操作, 你们会震惊的
** languge server protocol(LSP) [#B]                             :emacslisp:
:LOGBOOK:
CLOCK: [2018-09-22 周六 23:20]--[2018-09-22 周六 23:22] =>  0:02
:END:
                         Added: [2018-09-22 周六 23:19]
 LSP (Language Server Protocol) 是微软领导开发的编程语言语法补全和代码分析框架, 
好处是全世界黑客都一起开发 LSP 后端, 不论你用的是 Emacs, Vim 还是 Sublime, VSCode,
 Elicpse, IntelliJ 等编程工具, 都可以享受同等智能的语法补全后端.                        
LSP-mode: Emacs client/library for the Language Server Protocol
https://github.com/emacs-lsp/lsp-mode 

lsp-mode provides a handful of hooks that can be used to extend and
 configure the behaviour of language servers. A full list of hooks is available in the API documentation.
 

https://github.com/joaotavora/eglot
** 美丽的git [#B]                                                      :git:
:LOGBOOK:
CLOCK: [2018-09-26 周三 16:45]--[2018-09-26 周三 16:46] =>  0:01
:END:
                         Added: [2018-09-26 周三 16:44]
                         


#+BEGIN_SRC bash
git log --pretty=oneline --graph
#+END_SRC
** what is a graph？ [#B]                                           :@NCEPU:
:LOGBOOK:
CLOCK: [2018-09-26 周三 20:26]--[2018-09-26 周三 20:37] =>  0:11
:END:
                         Added: [2018-09-26 周三 20:25]
                         

    A graph refers to a collection of nodes and a collection of edges that connect pairs of nodes.

Graph theory can be used to describe a lot of things,
but I'll start off with one of the most straightforward examples: maps.
You can think of graph theory as a way of encoding information about two aspects of a map:

1. places to go, and 
2. ways to get there.

Each land mass can be represented by a point, and each bridge is just a line between two points.

Hook is a tool  for connection as edge, a bridge, which let you cross the wide gap(river).
** 老一代技术 [#B]                                               :emacslisp:
:LOGBOOK:
CLOCK: [2018-09-28 周五 23:15]--[2018-09-28 周五 23:22] =>  0:07
:END:
                         Added: [2018-09-28 周五 23:15]
                         
CISC: 1964 IBM System/360
RISC: 1960’s, various
SIMD: 1966, ILLIAC IV
GPGPU: well, it’s only meaningful after the definition of GPU came up, so just don’t count it. In fact there’s no difference to SIMD.
FGPA: 1982
TPU: it’s one instance of ASIC, which can be dated to 1981
Container: 1979, Unix V7
Distributed: 1960, ARPANET
AI: 这个不用多说了，ML 理论基础都是老早的了。传统 AI？ARPANET 就是用来做这个的。
IoT: 1985

现在的操作系统也懂得跟着进化，容器化、分布式、实时操作系统，为大数据、AI、IoT提供支撑。
如果你没有做过十年以上的操作系统的开发, 请不要借用朋友圈烂大街的理论去评论别人.

https://github.com/manateelazycat/emacs-application-framework

这个世界总有那么多人, 不懂得谦逊, 自己学的越多自己发现自己就是傻逼, 只有学业不精的人才有闲暇时间去浪费自己和别人的时间, 他们从和别人的争论上显得自己很牛逼.

每个人这一辈子就是傻逼的过这一辈子, 如果没有自知之明的好好学习, 只会无聊的和别人争论, 指点江山, 真的很可悲.

你想要社区版, 那是你自己的想法, 你觉得操作系统应该怎么做, 那是你自己的事情. 请不要去假设别人一定会按照你的想法做, 也不要假设别人的想法, 更不要去评价你根本不了解的事情和人.

我已经离开 deepin 了, 不要再和我讨论 deepin 和操作系统的事情, 谢谢!

http://lambda-the-ultimate.org/node/5335
当然现在很多程序员都是改配置，改插件，真正内核的、部件的东西不会涉及，比较少涉及核心的算法东西。
    According to Sussman, his students spend most of their time reading manuals for these 
    libraries to  Recent comments  figure out how to stitch them together to get a job done
    
现在大部分程序员做的工作，1.装插件 2.阅读插件帮助文档 3. 修改配置文档
    
1. computer graphics
2. computer vision
3. graph theory
4. set theory
5. robotics
6. embedded system
7. category theory
8. mathematics
9. What is the fixed point? and why it matters? ----the solution of the problem inside the domain specific language
10. Automate theory
11. Turing Completeness
12. Program language theory/ Lambda theory(PLT)
13. Hardware infrustrument


Languages provide abstractions (does anyone still recall the    
   data abstraction/procedural abstractions/control abstraction    
   typology?). Consider how people studying SICP knew about    
   lazy data-structures (streams) when this was something    
   mainstream programmers weren't thinking about. And how    
   about Luke's reminders about Thinking Machines LISP and    
   so forth. 
   
*** a Compiler is an arrow?
This is simply not true, or true at the level "a compiler is an    
   arrow." I am not interested in people who can explain to me    
   that compilers are arrows, I am interested in people who can    
   explain how to implement compilers. Neither is there anything    
   in category theory which helps you study set theory or    
   different logics particularly well.    
   
我认为是对的。
它是一座桥梁,字符的桥梁，通往逻辑殿堂，走向物理本质.


Apart from that, I think most CS students are better of with    
   general knowledge of applied math than foundational issues.    
   Dijkstra once pushed an agenda that programmers should be    
   able to prove everything, hence CS adopted the foundational    
   research from the mathematicians.    
       
   But history seems to have taken another course than that    
   what Dijkstra envisioned. Math is still important, a computer is    
   an expensive calculator, but I am not sure CS students are    
   better of being able to implement fluid dynamics simulators    
   than anything else. Seems more relevant than being able to    
   reproduce the Hilbert program.    

    http://lambda-the-ultimate.org/node/5335

 The route probably was that a popular FP construct was    
    given a categorical underpinning. It usually goes that    
    way. And I always found the categorical underpinning of    
    monads nonsensical. But I guess that's known on this    
    site, and I forgot half the reasons why.    
       
   This is not right. The history goes roughly as follows:    
       
   1. Godemont invents monads in 1958, under the name    
   "standard construction".     
       
   2. In 1963, Bill Lawvere applies them to model constructions    
   in formal algebra -- basically, he works out how to use    
   monads to model substitution in theories of languages    
   without binders, like the formal language of monoids, groups,    
   and rings.     
       
   3. In the late 1960s (roughtly 1968-1969), Dana Scott and    
   Christopher Strachey invent denotational semantics. Initially,    
   they work in very concrete models of languages (Scott's    
   D-infinity model of the lambda calculus was initially defined in    
   terms of complete lattices and continuous functions, and then    
   weakened to CPOs).     
       
   4. Throughout the 1970s, denotational models of more and    
   more effectful languages -- state, control, concurrency, and IO    
   -- are invented.    
       
   5. As the complexity of the languages under study goes up,    
   people begin using a variety of semantic structures -- not just    
   lattices and domains, but also metric spaces and so on. To    
   organize the structure common to all of these approaches,    
   people begin using categorical methods. Michael Smyth and    
   Gordon Plotkin's 1982 paper The Category-Theoretic    
   Solution of Recursive Domain Equations is a good example    
   that remains relevant to this day. (I learned how to solve    
   domain equations from it, in fact.)     
       
   6. In 1989, Eugenio Moggi recognized that there was a    
   common structure to how effects are modelled in semantics    
   -- namely, monads -- and showed how this worked for a very    
   wide variety of effects.    
       
   7. Shortly after publication of this work, Phil Wadler    
   recognized that Moggi's semantics could be used to replace    
   Haskell's IO system (which had a very clumsy CPS-based    
   API), with a much simpler monadic API. See his 1992 paper    
   The essence of functional programming. This led to the    
   adoption of monadic IO in Haskell 1.3, in 1996.     
       
   8. In his PhD thesis, Andrejz Filinski proved a representation    
   theorem for definable monadic effects -- he proved that    
   delimited continuations (or alternately, full continuations plus    
   state) could be used to implement and definable monadic    
   effect.    
       
   9. Shortly after the turn of the millenium (2001-2003), Gordon    
   Plotkin and John Power proposed using Lawvere's idea of    
   modelling substitution on trees with monads to turn an    
   algebraic theories of effects directly into a categorical    
   semantics of effects.     
       
   10. A few years later, Matija Pretnar (first with Gordon Plotkin    
   and then Andrej Bauer) made use of Filinski's representation    
   theorem for effects to invent "effect handlers". The idea was    
   that you could separate the definition of an effect from its use    
   by client code, and dynamically control how effects get    
   implemented. See Sam Lindley, Ohad Kammar and Nicolas    
   Oury's 2013 paper Handlers in Action.     
       
   So far, the theory has preceded the application, not just    
   once, but *twice*. Furthermore, I'm pretty sure this will happen    
   at least once more -- in his work on call-by-push-value, Paul    
   Blain Levy has shown how the decomposition of a monad into    
   an adjunction naturally splits semantics into a living in a pair of    
   categories, one for values and another category of algebras    
   for effects, which is sure to shape the design of the next    
   generation of functional language.    
       
   By neelk at Wed, 2016-05-18 09:58 | login or register to    
   post comments    
    
   *** lambda closure is acually 吸水的海绵

   *** merge physics intuition into math,and computers

I'm old enough to remember the pre-6.001 intro to computer    
   science at MIT, so I may be biased, but it was a truly brilliant    
   innovation, especially once they got rid of the vestigial bit of    
   Algol programming mandated by the department. It definitely    
   taught you a new way of looking at complex problems and    
   behaviors, and provided you with a toolkit for figuring out how    
   to solve those problems and emulate those behaviors.    
   Deceptively simple at times, like the classic and thin G Polya    
   book How to Solve It.    
       
   I'm a bit worried about suggestions that we need to simplify    
   or temporarily replace essential parts with substitutes, and    
   then teach those essential parts later.    
       
   All I can think here is that I took elementary mechanics twice,    
   once without calculus and once with, and it was so much    
   simpler once you had the right math to describe what was    
   going on with the physics. And conversely, it was easier to    
   understand the calculus when you had some physical intuition    
   to base that understanding on. The same is true in    
   crystallography which is a bitch without linear algebra but    
   almost frighteningly simple with it.     
       
   Turns out that it's often a big win if you can teach two subjects    
   together, and that if you can't, you end up teaching much of    
   the material twice.    
       
   Any possibility that we can combine more of the underlying    
   math bits with the "computer science" bits at the same time?    
   Here's where I need to put on my "Just another dumb    
   engineer" hat, and will leave the best sequencing and    
   combination of these subjects to the experts.    
    
** 王勇emacs-china [#B]                                          :emacslisp:
:LOGBOOK:
CLOCK: [2018-09-28 周五 23:36]--[2018-09-28 周五 23:46] =>  0:10
:END:
                         Added: [2018-09-28 周五 23:35]
                         

https://emacs-china.org/
          
*** Emacs的生态理解而言              
https://github.com/manateelazycat/emacs-application-framework
通过 python/qt 补强了 Emacs 的图形性能不足, 又保持不对核心 elisp 生态的侵入, 在保证现在 elisp 生态持续发展的基础之上, 拓展 Emacs 的图形渲染能力.

重新用 Qt/Gtk+ 做一个 Emacs 不会成功的, 原因主要是, 不论图形性能多么强大的编程语言, 都没法替代 Lisp 语言对编辑器核心的
高速开发的能力, 更无法替换几十年 Elisp 黑客的巨大插件生态.
elisp生态的力量太强大了，elisp外围插件是全球黑客几十年的结晶。
https://emacs-china.org/t/elisp-emacs/5100/126
*** color-rg

https://emacs-china.org/t/ripgrep/6833

https://emacs-china.org/t/topic/6313/94

https://github.com/manateelazycat/color-rg

*** insert-translated-name

https://github.com/manateelazycat/insert-translated-name

https://emacs-china.org/t/emacs/7098/33

*** magit-submodule-remove

https://emacs-china.org/t/submodule/6926/7

*** awesome-tab

https://emacs-china.org/t/awesome-tab-1-0-emacs/7053

https://github.com/manateelazycat/awesome-tab
*** Emacs Application Framework(EAF)
https://www.jianshu.com/p/3ebbfa41248c

Emacs Application Framework 的目标
增强Emacs的图形化能力, 所有需要高性能图形绘制的功能都用EAF来实现
让Emacs专注于文本编程环境的开发, 并保持 Elisp 现有的生态不会因为引入图形化功能发生重大的变化
通过增强Emacs的图形化插件来获得现代IDE的很多能力, 使得Emacser能够永久的生活在Emacs中.


https://www.emacswiki.org/emacs/AndyStewart

** 孙膑斗庞涓 [#B]                                                    :学术:
:LOGBOOK:
CLOCK: [2018-09-29 周六 16:43]--[2018-09-29 周六 16:47] =>  0:04
:END:
                         Added: [2018-09-29 周六 16:43]
                         

                         
岳武穆大破金兵

如何迷惑别人，虚假结合

以多胜少
                      
孙膑斗庞涓，边走边扔装备带、子弹、锅盔等，目的迷惑敌人，
这是大部队，把敌人引向别处。


但是有时候就应该不能撤退?
比如日本攻南京城的时候，真正士兵没法撤退，没法投降，
只能顶上去，这是必死之境地，但依然不能退，退则生灵涂炭。

** 老实人 [#B]                                                      :@NCEPU:
:LOGBOOK:
CLOCK: [2018-09-29 周六 17:21]--[2018-09-29 周六 17:21] =>  0:00
:END:
                         Added: [2018-09-29 周六 17:16]
                         

                         
就是一类没胆没主意的人？

要有idea和brave的老实人

老实人的做着本分的工作，但又不是让别人觉得难事，而是能够让人尊敬的事情
忍耐！坚持到底，水滴石穿!
** turbulent intensity for turbsim [#B]                               :学术:
:LOGBOOK:
:END:
                         Added: [2018-10-02 周二 08:37]

I know that the turbulence intensity is the standard deviation /mean value of a time series of
U component at a specific point.
** sectioning and organization [#B]                              :emacslisp:
:LOGBOOK:
CLOCK: [2018-10-03 周三 09:39]--[2018-10-03 周三 09:39] =>  0:00
- Clocked out on T:[2018-10-03 周三 09:39] \\

  Below I break down a discussion of features as I found them when I was considering each package.
  Since all of the software I consider is under rapid development, my discussion
  may be dated or incomplete. I divide my discussion into several groups. The first group described
  in Table 1 covers features for writing latex or in some cases markdown code for
  adding text narratives to your document. The features I am interested in are \(LateX\) math, previewing equations for debugging, sectioning and document organization, referencing
  and footnotes, etc. One of the most important features here is the quality of the pdf output. It is a subjective consideration, but for my purposes I am referring to how close the output is
  to a submission ready manuscript (or blog post).
http://rlhick.people.wm.edu/posts/reproducible-research.html#fnr.16

:END:
                         Added: [2018-10-03 周三 09:39]
** 为什么总是会忘了什么？(10s) [#B]                                  :@Home:
:LOGBOOK:
CLOCK: [2018-10-04 周四 09:50]--[2018-10-04 周四 09:53] =>  0:03
:END:
                         Added: [2018-10-04 周四 09:49]
                         

忘记该做的事情

为何不闭上眼睛(10s)钟，仔细聆听你的心声，让所有事情在你的脑海里面过一遍。

在你准备付诸行动之前，一定得记住这个10s
** 口臭 [#B]                                                      :@Company:
:LOGBOOK:
CLOCK: [2018-10-06 周六 12:30]--[2018-10-06 周六 12:30] =>  0:00
- Clocked out on T:[2018-10-06 周六 12:30] \\
  鲁迅曾说过，人有四件事藏不住
  
  咳嗽、贫穷、喜欢
  
  还有口臭
:END:
                         Added: [2018-10-06 周六 12:30]
                         

                         
引用名人名言瞎说,不好！
口腔内的细菌生态平衡就会被打破

滋生出大量的厌氧菌

发出浓烈的臭味

这时，就会形成口臭
** pyqt [#B]                                                        :python:
:LOGBOOK:
CLOCK: [2018-10-06 周六 12:59]--[2018-10-06 周六 12:59] =>  0:00
- Clocked out on T:[2018-10-06 周六 12:59] \\
  Python 是一个完美写Qt/Gtk的语言，而且Python可以直接调用很多线程的库，可以在短时间内极大的扩展emacs的能力。 就像上面的文件名类型判断， 一个 pymediainfo, 几行代码就搞定了。
:END:
                         Added: [2018-10-06 周六 12:59]
                         
   https://emacs-china.org/t/topic/6199/60                      
我们想不到，是因为我们对 emacs 和 xlib 等底层信息了解的不多，所以我们就不会产生这种想法

不断追逐底层的过程，你才会发现能做的事情很多，完全架空干起来就没干劲，要有专研的精神。


eaf 是用来开发 GUI 的应用程序，为了无缝集成应用程序，做了很多框架性的东西，比如事件伪造和转发，窗口混合，窗口管理等工作。

如果要做一个Company的东西，非常简单，一个PyQT5窗口，然后 xlib reparent 粘贴上去，给 
elisp post-command-insert-hook 加一个 hook ,PyQt5窗口跟着光标一动就可以了。

GUI版的下拉框太简单了

Emacs 需要的是分屏以后，可以快速组合不同的 mode 的buffer进行协同工作。

如果只是一个控件嵌入，没法提升Emacs的协同作战的能力

换个靠谱点的包管理器，比如 nix 。
brew 主要都是些 Xcode 用户在用，社区基本没有跨平台开发者。
哈哈哈，在Mac这么封闭的平台上居然可以要我玩 Nix , 哈哈哈哈，好欢乐啊。

nix 你玩过吗？确认可以解决我上面的问题吗？


话说有一个 xelb 的库, 可以通过 elisp 和 xserver 进行通讯.

不管什么编程语言, 都是再向 xserver 发送消息,所有的绘制都在服务端, 并通过显卡进行图层硬件混合的.

作为使用十几年的Linuxer, 我个人感觉, Mac 在保护系统稳定的架构设计和应用生态还是非常好的,
 比较适合开发商业程序和不用涉及底层的程序.
 
涉及到要定制操作系统方面,就很麻烦了,什么都不能改.理性看待 Mac, Mac 现在的现状可是所有Linux 发行版都没有达到的高度


再给你们打个预防针，Mac的硬件质量也非常糟糕．

我用过４台Mac, 有两台电池鼓包（是很大的那种，大到把机器整个给撑裂了）

还有一台用了不到三个月，键盘，触摸板完全失灵， 去保修的时候还是很大方的， 
好像出了主板都换成新的了，可惜没过３个月又都坏了， 应该是设计问题， 还
好我一直是用外接键盘． 后来一直撑到多苹果失去信心．．．下决心换了Linux

Mac现在就是做消费品了…但是它消费品做的体验就是好，消费者不需要折腾。

方便的话请在项目里面加个 requirements.txt，这样 python 的包有添加的话，pip install 下就可以了
然后我发现 pdf 用了 poppler 这个东西，又得装一堆库，有方便些的办法吗？


已经用 mupdf 替换 poppler 重写 pdfviewer 了： 
https://github.com/manateelazycat/emacs-application-framework/commit/bb5983b47203b03187b262b7353f470e0cdfa961 

现在只用做 sudo pacman -S python-xlib python-pyqt5 python-pymediainfo PyMuPDF 就可以安装全部依赖了，不用自己编译。

等我把 QWebEngine 折腾好， 所有依赖都可以用 pip 搞定。


mupdf 果然比 poppler 快很多，现在的速度应该是 emacs 里面渲染性能最高的 pdf 阅读器了。


如果往好的方向上想, 苹果是最早做窗口混合的图形桌面环境的,所以底层一定有这样的接口.

如果往坏的方向上想, 苹果不让开发者定制它的窗口管理器,就是有接口估计也够不着.

所以等我以后,好好学习苹果的图形开发库以后,看看有没有线索吧, 现在只能在我的另外一台linux电脑上开发了.


You need split emacs first, then edit in Emacs, markdown previewer will update once your save markdown file.
** Build Server Protocol(BSP) [#B]                                  :@NCEPU:
:LOGBOOK:
CLOCK: [2018-10-06 周六 22:13]--[2018-10-06 周六 22:18] =>  0:05
:END:
                         Added: [2018-10-06 周六 22:12]
                         
又注意到一個新奇的玩意兒，Build Server Protocol

https://github.com/scalacenter/bsp/blob/master/docs/bsp.md

The problem this document aims to address is the multiplied effort required to
 integrate between available language servers/editors and build tools. Currently,
 every language server must implement a custom integration for each supported 
build tool in order to extract compilation information such as classpaths,
 source directories or compiler diagnostics. Likewise, new build tools are 
expected to integrate with all available IDEs. The growing number of language 
servers and build tools in the wider programming community means tooling developers
 spend a lot of time working on these integrations.

 

The Build Server Protocol aims to define common functionality that both build tools (servers)
 and language servers/editors (clients) understand. This common functionality enables tooling
 developers to provide their end users the best developer experience while supporting build 
tools and language servers with less effort and time.
** Emacs Application Frame(EAF-Ubuntu) [#B]                      :emacslisp:
:LOGBOOK:
CLOCK: [2018-10-07 周日 18:40]--[2018-10-07 周日 18:55] =>  0:15
CLOCK: [2018-10-07 周日 17:08]--[2018-10-07 周日 18:25] =>  1:17
- Clocked out on T:[2018-10-07 周日 18:25] \\
  ** 何为势？
     
  造势，看出势之所在。
  柔不是弱，而是含，收，容。 
  
  太盛则折，太弱泽泻
  
  阴阳，有用
  
  造势妙哉奇迹，千变万化中，对方一动，势就可以入，就可导。高手你入他很难，这就要损
  
  损她一个子儿，损自己一个子儿，先导开，或找眼钉下，止住他的入势，铺排下自己的入势
  
  这时你可不可死损，势式要相机而动。势式有相因之气，势套势，小势开导，大势含而化之。
  
  根连根，套可以算出百步之远，但无势，不成气候！
  
  为棋不为生，为棋是为养性，生会坏性，所以生不可太盛。
  
  棋盘上无非是道同势不同，天下可不一样，子儿都不全摆上，棋就没法下了。
:END:
                         Added: [2018-10-07 周日 17:08]

     sudo pip install dbus-python PyMuPDF grip qrcode pyqt5 python-xlib                     
     
*** dbus-python
提示：No package ‘dbus-1’ found 
安装：$sudo apt-get install libdbus-1-dev

提示：No package ‘dbus-glib-1’ found 
安装：$sudo apt-get install libdbus-glib-1-dev

---------------------

*** pyMupdf

apt-get install mupdf
apt-get install fitz(后来改为pip3 install fitz 还是不行)
apt-get install libjbig2dec-dev
apt-get install libjpeg-dev
apt-get install libfreetype6-dev
apt-get install libopenjpeg-dev

pip3 install pyMupdf
*** grip

pip3 install grip
*** qrcode

pip3 install qrcode
*** pyqt5

*** python-xlib

pip3 install qrcode
** All is well [#B]                                                 :@NCEPU:
:LOGBOOK:
CLOCK: [2018-10-07 周日 21:01]--[2018-10-07 周日 21:02] =>  0:01
:END:
                         Added: [2018-10-07 周日 21:01]
                         
All is well（一切顺利) A li zi ben

世上无难事-----会变好的
** 很多人都想知道未来会怎么样？(势) [#B]                              :学术:
:LOGBOOK:
CLOCK: [2018-10-07 周日 21:25]--[2018-10-07 周日 21:32] =>  0:07
:END:
                         Added: [2018-10-07 周日 21:25]
                         
                         
1. 预测
2. 知道一个人最后的发展趋势，他会不会比别人出色
3. 但是真的能够找到将来的自己？
4. 每个人都具有反思过去的能力，一个人拥有的是过去和现在，可以发展的是将来
5. 所有预测结果都是相信会变好，结果是越来约好的
   
未来是什么样子？只有一些个别人知道，你就知足吧，吃好，睡好，码好，写好，足矣。

人这辈子，总得有点儿有意思的东西。

让你的生活多添点乐趣funny。

未来由势所生，由势所运，运势而生，既得未来。
**  [#B]  剑和剑道的相互结合                                        :@NCEPU:
:LOGBOOK:
CLOCK: [2018-10-08 周一 11:34]--[2018-10-08 周一 11:40] =>  0:06
:END:
                         Added: [2018-10-08 周一 11:34]
                         
花更多的时间去学习新的技术和陪伴家人, 而不是无穷无尽的折腾 Emacs, 
折腾Emacs而不学习高深的技术, 就像一个永远只会淬炼刀剑的却没有时间
练习剑法工匠一样, Emacs这个工具始终是为了探索好奇心服务, Emacs本身不应该成为学习的目标

手中有了一把剑足矣，接下来就是用这把剑探究各种剑法，而不是老磨剑。

要识别出来你现在看的东西哪些是工具的内容，哪些是剑法、枪法、功法的部分(道)

最后你一定要学会 Elisp 编程才会把Emacs这把屠龙刀打造的尽可能顺手(不是每个人都能使用屠龙刀)

剑在手，含而化势，只为披荆斩棘，还一方净土。
所向披靡，屠尽天下又何妨，非吾愿。

https://emacs-china.org/t/emacs-melpa/7256
** tufts [#B]                                                         :学术:
:LOGBOOK:
CLOCK: [2018-10-08 周一 19:28]--[2018-10-08 周一 19:29] =>  0:01
:END:
                         Added: [2018-10-08 周一 19:27]
                         

                         
The main forces acting on tufts glued to a rotating blade.(aerodynamics and centrigugal forces, the latter
causing the tuft orientation to be biased radically outboard
** 法治社会 [#B]                                                    :@NCEPU:
:LOGBOOK:
CLOCK: [2018-10-10 周三 15:19]--[2018-10-10 周三 15:20] =>  0:01
:END:
                         Added: [2018-10-10 周三 15:19]
                         
非法制社会（刀制)

得水治


市场经济面前就是产权明确，公买公卖。
** 阿兹海默症 [#B]                                                  :@NCEPU:
:LOGBOOK:
CLOCK: [2018-10-10 周三 16:27]--[2018-10-10 周三 16:29] =>  0:02
:END:
                         Added: [2018-10-10 周三 16:27]
                         
要关注身边的亲人、老人 脾气，脾气暴躁是不是得了抑郁症，还有阿尔兹海默症（老年痴呆)

脑里多了点东西
** Awesome shell [#B]                                            :emacslisp:
:LOGBOOK:
CLOCK: [2018-10-11 周四 02:24]--[2018-10-11 周四 02:25] =>  0:01
:END:
                         Added: [2018-10-11 周四 02:24]
                         
https://emacs-china.org/t/aweshell-1-0/6676


Emacs中执行终端命令, 最近看见大家都在折腾 EShell, 晚上花了一个小时写了一个 Aweshell 141

Aweshell 基于 eshell, 希望提供一个开箱即用的 eshell 使用环境, 下载下来就可以使用, 不用浪费时间折腾.

主要的增强功能有:

像 MultiTerm 一样对 eshell 进行多bufffer创建和切换功能
添加了一些方便的函数, 比如 clear buffer, toggle sudo , 感谢 @Samray
默认集成 eshell-prompt-extras.el , 提供长路径缩写, git分支, 远程shell等状态增强, 类似oh-my-zsh的效果
默认集成 esh-autosuggest.el , 提供类似 Fish 的历史命令补全功能, 包括对 bash/zsh 历史的补全
实时检查命令是否有效, 并对无效命令/别名提前进行高亮显示, 避免执行后发现敲错字符, 感谢 @casouri
eshell更改目录的时候, 同步更新 buffer name, 感谢 @casouri
通过集成 exec-path-from-shell.el 来修复Mac下 eshell 报 “Command not found” 的错误, 主要是 /usr/local/bin/ 等路径没有导入 eshell path
内置一些方便的别名: f (find-file), fo (find-file-other-window), d (dired), ll (list files)
添加 git 命令的补全支持
集成 eshell-up
unpack 命令可以直接解压压缩文件, 不用记住那么多解压命令
命令敲错的时候, 显示 didi you mean 的帮助
cat 命令的输出有语法高亮
后台命令完成或终止时提醒用户
默认按键:

Ctrl + L : aweshell-clear-buffer
Ctrl + Shift + L: aweshell-sudo-toggle
Ctrl + H: company-complete-selection
** 10projects in 2018 for  python [#B]                              :python:
:LOGBOOK:
:END:
                         Added: [2018-10-11 周四 10:32]
                         
https://prettier.io/docs/en/browser.html

prettier


https://github.com/DiegoVicen/som-tsp


important!
https://github.com/donnemartin/system-design-primer


好好学算法
https://github.com/keon/algorithms


面部识别
https://github.com/ageitgey/face_recognition

video
https://github.com/NVIDIA/vid2vid


pipenv

pip和virtualenv的结合
https://github.com/pypa/pipenv
** what it is? [#B]                                                 :@NCEPU:
                         Added: [2018-10-12 周五 09:49]
                         
                         
*** Launch or background?

*** Project development

*** Conclusion
** decorate table in org-mode [#B]                               :emacslisp:
:LOGBOOK:
CLOCK: [2018-10-12 周五 16:07]--[2018-10-12 周五 16:07] =>  0:00
- Clocked out on T:[2018-10-12 周五 16:07] \\
  done it
:END:
                         Added: [2018-10-12 周五 16:07]
                         
                         
https://emacsnotes.wordpress.com/2018/09/24/delim-col-a-handy-tool-for-creating-pretty-tables-and-converting-those-to-different-table-formats/
** 平常心面对(倒过来) [#B]                                          :@NCEPU:
:LOGBOOK:
CLOCK: [2018-10-13 周六 01:14]--[2018-10-13 周六 03:45] =>  2:31
:END:
                         Added: [2018-10-13 周六 01:14]
                         
https://www.youtube.com/watch?v=BOgH6sZJX5w

周润发：
1. 倒过来想着人生， 年轻时候，吃得苦越多，年老的时候就会比较轻松
   反而年轻时候越轻松，年老的时候越难受, 倒过来想问题. 能够倒着过来
   想问题，太不容易了
2. 这个问题对我有什么关系？ 最重要的是告诉自己， 你的内心里面有很多个
   自己，因为也许有些人可能想了解你的背景，你的敌人。 周边的人，你对着
   他哭，对他讲故事没什么用,还不如多吃点苦，多干点有用的工作。 
   中国人老是不开心，应该把这个世界看得更美些
   人生不开心的8,9，为什么不享受1,2呢！
3. 正常的人自拍的人只能露8个，周露12个以上
4. IQ不是一切，EQ才更重要，EQ是情，EQ要落地!感受民众,接地气

EQ高比IQ高來的重要 心裡的委屈是告解另個自我  要活在一二不要活在不如意八九 當個平凡人 心自在




我应该回复到会笑的那个阶段


1. 换位过来, 站在对方角度进行倒序过来
2. 倒序过来, 所有相互之间的基本过程
** 撇开成本说新能源都是耍流氓 [#B]                                    :学术:
:LOGBOOK:
CLOCK: [2018-10-13 周六 03:58]--[2018-10-13 周六 03:59] =>  0:01
:END:
                         Added: [2018-10-13 周六 03:58]
                         
                         
成本+ 可持续发展必须都得考虑。

我突然喜欢能量转换了
** 科技的发展让人越宅 [#B]                                          :@NCEPU:
:LOGBOOK:
CLOCK: [2018-10-13 周六 15:39]--[2018-10-13 周六 15:43] =>  0:04
:END:
                         Added: [2018-10-13 周六 15:39]
                         
                         
三个方向， 信息技术，核能，航空技术，往外发展的核能和航空技术反而没怎么
发展。反而是计算机信息技术越来越发展，也就是越宅发展的越多


先下手为强的原理是因为，人们的认识机制
人们对不熟悉的东西首先 先接受，认为是对的，等到某一天再回想起来，可能才会怀疑
而不是（我先怀疑，慢慢经过很长一个阶段再接受)
** 基数是什么? [#B]                                                 :@NCEPU:
:LOGBOOK:
CLOCK: [2018-10-13 周六 15:49]--[2018-10-13 周六 16:02] =>  0:13
:END:
                         Added: [2018-10-13 周六 15:49]
                         
                         
有多大的基数(分母)? 基数就是说某物体的总数量, 中国基数大
老年人基数也大!
你跟他讲政策，他跟你讲身份。你跟他讲比例，他跟你讲基数。

人总得被套一次，才能反被套
** 自我教养，自我调教 [#B]                                          :@NCEPU:
:LOGBOOK:
CLOCK: [2018-10-13 周六 20:41]--[2018-10-13 周六 21:10] =>  0:29
:END:
                         Added: [2018-10-13 周六 20:40]
                         
      https://www.youtube.com/watch?v=um_xKcji7kc                   


李健:

平常心，自己跟自己谈话才是最重要的。

要有自我警觉.  严于律己，宽以待人

当你向生活要很多东西的时候，你也等于失去很多东西。

30岁在这个时代很难立起来，也许40岁也不错。 30岁之前是父母的基因遗传
30岁之后得自己去把握，去改造，去修复和改善你自己的体质

音乐诗人，秋裤男神， 白马王子(白马王爷)
** 关你屁事 [#B]                                                    :@NCEPU:
:LOGBOOK:
CLOCK: [2018-10-13 周六 21:11]--[2018-10-13 周六 21:39] =>  0:28
:END:
                         Added: [2018-10-13 周六 21:10]
                         
                         
所以, 我以后写的任何代码和文章首先会让我自己觉得有趣我才会去写, 如果别人喜欢看我很高兴, 不喜欢看我也觉得很正常 (人和人本来就不一样嘛), 而不是仅仅只是让别人开心.

我一向以来崇尚的快乐大法:
https://emacs-china.org/t/emacs-melpa/7256/17

很多事情, 就是
关你屁事, 关我屁事
做点好玩的事情博得自己的开心最重要.(我做点自己喜欢的东西就好，李健)

我相信每个人只有让自己先快乐, 这个操蛋的社会才能进步, 哈哈哈哈.
And von Neumannn gave me an interesting idea: that you don’t have to be responsible for the world that you’re in.
 So I have developed a very powerful sense of social irresponsiblity as a result of von Neumann’s advice.
 It made me a very happy man ever since.
** fishc资源包 [#B]                                                 :@NCEPU:
:LOGBOOK:
CLOCK: [2018-10-13 周六 21:41]--[2018-10-13 周六 21:41] =>  0:00
:END:
                         Added: [2018-10-13 周六 21:39]
                         
                         
https://fishc.com.cn/thread-51842-1-1.html
** 只有你懂他，你才能写他 [#B]                                      :@NCEPU:
:LOGBOOK:
CLOCK: [2018-10-13 周六 21:54]--[2018-10-13 周六 21:57] =>  0:03
:END:
                         Added: [2018-10-13 周六 21:54]
                         
                         
Allow enough time:
  Before you can write about the research, you have to understand it.

Allot at least half the time that you spend on this assignment to reading and
understanding the article. Before you can write about the research, you have to understand it. This
takes more time than most students realize. Does the author's study make sense to you in lay terms
(could you explain the study to your roommate)? When you can clearly explain the study in your own
words, then you are ready to write about it. Here's how to proceed.

你用你自己的words来写，然后接着就是你用大家的words来写====这是一种方式

我们在文章中都有一些假设， 假设刚性！也是一种前提。
** 利用python imageio做gif动画 [#B]                                 :python:
:LOGBOOK:
CLOCK: [2018-10-15 周一 11:02]--[2018-10-15 周一 11:02] =>  0:00
:END:
                         Added: [2018-10-15 周一 11:02]
                         
                         
                         
需要配合上ImageIO

https://blog.csdn.net/guduruyu/article/details/77540445


https://blog.csdn.net/qq_24885695/article/details/70176386


解决乱序问题，事先对文件进行排序

字符排序
https://blog.csdn.net/Teeyohuang/article/details/79809652

数字排序
https://blog.csdn.net/ccpw_cn/article/details/51372122

shell解决方式

#+BEGIN_SRC python
  >>> files=os.listdir(".")
  >>> files.sort()
  >>> print files
  ['1.txt', '10.txt', '11.txt', '2.txt', '3.txt']
  >>> files.sort(key= lambda x:int(x[:-4]))
  >>> print files
  ['1.txt', '2.txt', '3.txt', '10.txt', '11.txt']



  files=['2.txt','1.txt','12.txt','18.txt','13.txt']
  print files
  ['2.txt', '1.txt', '12.txt', '18.txt', '13.txt']
  files.sort()
  print files
  ['1.txt', '12.txt', '13.txt', '18.txt', '2.txt']
  files.sort(key=lambda x:int(x[:-4]))
  print files
  ['1.txt', '2.txt', '12.txt', '13.txt', '18.txt']



  files=['2.md','1.md','12.md','18.md','13.md']
  print files
  ['2.md', '1.md', '12.md', '18.md', '13.md']
  files.sort()
  print files
  ['1.md', '12.md', '13.md', '18.md', '2.md']
  files.sort(key=lambda x:int(x[:-3]))
  print files
  ['1.md', '2.md', '12.md', '13.md', '18.md']
#+END_SRC
** 社会实践 [#B]                                                      :学术:
:LOGBOOK:
CLOCK: [2018-10-16 周二 16:56]--[2018-10-16 周二 16:56] =>  0:00
:END:
                         Added: [2018-10-16 周二 16:56]
                         
2015年10月,在内蒙古呼和浩特突泉县风电场实习，进行涡发生器和丝线相关实验; 
2016年4月,在山西偏岭风电场实习，进行叶片丝线实验和表面压力测量实验，现场拍摄叶片表面流动照片;
2016年7月~9月，在金风科技公司参与流场可视化算法和测量压力数据处理的软件设计
** learning express your english [#B]                         :EnglishPaper:
:LOGBOOK:
CLOCK: [2018-10-19 周五 20:13]--[2018-10-19 周五 20:14] =>  0:01
- Clocked out on T:[2018-10-19 周五 20:14] \\
  fine
CLOCK: [2018-10-19 周五 20:11]--[2018-10-19 周五 20:11] =>  0:00
- Clocked out on T:[2018-10-19 周五 20:11] \\
  fine
CLOCK: [2018-10-19 周五 14:43]--[2018-10-19 周五 14:43] =>  0:00
- Clocked out on T:[2018-10-19 周五 14:43] \\
  hi
CLOCK: [2018-10-16 周二 19:16]--[2018-10-19 周五 13:26] => 66:10
- Clocked out on T:[2018-10-19 周五 13:26] \\
  ok
:END:
                         Added: [2018-10-16 周二 19:16 +1d]
                         
That is important

Go over and over again

Form your independent vision


How to let your audience engaged with your title.
with subtle nerd comedy combined with a strong underlying understanding of the subject matter

Let it connect with function or with relation, make it useful
** 样本意义 [#B]                                                    :@NCEPU:
:LOGBOOK:
CLOCK: [2018-10-19 周五 13:26]--[2018-10-19 周五 14:43] =>  1:17
:END:
                         Added: [2018-10-19 周五 13:25]
                         
                         
同一阵容没有样本意义

合法迫害性（平时做了没问题 有问题了就得依法办理)

在税金流向如此不光荣的环境里， 没有感觉到一点点的光荣


一个企业对应一个ICP证

Ray-ban 太阳镜(雷朋太阳镜)
** 党员转正 [#B]                                                    :@NCEPU:
:LOGBOOK:
CLOCK: [2018-10-19 周五 14:43]--[2018-10-19 周五 20:11] =>  5:28
:END:
                         Added: [2018-10-19 周五 14:43]
                         
                         
                         
P14
支部大会讨论预备党员转正的主要程序是：
1.预备党员汇报一年来各方面的情况，特别是针对党支部接收预备党员大会上党员的意见进行改进的情况；
2.与会党员对预备党员能否转正进行充分讨论，并采取无记名投票方式进行表决。
讨论预备党员转正的支部大会，对到会人数、赞成人数等要求与讨论接收预备党员的支部大会相同。

** 需提交材料
存入本人档案。学生党员材料由基层党委保存
*** 1. 《入党志愿书》  

*** 2. 入党申请书【已有】

*** 3. 思想汇报

*** 4. 《入党积极分子培养考察表》【已有】

*** 5. 入党积极分子培养考察表【已有】

*** 6. 入党积极分子培训班结业证书

*** 7. 发展对象培训班结业证书原件或复印件

*** 8. 《征求党员、群众意见情况》 座谈会【已有】

*** 9. 政治审查材料【已有】 函调表等

*** 10.《预备党员教育考察情况表》

*** 11. 转正申请书

** 已准备
*** TODO 1. 转正申请书(一份, 手写)
:LOGBOOK:
- State "TODO"       from "DONE"          T:[2018-10-19 周五 16:05]
- State "DONE"       from "TODO"          T:[2018-10-19 周五 16:02]
- State "TODO"       from              T:[2018-10-19 周五 16:02]
:END:
*** TODO 2. 转正思想汇报(4份，手写)
:LOGBOOK:
- State "TODO"       from              T:[2018-10-19 周五 16:02]
:END:
**** 思想汇报3

#+BEGIN_SRC org
  华电: 

  深入学习党的十九大精神，以习近平新时代中国特色社会主义为思想为指导
  努力实现"2218"的发展目标  加快建设具有全球竞争力的世界一流能源企业
  全面落实新发展理念，努力实现高质量发展
  强化责任落实， 夯(hang)实安全环保基础
  深化改革创新  激发发展动力活力
  落实国家“一带一路”倡议，加快海外发展,推动公司最强做优做大
  坚持和坚强党的全面领导,推动全面从严治党向纵深发展
  http://www.chd.com.cn/webfront/webpage/web/contentPage/id/235bdda0e2534862b865db3d330b81c4
#+END_SRC

*** DONE 3. 接受预备档案党员备案名册(一份，xls）
CLOSED: [2018-10-19 周五 16:05]
:LOGBOOK:
- State "DONE"       from "TODO"          T:[2018-10-19 周五 16:05]
- State "TODO"       from              T:[2018-10-19 周五 16:04]
:END:
*** DONE 4. 转正党员备案名册(一份，xls)
CLOSED: [2018-10-19 周五 16:05]
:LOGBOOK:
- State "DONE"       from "TODO"          T:[2018-10-19 周五 16:05]
- State "TODO"       from              T:[2018-10-19 周五 16:01]
:END:
*** DONE 5. 预备党员教育考察情况表(2份，半年制,已打印)
CLOSED: [2018-10-19 周五 16:02]
:LOGBOOK:
- State "DONE"       from              T:[2018-10-19 周五 16:02]
:END:
（二十五）预备期内的教育和考察
党支部应当通过党的组织生活、听取本人汇报、个别谈心、
集中培训、实践锻炼等方式，对预备党员进行教育和考察。
一般应由预备党员的入党介绍人继续担负教育考察的责任。
入党介绍人、党支部分别将教育考察情况写入《预备党员教
育考察情况表》（参考模板14），发现问题要及时同本人谈话。

每半年一次，2张纸
*** 预备党员接受大会，自述一年内的经历

预备党员

*** 时间节点
（二十八）召开讨论预备党员转正的支部大会
党支部应在预备党员预备期满一个月内召开支部大会，讨论其能否
转为正式党员，不得无故提前或拖延。认真履行党员义务、具备党
员条件的，应当按期转为正式党员；需要继续考察和教育的，可以
延长一次预备期，延长时间不能少于半年，最长不超过一年；不履
行党员义务、不具备党员条件的，应当取消其预备党员资格.
** 2天内干掉的坏事 [#B]                                             :@NCEPU:
:LOGBOOK:
CLOCK: [2018-10-19 周五 20:11]--[2018-10-19 周五 20:13] =>  0:02
:END:
                         Added: [2018-10-19 周五 20:11]
                         
                         
只不过有一件事情没把师姐夫交代的事情办好哈。

这两天去国谊宾馆帮忙整理，所有纸质版文件没问题，说是电子版少了几份，
没对好，电子版得新建Excel重新按照纸字版录入专家分数，给那边添点事情了。 
我其实知道电子版可能没有齐全，因为有3个u盘传来传去，覆盖来覆盖去(打印
的文件没问题，都是最新版，一有最新我们就打印出来，就是电子版出点小意外），
快到结束的时候，我看组长也没想到核对一下，只是确认一下纸质版数目。 以后
工作的时候，我也得尽量吧我觉得有疑问的地方提出来（即使大家着急走，我也得
核对清楚），省的事后时候留下麻烦。
** 车管所驾照期满换证 [#B]                                          :@NCEPU:
:LOGBOOK:
CLOCK: [2018-10-20 周六 14:27]--[2018-10-20 周六 15:27] =>  1:00
:END:
                         Added: [2018-10-20 周六 14:27]
                         
                         
http://www.bjjtgl.gov.cn/jgj/94025/index.html

车管所查询

http://www.bjjtgl.gov.cn/map/Index.html?type=%E8%BD%A6%E7%AE%A1%E6%89%80


周一至周五 8:30 ~ 18:00
周六、日  9:30~16:00
** perl读取一个文件夹内所有txt文件 [#B]                               :perl:
:LOGBOOK:
CLOCK: [2018-10-21 周日 01:10]--[2018-10-21 周日 01:27] =>  0:17
:END:
                         Added: [2018-10-21 周日 01:10]
                         
                         
有时候，你需要不断往一个文件夹内添加记录数据，比如`20180912.txt`
`20180913.txt`,`20180914.txt`等

而这些文件内只有一列数据，每一行都有其特殊的含义，有数字和字符串，比如

```
CY11
11
14
32
45
```

于是你定义了

#+BEGIN_SRC perl
  my @cols=['data_name','math','chem','phys','body'];

#+END_SRC

把这些数据都按照cols中的字段进行映射
也就是
data_name='CY11'
math=11
chem=14
phys=32
body=45

于是你就想着定一个引用

#+BEGIN_SRC perl
  my %rec;
  $rec[@cols]=@temp;
#+END_SRC


@temp如何获取就是一番尝试后的结果

学习到chomp的使用，chomp默认返回值是1，不是你要处理的字符串
也就是chomp $_,得到的返回值是1，而真正你需要的是$_,此时经过
chomp处理之后，该新值不包含换行符

于是我们逐个对文件进行记录


#+BEGIN_SRC perl
  while(<fileOpen>)
  {
      chomp $_;
      $rec{$cols[$count]} = $_;
      $count=$count+1;
  }
#+END_SRC


于是你就会想着把rec hash类型存入数组中，于是就有了

#+BEGIN_SRC perl
  push @records, \%rec;
#+END_SRC

但是你发现每次插入的都是最新的数据，而不是保留原先数值的情况继续插入
这是因为在循环遍历每个文件的时候，都得my %rec,这样才会使得每一次的
%rec对应的pointer都是不一样的内存地址，这样你存入的数据才是最新的，
且不会覆盖原先的数据。之所以没存上，只保留最后一个最新的数据，就是因为
没有把my %rec放在循环内部里头。 这是必须记得，因为%rec是一个引用值。
只有其发生变化才是有效的push过程， 也就是在每一个迭代过程中都得
新建hash 值



#+BEGIN_SRC perl
  opendir my $dirOpen, $dirOpen_file_name
  my @txtFileList=grep(/.txt$/,readdir $dirOpen);

  while(<dirOpen>)
  {
      my %rec;
      $count=0;
      open $<fileOpen>, '<',$file_Open_file_name
      while(<$fileOpen>)
       {
           chomp $_;
           $rec{$cols[$count]}=$_;
           $count=$count+1;
         }
    
      push @records,\%rec;
     
      close $<fileOpen>


  }

  closedir $dirOpen;
#+END_SRC


实际最终的实现:


#+BEGIN_SRC perl
  #!/usr/bin/env perl
  #===============================================================================
  #
  #         FILE: analysisDirectory.pl
  #
  #        USAGE: ./analysisDirectory.pl  
  #
  #  DESCRIPTION: 
  #
  #      OPTIONS: ---
  # REQUIREMENTS: ---
  #         BUGS: ---
  #        NOTES: ---
  #       AUTHOR: Ye Zhao Liang (YZL), yezhaoliang@ncepu.edu.cn
  # ORGANIZATION: NCEPU
  #      VERSION: 1.0
  #      CREATED: 2018/10/20 22:29:12
  #     REVISION: ---
  #===============================================================================

  use strict;
  use warnings;
  use utf8;
  use Data::Dumper;
  use File::Spec;

  my  $dir_name='C:\\Users\\yzl\\perl\\testTXT\\';


  my	$dirOpen_file_name = "$dir_name";# input file name

  opendir  my $dirOpen, $dirOpen_file_name
      or die  "$0 : failed to open  input file '$dirOpen_file_name' : $!\n";

  my  @txtFileList = grep(/.txt$/,readdir $dirOpen);

  my @cols = ('data_name', 'f1', 'f2','f3','f4');

  my @records;

  my  $count; 

   foreach my $txtFile ( @txtFileList ) {
       print File::Spec->catfile($dir_name,$txtFile),"\n";

       my	$fileOpen_file_name = File::Spec->catfile($dir_name,$txtFile);		# input file name

       open  my $fileOpen, '<', $fileOpen_file_name
           or die  "$0 : failed to open  input file '$fileOpen_file_name' : $!\n";

    
       ## you must put it here, because rec need to be changed with pointer!
       # when define with my, it means requst for the new memory, or it will
       # use the old memory address
      my	%rec;
       $rec{'file_name'}=$txtFile;
       ## directly
       # @temp=<$fileOpen>;
       $count=0; 
       while ( <$fileOpen> ) {
           #print "$_\n";
           # $rec{$cols[$count]}=chomp($_);
           #my  @temp1=split /" "/;
           chomp $_; ## return1
            # print "while:",$cols[$count], chomp $temp1[0]," \n";
            # print "while:",$cols[$count], $_," \n";
            $rec{$cols[$count]}=$_;
           $count=$count+1;
       }

       # print "temp length $temp[0] : @temp\n";
       #print Dumper \@temp,"\n";
       #$rec{@cols}=@temp;
       #$rec{@cols}=split /\\n/ <$fileOpen>;

        push @records,\%rec;

       #  print Dumper \%rec,"\n";
       #  print "The newest array:\n";
       #  print Dumper \@records,"\n";

       close  $fileOpen
           or warn "$0 : failed to close input file '$fileOpen_file_name' : $!\n";

  }

   # print "OKKKKKK\n";
   # print Dumper \@records,"\n";
   #
   #

   foreach ( @records ) {
       print "$_->{'file_name'} $_->{'data_name'} $_->{'f1'}   $_->{'f2'}   $_->{'f3'}   $_->{'f4'}\n";
   }



  closedir  $dirOpen
      or warn "$0 : failed to close input file '$dirOpen_file_name' : $!\n";



#+END_SRC
** perl创建匿名hash array [#B]                                        :perl:
:LOGBOOK:
CLOCK: [2018-10-21 周日 16:14]--[2018-10-21 周日 17:57] =>  1:43
:END:
                         Added: [2018-10-21 周日 16:14]
                         
                         
                         
https://www.xuebuyuan.com/1424600.html
[ ITEMS ] 创建了一个新的、匿名的数组，并返回一个指向这个数组的'引用'。 
{ ITEMS } 创建了一个新的、匿名的哈希，并返回那个哈希的一个'引用'。 

#+BEGIN_SRC perl
      $aref = [ 1, "foo", undef, 13 ];   
      # $aref 保存了这个数组的'引用' 
      $href = { APR =>; 4, AUG =>; 8 };    
      # $href 保存了这个哈希的'引用' 
#+END_SRC


如何传递数组到子程序？

一般使用@_或者shift逐个弹出，@_直接幅值


#+BEGIN_SRC perl
  ## define
   sub statisticsRec{
       # you cannot use $_ instead
       my  $res=shift;
    
       print Dumper $res,"\n";
       my $countF1=0;
       foreach my $record ( @$res ) {
          $countF1=$countF1+$record->{"f1"};
          print $record->{'data_name'}," ",$record->{'f1'},"\n";
       }
       print "F1 sum is : $countF1\n";
   }



  ## usage
  statisticsRec(\@records);
#+END_SRC



*** 统计函数加入了判断



#+BEGIN_SRC perl
  sub statisticsRec{
       # you cannot use $_ instead
       my  $res=shift;
    
       print Dumper $res,"\n";
       my $countCYF1=0;
       my $countDJF1=0;
       foreach my $record ( @$res ) {
        
           if ( $record->{'data_name'}  =~ m/CY/xm) {
              $countCYF1=$countCYF1+$record->{"f1"};
              print "** CY : ",$record->{'data_name'}," ",$record->{'f1'},"\n";
           }
           elsif ( $record->{'data_name'}  =~ m/DJ/xm) {
              $countDJF1=$countDJF1+$record->{"f1"};
              print "** DJ : ",$record->{'data_name'}," ",$record->{'f1'},"\n";
           }
           else {
              print "**** Not CY and DJ: ",$record->{'data_name'}," ",$record->{'f1'},"\n";
           }
          print $record->{'data_name'}," ",$record->{'f1'},"\n";
       }
       print "CY F1 sum is : $countCYF1", "\t DJ F1 sum is : $countDJF1 \n";
   }

#+END_SRC
** 查看重复中文 [#B]                                                :@NCEPU:
:LOGBOOK:
CLOCK: [2018-10-22 周一 20:24]--[2018-10-22 周一 20:24] =>  0:00
- Clocked out on T:[2018-10-22 周一 20:24]
:END:
                         Added: [2018-10-22 周一 20:24]
                         
                         
                         
使用正则表达式测试序工具
([\u4e00-\u9fa5\w])\1+

([a-zA-Z0-9]+)\1+  查找重复英文
** delimited continuous for clojure [#B]                           :clojure:
:LOGBOOK:
CLOCK: [2018-10-23 周二 17:21]--[2018-10-23 周二 17:23] =>  0:02
:END:
                         Added: [2018-10-23 周二 17:21]
                         


                         
clojure趋势
 https://trends.google.com/trends/explore?q=%2Fm%2F0_lcrx4,%2Fm%2F091hdj,%2Fm%2F03yb8hb                        

https://github.com/swannodette/delimc?tdsourcetag=s_pctim_aiomsg

不过 Clojure 确实少一个杀手级的应用，Scala 有 kafka/play， Kotlin 有 android
'
storm 基本被 jstorm 取代了
要玩就玩scratch
** c语言输出正弦曲线点 [#B]                                         :@NCEPU:
:LOGBOOK:
CLOCK: [2018-11-01 周四 16:31]--[2018-11-01 周四 16:32] =>  0:01
:END:
                         Added: [2018-11-01 周四 16:30]
                         

#+BEGIN_SRC C
#include <math.h>
#include <stdio.h>

void main(){
    double pi = 3.1415926535;
    double x, y;
    double t;
    double frequency=0.1;
    for(t=0;t<20;t=t+0.1){
    x = t;
    y = 10*sin( 2* pi * frequency * t );

    printf("%f,%f\n",x,y);
    }
    /** printf( "sin( %f ) = %f\n", x, y ); */
    /** y = sinh( x ); */
    /** printf( "sinh( %f ) = %f\n",x, y ); */
    /** y = cos( x ); */
    /** printf( "cos( %f ) = %f\n", x, y ); */
    /** y = cosh( x ); */
    /** printf( "cosh( %f ) = %f\n",x, y );     */
}

#+END_SRC
** 什么是数据结构 [#B]                                              :@NCEPU:
:LOGBOOK:
CLOCK: [2018-11-04 周日 17:02]--[2018-11-05 周一 14:12] => 21:10
:END:
                         Added: [2018-11-04 周日 17:02]
                         
                         
数据结构的研究是数据的存储和数据的操作的一门学问

数据的存储分为两部分:
1. 个体的存储
2. 个体关系的存储
   从某个角度而言，数据的存储最核心的就是个体关系的存储，
   个体的存储忽略不计（额不错）
** 分布式存储对大并行计算有必要? [#B]                               :@NCEPU:
:LOGBOOK:
CLOCK: [2018-11-05 周一 15:00]--[2018-11-06 周二 18:36] => 27:36
:END:
                         Added: [2018-11-05 周一 14:59]
                         
                         
分布式存储对于大并行计算有必要？

如果几个通道的计算同时访问一块机子，是否会造成访问冗余

分布式存储和分布式计算？

分布式存储(先存储后计算，GFS ,HDFS)

分布式的并行计算技术
大数据主要环节：

　　数据准备--->数据存储和管理--->计算处理--->数据分析--->知识展现

在数据存储和管理中，GFS（谷歌文件系统，GOOGLE FILE SYSTEM）和HDFS（Hadoop的分布式文件系统）是奠定了大数据存储技术的基础。GFS/HDFS能避免在数据密集计算中容易形成的输入/输出吞吐量限制，且有较高的并发访问能力，能在大文件的追加写入和读取时能获得很高的性能，但随机访问、海量小文件的频繁写入性能较低。当然除了GFS/HDFS，是针对海量数据的文件系统，还有BigTable和Hadoop Hbase等非关系型数据库，它们针对非结构化的数据存储管理。

批计算：

　　Hadoop：是一个提供分布式存储和计算的软件框架，它具有无共享、高可用、弹性可扩展的特点，非常适合处理海量数据，先存储再计算。包含计算框架MapReduce（Google File System的开源实现）和分布式文件系统HDFS（Google MapReduce的开源实现），更广泛的说还包括其生态系统上的其他系统，如Hbase、Hive等。

　　Apache Hadoop MapReduce 大数据计算软件架构能满足“先存储再计算”的离线批量计算，但时延过大，在机器学习迭代、流处理、大规模图数据处理方面很有局限性。但在Hadoop 2.0 中推出的新一代MapReduce 架构将原来MapReduce中的任务调度和资源管理功能分离，形成与任务无关的资源管理层（YARN）。 YARN对上支持批处理、流处理、图计算等新结构模型，对下负责物理资源的统一管理。

实时批计算：

　　Spark：基于内存计算、支持快速迭代的的大数据并行计算框架。 适用于一切的分布式处理方案。

　　Spark比MapReduce更加高效，数据处理速度更快。可以作为MapReduce的替代方案，并且兼容HDFS、Hive等分布式存储层，可以融入Hadoop的生态系统，可以弥补MapReduce的不足。

流计算：

　　Strom：针对“边达到边计算”的实时流计算框架，可在一个时间窗口上对数据流进行在线实时分析。

　　同样的还有Yahoo提出的S4系统也是针对流计算的。

图计算：

　　Pregel：主要用于绘制大量网上信息之间关系的“图形数据库”。是面向图结构优化,一个可伸缩的分布式迭代图处理系统计算框架，灵感来自 BSP (bulk synchronous parallel) 和 Google 的 Pregel。

交互查询：

　　Dremel：Google 的“交互式”数据分析系统。可以组建成规模上千的集群，处理PB级别的数据，可实现快速交互查询。

　　Drill是Dremel的开源实现。

在数据分析中，机器学习毫无疑问是最佳的实现方法，其中最核心的为算法。

算法：

　　有工程学方法和模拟法两种。

　　模拟法又分为进化算法和人工神经网络算法两种。

进化算法以达尔文的进化思想为基础，通过选择、重组、变异三种操作方法优化问题求解。

人工神经网络算法是根据逻辑规则进行推理的过程。



https://book.2cto.com/201408/45626.html

图1-14展示了Hadoop系统的分布式存储和并行计算构架。从硬件体系结构上看，Hadoop系统是一个运行于普通的商用服务器集群的分布式存储和并行计算系统。集群中将有一个主控节点用来控制和管理整个集群的正常运行，并协调管理集群中各个从节点完成数据存储和计算任务。每个从节点将同时担任数据存储节点和数据计算节点两种角色，这样设计的目的主要是在大数据环境下实现尽可能的本地化计算，以此提高系统的处理性能。为了能及时检测和发现集群中某个从节点发生故障失效，主控节点采用心跳机制（Heartbeat）定期检测从节点，如果从节点不能有效回应心跳信息，则系统认为这个从节点失效。

 

从软件系统角度看，Hadoop系统包括分布式存储和并行计算两个部分。分布式存储构架上，Hadoop基于每个从节点上的本地文件系统，构建一个逻辑上整体化的分布式文件系统，以此提供大规模可扩展的分布式数据存储功能，这个分布式文件系统称为HDFS（Hadoop Distributed File System），其中，负责控制和管理整个分布式文件系统的主控节点称为NameNode，而每个具体负责数据存储的从节点称为DataNode。

进一步，为了能对存储在HDFS中的大规模数据进行并行化的计算处理，Hadoop又提供了一个称为MapReduce的并行化计算框架。该框架能有效管理和调度整个集群中的节点来完成并行化程序的执行和数据处理，并能让每个从节点尽可能对本地节点上的数据进行本地化计算，其中，负责管理和调度整个集群进行计算的主控节点称为JobTracker，而每个负责具体的数据计算的从节点称为TaskTracker。JobTracker可以与负责管理数据存储的主控节点NameNode设置在同一个物理的主控服务器上，在系统规模较大、各自负载较重时两者也可以分开设置。但数据存储节点DataNode与计算节点TaskTracker会配对地设置在同一个物理的从节点服务器上。

Hadoop系统中的其他子系统，例如HBase、Hive等，将建立在上述HDFS分布式文件系统和MapReduce并行化计算框架之上。


　　HDFS是Hadoop应用程序使用的主要分布式存储，主要被设计在商用硬件上运行，也就是说，他必须满足低成本、高容错、高吞吐的特性才能在众多的分布式存储系统中脱颖而出。



分布式存储白话说
　　假设现在有一个1000MB的文件需要存储，首先HDFS先将这1000MB的文件分割成128MB大小的数据块,分别为1,2,3….8号，先
对每个块复制2次，那么现在每个数据其实有3份； 
　　接下来主节点（NameNode）会看看集群中的从节点（DataNode）哪些的空间比较大，
将8*3的这些block分配到各个节点上，但必须保证每个block只能在一个从节点存储，额，也就是在 从节点 003号上只能存3号 block一次，另外2个3号block放到其他的 从节点 上
** en-completion-words [#B]                                      :emacslisp:
:LOGBOOK:
CLOCK: [2018-11-10 周六 09:35]--[2018-11-10 周六 09:41] =>  0:06
:END:
                         Added: [2018-11-10 周六 09:35]
                         
                         
https://emacs-china.org/t/company/6322/113

不错的补全单词
** 捕捉未来的jokes [#B]                                             :@NCEPU:
:LOGBOOK:
CLOCK: [2018-11-11 周日 13:57]--[2018-11-11 周日 13:59] =>  0:02
:END:
                         Added: [2018-11-11 周日 13:57]
                         
                         
有些政策性的笑话，可能会延续到将来某一阶段，待那时才讲述出来。
比如黄西在C-span的演讲
** markdown编辑网页 [#B]                                         :emacslisp:
:LOGBOOK:
CLOCK: [2018-11-14 周三 12:47]--[2018-11-14 周三 12:47] =>  0:00
:END:
                         Added: [2018-11-14 周三 12:47]
                         
                         
http://pandao.github.io/editor.md/examples/themes.html?tdsourcetag=s_pctim_aiomsg
** IDO mode [#B]                                                 :emacslisp:
:LOGBOOK:
CLOCK: [2018-11-19 周一 20:35]--[2018-11-19 周一 20:36] =>  0:01
:END:
                         Added: [2018-11-19 周一 20:34]
                         
                         
IDO: Interactive Do things!

According to Mickey, IDO is the greatest thing

https://github.com/howardabrams/dot-files/blob/master/emacs.org#ido-interactively-do-things
** the brain9几个用法 [#B]                                          :@NCEPU:
:LOGBOOK:
CLOCK: [2018-11-23 周五 12:57]--[2018-11-23 周五 13:11] =>  0:14
:END:
                         Added: [2018-11-23 周五 12:57]
                         
                         
1. 更加丰富的note风格
2. 更加方便的child created(f6),parent created(f7), jump created(f8), 通过分号进行划分，比如 1;2;3;4会创建4个节点
3. 可以遗忘节点，然后options可以显示被遗忘的节点，可以右键被遗忘节点选择删除和记起（符合人脑的记忆）
    当右键单击想法的同时按住shift，出来的菜单里面就是“删除”而不是“遗忘”了（默认右键是遗忘forget)。
    呵呵，提醒一下，点击有风险，删除需谨慎
4. 可以创建pin节点，快速切入
5. Ctrl+左键可创立选集，然后遗忘和删除等
** after-init-hook [#B]                                          :emacslisp:
:LOGBOOK:
CLOCK: [2018-11-26 周一 13:30]--[2018-11-26 周一 13:30] =>  0:00
- Clocked out on T:[2018-11-26 周一 13:30] \\
  fine
:END:
                         Added: [2018-11-26 周一 13:29]
                         
                         
是的, 其实用after-init-hook的延迟加载时是一个相当自欺欺人的事情, 现在我用这个hook加载的,
 一般是evil-mode这种十万火急的mode以及keyfreq和super-save这种与编辑文本如影随形悄无声息的mode.

对于ivy, 我参考doom-emacs的方式, 用run-with-idle-timer加载, 同时在pre-command-hook挂临时钩子.
 一旦有命令运行, 就立刻强制(require 'ivy) 加载. 这样感觉上会比挂在after-init-hook好不少.
 company就直接用run-with-idle-timer就完事了.

其实最让我烦躁的就是lisp-interaction-mode, 这个模式名不副实. 想象一下如果我要写一段代码,
 为什么我不用elisp-mode, 如果要交互式运行, 为什么不用ielm-mode呢?
 最恶心的是这个小东西是开始时随着*scratch*被强制加载的, 还属于prog-mode.
 导致一票诸如aggressive-indent-mode lispy hs-minor-mode 也被这个家伙加载起来了.
 事实上我们用scratch buffer并不会立马用到这么多高级功能. 它一开emacs就加载反而影响我的体验.
